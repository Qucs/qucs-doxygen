<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Qucs-core: nasolver.cpp Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Qucs-core
   &#160;<span id="projectnumber">0.0.19</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">nasolver.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<a href="nasolver_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * nasolver.cpp - nodal analysis solver class implementation</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> * Copyright (C) 2004, 2005, 2006, 2007, 2008 Stefan Jahn &lt;stefan@lkcc.org&gt;</span>
<a name="l00005"></a>00005 <span class="comment"> *</span>
<a name="l00006"></a>00006 <span class="comment"> * This is free software; you can redistribute it and/or modify</span>
<a name="l00007"></a>00007 <span class="comment"> * it under the terms of the GNU General Public License as published by</span>
<a name="l00008"></a>00008 <span class="comment"> * the Free Software Foundation; either version 2, or (at your option)</span>
<a name="l00009"></a>00009 <span class="comment"> * any later version.</span>
<a name="l00010"></a>00010 <span class="comment"> *</span>
<a name="l00011"></a>00011 <span class="comment"> * This software is distributed in the hope that it will be useful,</span>
<a name="l00012"></a>00012 <span class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00013"></a>00013 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00014"></a>00014 <span class="comment"> * GNU General Public License for more details.</span>
<a name="l00015"></a>00015 <span class="comment"> *</span>
<a name="l00016"></a>00016 <span class="comment"> * You should have received a copy of the GNU General Public License</span>
<a name="l00017"></a>00017 <span class="comment"> * along with this package; see the file COPYING.  If not, write to</span>
<a name="l00018"></a>00018 <span class="comment"> * the Free Software Foundation, Inc., 51 Franklin Street - Fifth Floor,</span>
<a name="l00019"></a>00019 <span class="comment"> * Boston, MA 02110-1301, USA.</span>
<a name="l00020"></a>00020 <span class="comment"> *</span>
<a name="l00021"></a>00021 <span class="comment"> * $Id$</span>
<a name="l00022"></a>00022 <span class="comment"> *</span>
<a name="l00023"></a>00023 <span class="comment"> */</span>
<a name="l00024"></a>00024 
<a name="l00025"></a>00025 <span class="comment">// the types required for qucs library files are defined</span>
<a name="l00026"></a>00026 <span class="comment">// in qucs_typedefs.h, created by configure from</span>
<a name="l00027"></a>00027 <span class="comment">// qucs_typedefs.h.in</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &quot;<a class="code" href="qucs__typedefs_8h.html">qucs_typedefs.h</a>&quot;</span>
<a name="l00029"></a>00029 
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &lt;cmath&gt;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &lt;float.h&gt;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &lt;assert.h&gt;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &lt;limits&gt;</span>
<a name="l00037"></a>00037 
<a name="l00038"></a>00038 <span class="preprocessor">#include &quot;<a class="code" href="logging_8h.html">logging.h</a>&quot;</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &quot;<a class="code" href="complex_8h.html">complex.h</a>&quot;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#include &quot;<a class="code" href="object_8h.html">object.h</a>&quot;</span>
<a name="l00041"></a>00041 <span class="preprocessor">#include &quot;<a class="code" href="node_8h.html">node.h</a>&quot;</span>
<a name="l00042"></a>00042 <span class="preprocessor">#include &quot;<a class="code" href="circuit_8h.html" title="The circuit class header file.">circuit.h</a>&quot;</span>
<a name="l00043"></a>00043 <span class="preprocessor">#include &quot;<a class="code" href="vector_8h.html">vector.h</a>&quot;</span>
<a name="l00044"></a>00044 <span class="preprocessor">#include &quot;<a class="code" href="dataset_8h.html">dataset.h</a>&quot;</span>
<a name="l00045"></a>00045 <span class="preprocessor">#include &quot;<a class="code" href="net_8h.html">net.h</a>&quot;</span>
<a name="l00046"></a>00046 <span class="preprocessor">#include &quot;<a class="code" href="analysis_8h.html" title="The analysis class header file.">analysis.h</a>&quot;</span>
<a name="l00047"></a>00047 <span class="preprocessor">#include &quot;<a class="code" href="nodelist_8h.html">nodelist.h</a>&quot;</span>
<a name="l00048"></a>00048 <span class="preprocessor">#include &quot;<a class="code" href="nodeset_8h.html">nodeset.h</a>&quot;</span>
<a name="l00049"></a>00049 <span class="preprocessor">#include &quot;<a class="code" href="strlist_8h.html">strlist.h</a>&quot;</span>
<a name="l00050"></a>00050 <span class="preprocessor">#include &quot;<a class="code" href="tvector_8h.html">tvector.h</a>&quot;</span>
<a name="l00051"></a>00051 <span class="preprocessor">#include &quot;<a class="code" href="tmatrix_8h.html">tmatrix.h</a>&quot;</span>
<a name="l00052"></a>00052 <span class="preprocessor">#include &quot;<a class="code" href="eqnsys_8h.html">eqnsys.h</a>&quot;</span>
<a name="l00053"></a>00053 <span class="preprocessor">#include &quot;<a class="code" href="precision_8h.html">precision.h</a>&quot;</span>
<a name="l00054"></a>00054 <span class="preprocessor">#include &quot;<a class="code" href="operatingpoint_8h.html">operatingpoint.h</a>&quot;</span>
<a name="l00055"></a>00055 <span class="preprocessor">#include &quot;<a class="code" href="exception_8h.html">exception.h</a>&quot;</span>
<a name="l00056"></a>00056 <span class="preprocessor">#include &quot;<a class="code" href="exceptionstack_8h.html">exceptionstack.h</a>&quot;</span>
<a name="l00057"></a>00057 <span class="preprocessor">#include &quot;<a class="code" href="nasolver_8h.html">nasolver.h</a>&quot;</span>
<a name="l00058"></a>00058 <span class="preprocessor">#include &quot;<a class="code" href="constants_8h.html" title="Global physical constants header file.">constants.h</a>&quot;</span>
<a name="l00059"></a>00059 
<a name="l00060"></a>00060 <span class="keyword">namespace </span><a class="code" href="structqucs.html">qucs</a> {
<a name="l00061"></a>00061 
<a name="l00062"></a>00062 <span class="comment">// Constructor creates an unnamed instance of the nasolver class.</span>
<a name="l00063"></a>00063 <span class="keyword">template</span> &lt;<span class="keyword">class</span> nr_type_t&gt;
<a name="l00064"></a><a class="code" href="classqucs_1_1nasolver.html#a8942d5deb731c62389b4b9ad6939c2a1">00064</a> <a class="code" href="classqucs_1_1nasolver.html">nasolver&lt;nr_type_t&gt;::nasolver</a> () : analysis ()
<a name="l00065"></a>00065 {
<a name="l00066"></a>00066     <a class="code" href="classqucs_1_1nasolver.html#a1cd43e1591e2aa3936e7e468a590f5b1">nlist</a> = NULL;
<a name="l00067"></a>00067     <a class="code" href="eqndefined_8cpp.html#a70993d52766e31cb0157958a18aa499a">A</a> = <a class="code" href="eqndefined_8cpp.html#ad1368c2a0fa68385ecdd9f1016563c08">C</a> = NULL;
<a name="l00068"></a>00068     <a class="code" href="classqucs_1_1nasolver.html#a7c9d1ec2bd181d6b261117381261d2ce">z</a> = <a class="code" href="parse__mdl_8y.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a> = <a class="code" href="classqucs_1_1nasolver.html#a8601e2b4bec09565bc457bedef420926">xprev</a> = <a class="code" href="classqucs_1_1nasolver.html#ab43e68c47a8e90569b40ddda6fa5e6a7">zprev</a> = NULL;
<a name="l00069"></a>00069     <a class="code" href="classqucs_1_1nasolver.html#ac01365b31972d8671621d42d4006060e">reltol</a> = <a class="code" href="classqucs_1_1nasolver.html#a9fe5ef32ce79bec66725343056131350">abstol</a> = <a class="code" href="classqucs_1_1nasolver.html#a097abf55ba19b821a5c06ebbf540c18a">vntol</a> = 0;
<a name="l00070"></a>00070     <a class="code" href="classqucs_1_1nasolver.html#a1470a8ae4bf6de4c3f584cd5a18bc671">calculate_func</a> = NULL;
<a name="l00071"></a>00071     <a class="code" href="classqucs_1_1nasolver.html#af245824b9e76d362e6a595cd12c9d649">convHelper</a> = <a class="code" href="classqucs_1_1nasolver.html#a8f8dc8c641e500af26aa4a3dbddf602f">fixpoint</a> = 0;
<a name="l00072"></a>00072     <a class="code" href="classqucs_1_1nasolver.html#a6431ca92d391749f2025db3446fd2c68">eqnAlgo</a> = <a class="code" href="eqnsys_8h.html#a92b72228de8e945a7cbdf109a4e3c14fa6cea149798988dc30e1b4186f8a3c8dd">ALGO_LU_DECOMPOSITION</a>;
<a name="l00073"></a>00073     <a class="code" href="classqucs_1_1nasolver.html#a6523dbb0430b5517e9260b6ae11f7b7a">updateMatrix</a> = 1;
<a name="l00074"></a>00074     <a class="code" href="classqucs_1_1nasolver.html#ae8f71b8f5ca49368fb1ddeec8da2f718">gMin</a> = <a class="code" href="classqucs_1_1nasolver.html#a830b4636c91ed2b25552b15f61b12db0">srcFactor</a> = 0;
<a name="l00075"></a>00075     <a class="code" href="parse__netlist_8y.html#aad664ad10957bf531dcce47612c7677a">eqns</a> = <span class="keyword">new</span> <a class="code" href="classqucs_1_1eqnsys.html">eqnsys&lt;nr_type_t&gt;</a> ();
<a name="l00076"></a>00076 }
<a name="l00077"></a>00077 
<a name="l00078"></a>00078 <span class="comment">// Constructor creates a named instance of the nasolver class.</span>
<a name="l00079"></a>00079 <span class="keyword">template</span> &lt;<span class="keyword">class</span> nr_type_t&gt;
<a name="l00080"></a><a class="code" href="classqucs_1_1nasolver.html#a285543e2371415cf15770325ed9596d8">00080</a> <a class="code" href="classqucs_1_1nasolver.html">nasolver&lt;nr_type_t&gt;::nasolver</a> (<span class="keyword">const</span> <a class="code" href="namespacetesting_1_1internal.html#a5ca8a348395a6145775c1a2334e21889">std::string</a> &amp;<a class="code" href="parse__mdl_8y.html#aecba4cab5e52994730d1e21424997b33">n</a>) : analysis (n)
<a name="l00081"></a>00081 {
<a name="l00082"></a>00082     <a class="code" href="classqucs_1_1nasolver.html#a1cd43e1591e2aa3936e7e468a590f5b1">nlist</a> = NULL;
<a name="l00083"></a>00083     <a class="code" href="eqndefined_8cpp.html#a70993d52766e31cb0157958a18aa499a">A</a> = <a class="code" href="eqndefined_8cpp.html#ad1368c2a0fa68385ecdd9f1016563c08">C</a> = NULL;
<a name="l00084"></a>00084     <a class="code" href="classqucs_1_1nasolver.html#a7c9d1ec2bd181d6b261117381261d2ce">z</a> = <a class="code" href="parse__mdl_8y.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a> = <a class="code" href="classqucs_1_1nasolver.html#a8601e2b4bec09565bc457bedef420926">xprev</a> = <a class="code" href="classqucs_1_1nasolver.html#ab43e68c47a8e90569b40ddda6fa5e6a7">zprev</a> = NULL;
<a name="l00085"></a>00085     <a class="code" href="classqucs_1_1nasolver.html#ac01365b31972d8671621d42d4006060e">reltol</a> = <a class="code" href="classqucs_1_1nasolver.html#a9fe5ef32ce79bec66725343056131350">abstol</a> = <a class="code" href="classqucs_1_1nasolver.html#a097abf55ba19b821a5c06ebbf540c18a">vntol</a> = 0;
<a name="l00086"></a>00086     <a class="code" href="classqucs_1_1nasolver.html#a1470a8ae4bf6de4c3f584cd5a18bc671">calculate_func</a> = NULL;
<a name="l00087"></a>00087     <a class="code" href="classqucs_1_1nasolver.html#af245824b9e76d362e6a595cd12c9d649">convHelper</a> = <a class="code" href="classqucs_1_1nasolver.html#a8f8dc8c641e500af26aa4a3dbddf602f">fixpoint</a> = 0;
<a name="l00088"></a>00088     <a class="code" href="classqucs_1_1nasolver.html#a6431ca92d391749f2025db3446fd2c68">eqnAlgo</a> = <a class="code" href="eqnsys_8h.html#a92b72228de8e945a7cbdf109a4e3c14fa6cea149798988dc30e1b4186f8a3c8dd">ALGO_LU_DECOMPOSITION</a>;
<a name="l00089"></a>00089     <a class="code" href="classqucs_1_1nasolver.html#a6523dbb0430b5517e9260b6ae11f7b7a">updateMatrix</a> = 1;
<a name="l00090"></a>00090     <a class="code" href="classqucs_1_1nasolver.html#ae8f71b8f5ca49368fb1ddeec8da2f718">gMin</a> = <a class="code" href="classqucs_1_1nasolver.html#a830b4636c91ed2b25552b15f61b12db0">srcFactor</a> = 0;
<a name="l00091"></a>00091     <a class="code" href="parse__netlist_8y.html#aad664ad10957bf531dcce47612c7677a">eqns</a> = <span class="keyword">new</span> <a class="code" href="classqucs_1_1eqnsys.html">eqnsys&lt;nr_type_t&gt;</a> ();
<a name="l00092"></a>00092 }
<a name="l00093"></a>00093 
<a name="l00094"></a>00094 <span class="comment">// Destructor deletes the nasolver class object.</span>
<a name="l00095"></a>00095 <span class="keyword">template</span> &lt;<span class="keyword">class</span> nr_type_t&gt;
<a name="l00096"></a><a class="code" href="classqucs_1_1nasolver.html#ab1dfbfac18507849aef95964dc8919d7">00096</a> <a class="code" href="classqucs_1_1nasolver.html">nasolver&lt;nr_type_t&gt;::~nasolver</a> ()
<a name="l00097"></a>00097 {
<a name="l00098"></a>00098     <span class="keywordflow">if</span> (nlist) <span class="keyword">delete</span> nlist;
<a name="l00099"></a>00099     <span class="keywordflow">if</span> (<a class="code" href="eqndefined_8cpp.html#ad1368c2a0fa68385ecdd9f1016563c08">C</a>) <span class="keyword">delete</span> <a class="code" href="eqndefined_8cpp.html#ad1368c2a0fa68385ecdd9f1016563c08">C</a>;
<a name="l00100"></a>00100     <span class="keyword">delete</span> <a class="code" href="eqndefined_8cpp.html#a70993d52766e31cb0157958a18aa499a">A</a>;
<a name="l00101"></a>00101     <span class="keyword">delete</span> z;
<a name="l00102"></a>00102     <span class="keyword">delete</span> <a class="code" href="parse__mdl_8y.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>;
<a name="l00103"></a>00103     <span class="keyword">delete</span> xprev;
<a name="l00104"></a>00104     <span class="keyword">delete</span> zprev;
<a name="l00105"></a>00105     <span class="keyword">delete</span> <a class="code" href="parse__netlist_8y.html#aad664ad10957bf531dcce47612c7677a">eqns</a>;
<a name="l00106"></a>00106 }
<a name="l00107"></a>00107 
<a name="l00108"></a>00108 <span class="comment">/* The copy constructor creates a new instance of the nasolver class</span>
<a name="l00109"></a>00109 <span class="comment">   based on the given nasolver object. */</span>
<a name="l00110"></a>00110 <span class="keyword">template</span> &lt;<span class="keyword">class</span> nr_type_t&gt;
<a name="l00111"></a><a class="code" href="classqucs_1_1nasolver.html#ac1e08af13e7fcc31318f3f09a8235c40">00111</a> <a class="code" href="classqucs_1_1nasolver.html">nasolver&lt;nr_type_t&gt;::nasolver</a> (<a class="code" href="classqucs_1_1nasolver.html">nasolver</a> &amp; o) : analysis (o)
<a name="l00112"></a>00112 {
<a name="l00113"></a>00113     <a class="code" href="classqucs_1_1nasolver.html#a1cd43e1591e2aa3936e7e468a590f5b1">nlist</a> = o.<a class="code" href="classqucs_1_1nasolver.html#a1cd43e1591e2aa3936e7e468a590f5b1">nlist</a> ? <span class="keyword">new</span> <a class="code" href="classqucs_1_1nodelist.html">nodelist</a> (*(o.<a class="code" href="classqucs_1_1nasolver.html#a1cd43e1591e2aa3936e7e468a590f5b1">nlist</a>)) : NULL;
<a name="l00114"></a>00114     <a class="code" href="eqndefined_8cpp.html#a70993d52766e31cb0157958a18aa499a">A</a> = o.<a class="code" href="classqucs_1_1nasolver.html#ac46d2e86bd0726554c4edee0b882d6b4">A</a> ? <span class="keyword">new</span> <a class="code" href="classqucs_1_1tmatrix.html">tmatrix&lt;nr_type_t&gt;</a> (*(o.<a class="code" href="classqucs_1_1nasolver.html#ac46d2e86bd0726554c4edee0b882d6b4">A</a>)) : NULL;
<a name="l00115"></a>00115     <a class="code" href="eqndefined_8cpp.html#ad1368c2a0fa68385ecdd9f1016563c08">C</a> = o.<a class="code" href="classqucs_1_1nasolver.html#ab045b75672428d6576672a8ddae829b3">C</a> ? <span class="keyword">new</span> <a class="code" href="classqucs_1_1tmatrix.html">tmatrix&lt;nr_type_t&gt;</a> (*(o.<a class="code" href="classqucs_1_1nasolver.html#ab045b75672428d6576672a8ddae829b3">C</a>)) : NULL;
<a name="l00116"></a>00116     <a class="code" href="classqucs_1_1nasolver.html#a7c9d1ec2bd181d6b261117381261d2ce">z</a> = o.<a class="code" href="classqucs_1_1nasolver.html#a7c9d1ec2bd181d6b261117381261d2ce">z</a> ? <span class="keyword">new</span> <a class="code" href="classqucs_1_1tvector.html">tvector&lt;nr_type_t&gt;</a> (*(o.<a class="code" href="classqucs_1_1nasolver.html#a7c9d1ec2bd181d6b261117381261d2ce">z</a>)) : NULL;
<a name="l00117"></a>00117     <a class="code" href="parse__mdl_8y.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a> = o.<a class="code" href="classqucs_1_1nasolver.html#a04596b58e70446c7fa14d832461c0f0b">x</a> ? <span class="keyword">new</span> <a class="code" href="classqucs_1_1tvector.html">tvector&lt;nr_type_t&gt;</a> (*(o.<a class="code" href="classqucs_1_1nasolver.html#a04596b58e70446c7fa14d832461c0f0b">x</a>)) : NULL;
<a name="l00118"></a>00118     <a class="code" href="classqucs_1_1nasolver.html#a8601e2b4bec09565bc457bedef420926">xprev</a> = <a class="code" href="classqucs_1_1nasolver.html#ab43e68c47a8e90569b40ddda6fa5e6a7">zprev</a> = NULL;
<a name="l00119"></a>00119     <a class="code" href="classqucs_1_1nasolver.html#ac01365b31972d8671621d42d4006060e">reltol</a> = o.<a class="code" href="classqucs_1_1nasolver.html#ac01365b31972d8671621d42d4006060e">reltol</a>;
<a name="l00120"></a>00120     <a class="code" href="classqucs_1_1nasolver.html#a9fe5ef32ce79bec66725343056131350">abstol</a> = o.<a class="code" href="classqucs_1_1nasolver.html#a9fe5ef32ce79bec66725343056131350">abstol</a>;
<a name="l00121"></a>00121     <a class="code" href="classqucs_1_1nasolver.html#a097abf55ba19b821a5c06ebbf540c18a">vntol</a> = o.<a class="code" href="classqucs_1_1nasolver.html#a097abf55ba19b821a5c06ebbf540c18a">vntol</a>;
<a name="l00122"></a>00122     <a class="code" href="classqucs_1_1nasolver.html#a50713fb9dd92b8ae9e781afea1e6dabc">desc</a> = o.<a class="code" href="classqucs_1_1nasolver.html#a50713fb9dd92b8ae9e781afea1e6dabc">desc</a>;
<a name="l00123"></a>00123     <a class="code" href="classqucs_1_1nasolver.html#a1470a8ae4bf6de4c3f584cd5a18bc671">calculate_func</a> = o.<a class="code" href="classqucs_1_1nasolver.html#a1470a8ae4bf6de4c3f584cd5a18bc671">calculate_func</a>;
<a name="l00124"></a>00124     <a class="code" href="classqucs_1_1nasolver.html#af245824b9e76d362e6a595cd12c9d649">convHelper</a> = o.<a class="code" href="classqucs_1_1nasolver.html#af245824b9e76d362e6a595cd12c9d649">convHelper</a>;
<a name="l00125"></a>00125     <a class="code" href="classqucs_1_1nasolver.html#a6431ca92d391749f2025db3446fd2c68">eqnAlgo</a> = o.<a class="code" href="classqucs_1_1nasolver.html#a6431ca92d391749f2025db3446fd2c68">eqnAlgo</a>;
<a name="l00126"></a>00126     <a class="code" href="classqucs_1_1nasolver.html#a6523dbb0430b5517e9260b6ae11f7b7a">updateMatrix</a> = o.<a class="code" href="classqucs_1_1nasolver.html#a6523dbb0430b5517e9260b6ae11f7b7a">updateMatrix</a>;
<a name="l00127"></a>00127     <a class="code" href="classqucs_1_1nasolver.html#a8f8dc8c641e500af26aa4a3dbddf602f">fixpoint</a> = o.<a class="code" href="classqucs_1_1nasolver.html#a8f8dc8c641e500af26aa4a3dbddf602f">fixpoint</a>;
<a name="l00128"></a>00128     <a class="code" href="classqucs_1_1nasolver.html#ae8f71b8f5ca49368fb1ddeec8da2f718">gMin</a> = o.<a class="code" href="classqucs_1_1nasolver.html#ae8f71b8f5ca49368fb1ddeec8da2f718">gMin</a>;
<a name="l00129"></a>00129     <a class="code" href="classqucs_1_1nasolver.html#a830b4636c91ed2b25552b15f61b12db0">srcFactor</a> = o.<a class="code" href="classqucs_1_1nasolver.html#a830b4636c91ed2b25552b15f61b12db0">srcFactor</a>;
<a name="l00130"></a>00130     <a class="code" href="parse__netlist_8y.html#aad664ad10957bf531dcce47612c7677a">eqns</a> = <span class="keyword">new</span> <a class="code" href="classqucs_1_1eqnsys.html">eqnsys&lt;nr_type_t&gt;</a> (*(o.<a class="code" href="classqucs_1_1nasolver.html#a308756d59046e187decaeca3ed4c8601">eqns</a>));
<a name="l00131"></a>00131     <a class="code" href="classqucs_1_1nasolver.html#aca203ba6aa5beca8f5c96f85d35ee77b">solution</a> = nasolution&lt;nr_type_t&gt; (o.<a class="code" href="classqucs_1_1nasolver.html#aca203ba6aa5beca8f5c96f85d35ee77b">solution</a>);
<a name="l00132"></a>00132 }
<a name="l00133"></a>00133 
<a name="l00134"></a>00134 <span class="comment">/* The function runs the nodal analysis solver once, reports errors if</span>
<a name="l00135"></a>00135 <span class="comment">   any and save the results into each circuit. */</span>
<a name="l00136"></a>00136 <span class="keyword">template</span> &lt;<span class="keyword">class</span> nr_type_t&gt;
<a name="l00137"></a><a class="code" href="classqucs_1_1nasolver.html#ab2d2856208954e2619e2a417775b3372">00137</a> <span class="keywordtype">int</span> <a class="code" href="classqucs_1_1nasolver.html">nasolver&lt;nr_type_t&gt;::solve_once</a> (<span class="keywordtype">void</span>)
<a name="l00138"></a>00138 {
<a name="l00139"></a>00139     qucs::exception * e;
<a name="l00140"></a>00140     <span class="keywordtype">int</span> error = 0, <a class="code" href="parse__spice_8y.html#a873684cefeb665f3d5e6b495de57fc0d">d</a>;
<a name="l00141"></a>00141 
<a name="l00142"></a>00142     <span class="comment">// run the calculation function for each circuit</span>
<a name="l00143"></a>00143     calculate ();
<a name="l00144"></a>00144 
<a name="l00145"></a>00145     <span class="comment">// generate A matrix and z vector</span>
<a name="l00146"></a>00146     createMatrix ();
<a name="l00147"></a>00147 
<a name="l00148"></a>00148     <span class="comment">// solve equation system</span>
<a name="l00149"></a>00149     <a class="code" href="exceptionstack_8h.html#a5123cac5cf3369997ae7bc31d5f1e1ce">try_running</a> ()
<a name="l00150"></a>00150     {
<a name="l00151"></a>00151         runMNA ();
<a name="l00152"></a>00152     }
<a name="l00153"></a>00153     <span class="comment">// appropriate exception handling</span>
<a name="l00154"></a>00154     <a class="code" href="exceptionstack_8h.html#a1bcd5362715dd5fbe069fdf9f9b96399">catch_exception</a> ()
<a name="l00155"></a>00155     {
<a name="l00156"></a>00156     <span class="keywordflow">case</span> <a class="code" href="structqucs.html#ac060e999cf6725990fdd6c65600a62e5a732ab89ae14ddf9050b060b500c84177">EXCEPTION_PIVOT</a>:
<a name="l00157"></a>00157     <span class="keywordflow">case</span> <a class="code" href="structqucs.html#ac060e999cf6725990fdd6c65600a62e5ad18fc025c516befe5ad71d8c37b2e2f3">EXCEPTION_WRONG_VOLTAGE</a>:
<a name="l00158"></a>00158         e = <span class="keyword">new</span> qucs::exception (<a class="code" href="structqucs.html#ac060e999cf6725990fdd6c65600a62e5a3c1af9a96319e176a41f5ceec5e529e4">EXCEPTION_NA_FAILED</a>);
<a name="l00159"></a>00159         <a class="code" href="parse__spice_8y.html#a873684cefeb665f3d5e6b495de57fc0d">d</a> = <a class="code" href="exceptionstack_8h.html#af6a3e10f858ba64bd0aee79b0bc2ca6c">top_exception</a>()-&gt;getData ();
<a name="l00160"></a>00160         <a class="code" href="exceptionstack_8h.html#aa539da6ed9b41bb5d7db0218eaceeab3">pop_exception</a> ();
<a name="l00161"></a>00161         <span class="keywordflow">if</span> (<a class="code" href="parse__spice_8y.html#a873684cefeb665f3d5e6b495de57fc0d">d</a> &gt;= countNodes ())
<a name="l00162"></a>00162         {
<a name="l00163"></a>00163             <a class="code" href="parse__spice_8y.html#a873684cefeb665f3d5e6b495de57fc0d">d</a> -= countNodes ();
<a name="l00164"></a>00164             e-&gt;setText (<span class="stringliteral">&quot;voltage source `%s&#39; conflicts with some other voltage &quot;</span>
<a name="l00165"></a>00165                         <span class="stringliteral">&quot;source&quot;</span>, findVoltageSource(<a class="code" href="parse__spice_8y.html#a873684cefeb665f3d5e6b495de57fc0d">d</a>)-&gt;getName ());
<a name="l00166"></a>00166         }
<a name="l00167"></a>00167         <span class="keywordflow">else</span>
<a name="l00168"></a>00168         {
<a name="l00169"></a>00169             e-&gt;setText (<span class="stringliteral">&quot;circuit admittance matrix in %s solver is singular at &quot;</span>
<a name="l00170"></a>00170                         <span class="stringliteral">&quot;node `%s&#39; connected to [%s]&quot;</span>, desc.c_str(), nlist-&gt;get (<a class="code" href="parse__spice_8y.html#a873684cefeb665f3d5e6b495de57fc0d">d</a>).c_str(),
<a name="l00171"></a>00171                         nlist-&gt;getNodeString (<a class="code" href="parse__spice_8y.html#a873684cefeb665f3d5e6b495de57fc0d">d</a>).c_str());
<a name="l00172"></a>00172         }
<a name="l00173"></a>00173         <a class="code" href="exceptionstack_8h.html#a8da005873bb805e4071f4b7cd9da6cdb">throw_exception</a> (e);
<a name="l00174"></a>00174         error++;
<a name="l00175"></a>00175         <span class="keywordflow">break</span>;
<a name="l00176"></a>00176     <span class="keywordflow">case</span> <a class="code" href="structqucs.html#ac060e999cf6725990fdd6c65600a62e5a84bd3ce68c950cf68d46959251897139">EXCEPTION_SINGULAR</a>:
<a name="l00177"></a>00177         <span class="keywordflow">do</span>
<a name="l00178"></a>00178         {
<a name="l00179"></a>00179             <a class="code" href="parse__spice_8y.html#a873684cefeb665f3d5e6b495de57fc0d">d</a> = <a class="code" href="exceptionstack_8h.html#af6a3e10f858ba64bd0aee79b0bc2ca6c">top_exception</a>()-&gt;getData ();
<a name="l00180"></a>00180             <a class="code" href="exceptionstack_8h.html#aa539da6ed9b41bb5d7db0218eaceeab3">pop_exception</a> ();
<a name="l00181"></a>00181             <span class="keywordflow">if</span> (<a class="code" href="parse__spice_8y.html#a873684cefeb665f3d5e6b495de57fc0d">d</a> &lt; countNodes ())
<a name="l00182"></a>00182             {
<a name="l00183"></a>00183                 <a class="code" href="logging_8c.html#abe06a8732a47a291606edcfac5e5146e">logprint</a> (<a class="code" href="logging_8h.html#aced66975c154ea0e2a8ec3bc818b4e08">LOG_ERROR</a>, <span class="stringliteral">&quot;WARNING: %s: inserted virtual resistance at &quot;</span>
<a name="l00184"></a>00184                           <span class="stringliteral">&quot;node `%s&#39; connected to [%s]\n&quot;</span>, getName (), nlist-&gt;get (<a class="code" href="parse__spice_8y.html#a873684cefeb665f3d5e6b495de57fc0d">d</a>).c_str(),
<a name="l00185"></a>00185                           nlist-&gt;getNodeString (<a class="code" href="parse__spice_8y.html#a873684cefeb665f3d5e6b495de57fc0d">d</a>).c_str());
<a name="l00186"></a>00186             }
<a name="l00187"></a>00187         }
<a name="l00188"></a>00188         <span class="keywordflow">while</span> (<a class="code" href="exceptionstack_8h.html#af6a3e10f858ba64bd0aee79b0bc2ca6c">top_exception</a>() != NULL &amp;&amp;
<a name="l00189"></a>00189                 <a class="code" href="exceptionstack_8h.html#af6a3e10f858ba64bd0aee79b0bc2ca6c">top_exception</a>()-&gt;getCode () == <a class="code" href="structqucs.html#ac060e999cf6725990fdd6c65600a62e5a84bd3ce68c950cf68d46959251897139">EXCEPTION_SINGULAR</a>);
<a name="l00190"></a>00190         <span class="keywordflow">break</span>;
<a name="l00191"></a>00191     <span class="keywordflow">default</span>:
<a name="l00192"></a>00192         <a class="code" href="structqucs.html#a99a68a2452092cafcd735a48a064a8bf">estack</a>.<a class="code" href="classqucs_1_1exceptionstack.html#a486af86b492f662998c8d7ced9ecd64f">print</a> ();
<a name="l00193"></a>00193         <span class="keywordflow">break</span>;
<a name="l00194"></a>00194     }
<a name="l00195"></a>00195 
<a name="l00196"></a>00196     <span class="comment">// save results into circuits</span>
<a name="l00197"></a>00197     <span class="keywordflow">if</span> (!error) saveSolution ();
<a name="l00198"></a>00198     <span class="keywordflow">return</span> error;
<a name="l00199"></a>00199 }
<a name="l00200"></a>00200 
<a name="l00201"></a>00201 <span class="comment">/* Run this function after the actual solver run and before evaluating</span>
<a name="l00202"></a>00202 <span class="comment">   the results. */</span>
<a name="l00203"></a>00203 <span class="keyword">template</span> &lt;<span class="keyword">class</span> nr_type_t&gt;
<a name="l00204"></a><a class="code" href="classqucs_1_1nasolver.html#a92600d02c4b536170044834e2a8531f6">00204</a> <span class="keywordtype">void</span> <a class="code" href="classqucs_1_1nasolver.html">nasolver&lt;nr_type_t&gt;::solve_post</a> (<span class="keywordtype">void</span>)
<a name="l00205"></a>00205 {
<a name="l00206"></a>00206     <span class="keyword">delete</span> nlist;
<a name="l00207"></a>00207     nlist = NULL;
<a name="l00208"></a>00208 }
<a name="l00209"></a>00209 
<a name="l00210"></a>00210 <span class="comment">/* Run this function before the actual solver. */</span>
<a name="l00211"></a>00211 <span class="keyword">template</span> &lt;<span class="keyword">class</span> nr_type_t&gt;
<a name="l00212"></a><a class="code" href="classqucs_1_1nasolver.html#a880c216ea3ca329c03e78f5caf6e6fd4">00212</a> <span class="keywordtype">void</span> <a class="code" href="classqucs_1_1nasolver.html">nasolver&lt;nr_type_t&gt;::solve_pre</a> (<span class="keywordtype">void</span>)
<a name="l00213"></a>00213 {
<a name="l00214"></a>00214     <span class="comment">// create node list, enumerate nodes and voltage sources</span>
<a name="l00215"></a>00215 <span class="preprocessor">#if DEBUG</span>
<a name="l00216"></a>00216 <span class="preprocessor"></span>    <a class="code" href="logging_8c.html#abe06a8732a47a291606edcfac5e5146e">logprint</a> (<a class="code" href="logging_8h.html#a9b52156aa5746cc612e2e3edea6d5dbd">LOG_STATUS</a>, <span class="stringliteral">&quot;NOTIFY: %s: creating node list for %s analysis\n&quot;</span>,
<a name="l00217"></a>00217               getName (), desc.c_str());
<a name="l00218"></a>00218 <span class="preprocessor">#endif</span>
<a name="l00219"></a>00219 <span class="preprocessor"></span>    nlist = <span class="keyword">new</span> <a class="code" href="classqucs_1_1nodelist.html">nodelist</a> (subnet);
<a name="l00220"></a>00220     nlist-&gt;assignNodes ();
<a name="l00221"></a>00221     assignVoltageSources ();
<a name="l00222"></a>00222 <span class="preprocessor">#if DEBUG &amp;&amp; 0</span>
<a name="l00223"></a>00223 <span class="preprocessor"></span>    nlist-&gt;print ();
<a name="l00224"></a>00224 <span class="preprocessor">#endif</span>
<a name="l00225"></a>00225 <span class="preprocessor"></span>
<a name="l00226"></a>00226     <span class="comment">// create matrix, solution vector and right hand side vector</span>
<a name="l00227"></a>00227     <span class="keywordtype">int</span> <a class="code" href="evaluate_8cpp.html#a92592142cb41364b6fe6ef9cc1a16dbd">M</a> = countVoltageSources ();
<a name="l00228"></a>00228     <span class="keywordtype">int</span> <a class="code" href="equation_8cpp.html#a540f72cb9bcf86a19e3bbc259b9ec3e0">N</a> = countNodes ();
<a name="l00229"></a>00229     <span class="keywordflow">if</span> (<a class="code" href="eqndefined_8cpp.html#a70993d52766e31cb0157958a18aa499a">A</a> != NULL) <span class="keyword">delete</span> <a class="code" href="eqndefined_8cpp.html#a70993d52766e31cb0157958a18aa499a">A</a>;
<a name="l00230"></a>00230     <a class="code" href="eqndefined_8cpp.html#a70993d52766e31cb0157958a18aa499a">A</a> = <span class="keyword">new</span> <a class="code" href="classqucs_1_1tmatrix.html">tmatrix&lt;nr_type_t&gt;</a> (M + <a class="code" href="equation_8cpp.html#a540f72cb9bcf86a19e3bbc259b9ec3e0">N</a>);
<a name="l00231"></a>00231     <span class="keywordflow">if</span> (z != NULL) <span class="keyword">delete</span> z;
<a name="l00232"></a>00232     z = <span class="keyword">new</span> <a class="code" href="classqucs_1_1tvector.html">tvector&lt;nr_type_t&gt;</a> (N + <a class="code" href="evaluate_8cpp.html#a92592142cb41364b6fe6ef9cc1a16dbd">M</a>);
<a name="l00233"></a>00233     <span class="keywordflow">if</span> (<a class="code" href="parse__mdl_8y.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a> != NULL) <span class="keyword">delete</span> <a class="code" href="parse__mdl_8y.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>;
<a name="l00234"></a>00234     <a class="code" href="parse__mdl_8y.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a> = <span class="keyword">new</span> <a class="code" href="classqucs_1_1tvector.html">tvector&lt;nr_type_t&gt;</a> (N + <a class="code" href="evaluate_8cpp.html#a92592142cb41364b6fe6ef9cc1a16dbd">M</a>);
<a name="l00235"></a>00235 
<a name="l00236"></a>00236 <span class="preprocessor">#if DEBUG</span>
<a name="l00237"></a>00237 <span class="preprocessor"></span>    <a class="code" href="logging_8c.html#abe06a8732a47a291606edcfac5e5146e">logprint</a> (<a class="code" href="logging_8h.html#a9b52156aa5746cc612e2e3edea6d5dbd">LOG_STATUS</a>, <span class="stringliteral">&quot;NOTIFY: %s: solving %s netlist\n&quot;</span>, getName (), desc.c_str());
<a name="l00238"></a>00238 <span class="preprocessor">#endif</span>
<a name="l00239"></a>00239 <span class="preprocessor"></span>}
<a name="l00240"></a>00240 
<a name="l00241"></a>00241 <span class="comment">/* This function goes through the nodeset list of the current netlist</span>
<a name="l00242"></a>00242 <span class="comment">   and applies the stored values to the current solution vector.  Then</span>
<a name="l00243"></a>00243 <span class="comment">   the function saves the solution vector back into the actual</span>
<a name="l00244"></a>00244 <span class="comment">   component nodes. */</span>
<a name="l00245"></a>00245 <span class="keyword">template</span> &lt;<span class="keyword">class</span> nr_type_t&gt;
<a name="l00246"></a><a class="code" href="classqucs_1_1nasolver.html#a28ad8387d3ef5e484a8475dfc18dd18f">00246</a> <span class="keywordtype">void</span> <a class="code" href="classqucs_1_1nasolver.html">nasolver&lt;nr_type_t&gt;::applyNodeset</a> (<span class="keywordtype">bool</span> nokeep)
<a name="l00247"></a>00247 {
<a name="l00248"></a>00248     <span class="keywordflow">if</span> (<a class="code" href="parse__mdl_8y.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a> == NULL || nlist == NULL) <span class="keywordflow">return</span>;
<a name="l00249"></a>00249 
<a name="l00250"></a>00250     <span class="comment">// set each solution to zero</span>
<a name="l00251"></a>00251     <span class="keywordflow">if</span> (nokeep) <span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code" href="parse__mdl_8y.html#a7e98b8a17c0aad30ba64d47b74e2a6c1">i</a> = 0; <a class="code" href="parse__mdl_8y.html#a7e98b8a17c0aad30ba64d47b74e2a6c1">i</a> &lt; <a class="code" href="parse__mdl_8y.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>-&gt;size (); <a class="code" href="parse__mdl_8y.html#a7e98b8a17c0aad30ba64d47b74e2a6c1">i</a>++) <a class="code" href="parse__mdl_8y.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>-&gt;set (<a class="code" href="parse__mdl_8y.html#a7e98b8a17c0aad30ba64d47b74e2a6c1">i</a>, 0);
<a name="l00252"></a>00252 
<a name="l00253"></a>00253     <span class="comment">// then apply the nodeset itself</span>
<a name="l00254"></a>00254     <span class="keywordflow">for</span> (<a class="code" href="structqucs_1_1nodeset.html">nodeset</a> * <a class="code" href="parse__mdl_8y.html#aecba4cab5e52994730d1e21424997b33">n</a> = subnet-&gt;getNodeset (); <a class="code" href="parse__mdl_8y.html#aecba4cab5e52994730d1e21424997b33">n</a>; <a class="code" href="parse__mdl_8y.html#aecba4cab5e52994730d1e21424997b33">n</a> = <a class="code" href="parse__mdl_8y.html#aecba4cab5e52994730d1e21424997b33">n</a>-&gt;getNext ())
<a name="l00255"></a>00255     {
<a name="l00256"></a>00256         <span class="keyword">struct </span><a class="code" href="structqucs_1_1nodelist__t.html">nodelist_t</a> * nl = nlist-&gt;getNode (<a class="code" href="parse__mdl_8y.html#aecba4cab5e52994730d1e21424997b33">n</a>-&gt;getName ());
<a name="l00257"></a>00257         <span class="keywordflow">if</span> (nl != NULL)
<a name="l00258"></a>00258         {
<a name="l00259"></a>00259             <a class="code" href="parse__mdl_8y.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>-&gt;set (nl-&gt;<a class="code" href="structqucs_1_1nodelist__t.html#adb05bc3207e7adc4df3d26ca7e489c26">n</a>, <a class="code" href="parse__mdl_8y.html#aecba4cab5e52994730d1e21424997b33">n</a>-&gt;getValue ());
<a name="l00260"></a>00260         }
<a name="l00261"></a>00261         <span class="keywordflow">else</span>
<a name="l00262"></a>00262         {
<a name="l00263"></a>00263             <a class="code" href="logging_8c.html#abe06a8732a47a291606edcfac5e5146e">logprint</a> (<a class="code" href="logging_8h.html#aced66975c154ea0e2a8ec3bc818b4e08">LOG_ERROR</a>, <span class="stringliteral">&quot;WARNING: %s: no such node `%s&#39; found, cannot &quot;</span>
<a name="l00264"></a>00264                       <span class="stringliteral">&quot;initialize node\n&quot;</span>, getName (), <a class="code" href="parse__mdl_8y.html#aecba4cab5e52994730d1e21424997b33">n</a>-&gt;getName ());
<a name="l00265"></a>00265         }
<a name="l00266"></a>00266     }
<a name="l00267"></a>00267     <span class="keywordflow">if</span> (xprev != NULL) *xprev = *<a class="code" href="parse__mdl_8y.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>;
<a name="l00268"></a>00268     saveSolution ();
<a name="l00269"></a>00269 }
<a name="l00270"></a>00270 
<a name="l00271"></a>00271 <span class="comment">/* The following function uses the gMin-stepping algorithm in order to</span>
<a name="l00272"></a>00272 <span class="comment">   solve the given non-linear netlist by continuous iterations. */</span>
<a name="l00273"></a>00273 <span class="keyword">template</span> &lt;<span class="keyword">class</span> nr_type_t&gt;
<a name="l00274"></a><a class="code" href="classqucs_1_1nasolver.html#acf78f1cb2223972b54d05ea3b5def254">00274</a> <span class="keywordtype">int</span> <a class="code" href="classqucs_1_1nasolver.html">nasolver&lt;nr_type_t&gt;::solve_nonlinear_continuation_gMin</a> (<span class="keywordtype">void</span>)
<a name="l00275"></a>00275 {
<a name="l00276"></a>00276     qucs::exception * e;
<a name="l00277"></a>00277     <span class="keywordtype">int</span> convergence, run = 0, MaxIterations, error = 0;
<a name="l00278"></a>00278     <a class="code" href="config_8h.html#a014aadc409afb297b8247c13f8ca89be">nr_double_t</a> gStep, gPrev;
<a name="l00279"></a>00279 
<a name="l00280"></a>00280     <span class="comment">// fetch simulation properties</span>
<a name="l00281"></a>00281     MaxIterations = getPropertyInteger (<span class="stringliteral">&quot;MaxIter&quot;</span>) / 4 + 1;
<a name="l00282"></a>00282     updateMatrix = 1;
<a name="l00283"></a>00283     fixpoint = 0;
<a name="l00284"></a>00284 
<a name="l00285"></a>00285     <span class="comment">// initialize the stepper</span>
<a name="l00286"></a>00286     gPrev = gMin = 0.01;
<a name="l00287"></a>00287     gStep = gMin / 100;
<a name="l00288"></a>00288     gMin -= gStep;
<a name="l00289"></a>00289 
<a name="l00290"></a>00290     <span class="keywordflow">do</span>
<a name="l00291"></a>00291     {
<a name="l00292"></a>00292         <span class="comment">// run solving loop until convergence is reached</span>
<a name="l00293"></a>00293         run = 0;
<a name="l00294"></a>00294         <span class="keywordflow">do</span>
<a name="l00295"></a>00295         {
<a name="l00296"></a>00296             error = solve_once ();
<a name="l00297"></a>00297             <span class="keywordflow">if</span> (!error)
<a name="l00298"></a>00298             {
<a name="l00299"></a>00299                 <span class="comment">// convergence check</span>
<a name="l00300"></a>00300                 convergence = (run &gt; 0) ? checkConvergence () : 0;
<a name="l00301"></a>00301                 savePreviousIteration ();
<a name="l00302"></a>00302                 run++;
<a name="l00303"></a>00303             }
<a name="l00304"></a>00304             <span class="keywordflow">else</span> <span class="keywordflow">break</span>;
<a name="l00305"></a>00305         }
<a name="l00306"></a>00306         <span class="keywordflow">while</span> (!convergence &amp;&amp; run &lt; MaxIterations);
<a name="l00307"></a>00307         iterations += run;
<a name="l00308"></a>00308 
<a name="l00309"></a>00309         <span class="comment">// not yet converged, so decreased the gMin-step</span>
<a name="l00310"></a>00310         <span class="keywordflow">if</span> (run &gt;= MaxIterations || error)
<a name="l00311"></a>00311         {
<a name="l00312"></a>00312             gStep /= 2;
<a name="l00313"></a>00313             <span class="comment">// here the absolute minimum step checker</span>
<a name="l00314"></a>00314             <span class="keywordflow">if</span> (gStep &lt; std::numeric_limits&lt;nr_double_t&gt;::epsilon())
<a name="l00315"></a>00315             {
<a name="l00316"></a>00316                 error = 1;
<a name="l00317"></a>00317                 e = <span class="keyword">new</span> qucs::exception (<a class="code" href="structqucs.html#ac060e999cf6725990fdd6c65600a62e5a28c96ff10d13b86706a9375af2dd7fe0">EXCEPTION_NO_CONVERGENCE</a>);
<a name="l00318"></a>00318                 e-&gt;setText (<span class="stringliteral">&quot;no convergence in %s analysis after %d gMinStepping &quot;</span>
<a name="l00319"></a>00319                             <span class="stringliteral">&quot;iterations&quot;</span>, desc.c_str(), iterations);
<a name="l00320"></a>00320                 <a class="code" href="exceptionstack_8h.html#a8da005873bb805e4071f4b7cd9da6cdb">throw_exception</a> (e);
<a name="l00321"></a>00321                 <span class="keywordflow">break</span>;
<a name="l00322"></a>00322             }
<a name="l00323"></a>00323             gMin = MAX (gPrev - gStep, 0);
<a name="l00324"></a>00324         }
<a name="l00325"></a>00325         <span class="comment">// converged, increased the gMin-step</span>
<a name="l00326"></a>00326         <span class="keywordflow">else</span>
<a name="l00327"></a>00327         {
<a name="l00328"></a>00328             gPrev = gMin;
<a name="l00329"></a>00329             gMin = MAX (gMin - gStep, 0);
<a name="l00330"></a>00330             gStep *= 2;
<a name="l00331"></a>00331         }
<a name="l00332"></a>00332     }
<a name="l00333"></a>00333     <span class="comment">// continue until no additional resistances is necessary</span>
<a name="l00334"></a>00334     <span class="keywordflow">while</span> (gPrev &gt; 0);
<a name="l00335"></a>00335 
<a name="l00336"></a>00336     <span class="keywordflow">return</span> error;
<a name="l00337"></a>00337 }
<a name="l00338"></a>00338 
<a name="l00339"></a>00339 <span class="comment">/* The following function uses the source-stepping algorithm in order</span>
<a name="l00340"></a>00340 <span class="comment">   to solve the given non-linear netlist by continuous iterations. */</span>
<a name="l00341"></a>00341 <span class="keyword">template</span> &lt;<span class="keyword">class</span> nr_type_t&gt;
<a name="l00342"></a><a class="code" href="classqucs_1_1nasolver.html#a0bb03de4435581df8fbb8623be73e763">00342</a> <span class="keywordtype">int</span> <a class="code" href="classqucs_1_1nasolver.html">nasolver&lt;nr_type_t&gt;::solve_nonlinear_continuation_Source</a> (<span class="keywordtype">void</span>)
<a name="l00343"></a>00343 {
<a name="l00344"></a>00344     qucs::exception * e;
<a name="l00345"></a>00345     <span class="keywordtype">int</span> convergence, run = 0, MaxIterations, error = 0;
<a name="l00346"></a>00346     <a class="code" href="config_8h.html#a014aadc409afb297b8247c13f8ca89be">nr_double_t</a> sStep, sPrev;
<a name="l00347"></a>00347 
<a name="l00348"></a>00348     <span class="comment">// fetch simulation properties</span>
<a name="l00349"></a>00349     MaxIterations = getPropertyInteger (<span class="stringliteral">&quot;MaxIter&quot;</span>) / 4 + 1;
<a name="l00350"></a>00350     updateMatrix = 1;
<a name="l00351"></a>00351     fixpoint = 0;
<a name="l00352"></a>00352 
<a name="l00353"></a>00353     <span class="comment">// initialize the stepper</span>
<a name="l00354"></a>00354     sPrev = srcFactor = 0;
<a name="l00355"></a>00355     sStep = 0.01;
<a name="l00356"></a>00356     srcFactor += sStep;
<a name="l00357"></a>00357 
<a name="l00358"></a>00358     <span class="keywordflow">do</span>
<a name="l00359"></a>00359     {
<a name="l00360"></a>00360         <span class="comment">// run solving loop until convergence is reached</span>
<a name="l00361"></a>00361         run = 0;
<a name="l00362"></a>00362         <span class="keywordflow">do</span>
<a name="l00363"></a>00363         {
<a name="l00364"></a>00364             subnet-&gt;setSrcFactor (srcFactor);
<a name="l00365"></a>00365             error = solve_once ();
<a name="l00366"></a>00366             <span class="keywordflow">if</span> (!error)
<a name="l00367"></a>00367             {
<a name="l00368"></a>00368                 <span class="comment">// convergence check</span>
<a name="l00369"></a>00369                 convergence = (run &gt; 0) ? checkConvergence () : 0;
<a name="l00370"></a>00370                 savePreviousIteration ();
<a name="l00371"></a>00371                 run++;
<a name="l00372"></a>00372             }
<a name="l00373"></a>00373             <span class="keywordflow">else</span> <span class="keywordflow">break</span>;
<a name="l00374"></a>00374         }
<a name="l00375"></a>00375         <span class="keywordflow">while</span> (!convergence &amp;&amp; run &lt; MaxIterations);
<a name="l00376"></a>00376         iterations += run;
<a name="l00377"></a>00377 
<a name="l00378"></a>00378         <span class="comment">// not yet converged, so decreased the source-step</span>
<a name="l00379"></a>00379         <span class="keywordflow">if</span> (run &gt;= MaxIterations || error)
<a name="l00380"></a>00380         {
<a name="l00381"></a>00381             <span class="keywordflow">if</span> (error)
<a name="l00382"></a>00382                 sStep *= 0.1;
<a name="l00383"></a>00383             <span class="keywordflow">else</span>
<a name="l00384"></a>00384                 sStep *= 0.5;
<a name="l00385"></a>00385             restorePreviousIteration ();
<a name="l00386"></a>00386             saveSolution ();
<a name="l00387"></a>00387             <span class="comment">// here the absolute minimum step checker</span>
<a name="l00388"></a>00388             <span class="keywordflow">if</span> (sStep &lt; std::numeric_limits&lt;nr_double_t&gt;::epsilon())
<a name="l00389"></a>00389             {
<a name="l00390"></a>00390                 error = 1;
<a name="l00391"></a>00391                 e = <span class="keyword">new</span> qucs::exception (<a class="code" href="structqucs.html#ac060e999cf6725990fdd6c65600a62e5a28c96ff10d13b86706a9375af2dd7fe0">EXCEPTION_NO_CONVERGENCE</a>);
<a name="l00392"></a>00392                 e-&gt;setText (<span class="stringliteral">&quot;no convergence in %s analysis after %d sourceStepping &quot;</span>
<a name="l00393"></a>00393                             <span class="stringliteral">&quot;iterations&quot;</span>, desc.c_str(), iterations);
<a name="l00394"></a>00394                 <a class="code" href="exceptionstack_8h.html#a8da005873bb805e4071f4b7cd9da6cdb">throw_exception</a> (e);
<a name="l00395"></a>00395                 <span class="keywordflow">break</span>;
<a name="l00396"></a>00396             }
<a name="l00397"></a>00397             srcFactor = std::min (sPrev + sStep, 1.0);
<a name="l00398"></a>00398         }
<a name="l00399"></a>00399         <span class="comment">// converged, increased the source-step</span>
<a name="l00400"></a>00400         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (run &lt; MaxIterations / 4)
<a name="l00401"></a>00401         {
<a name="l00402"></a>00402             sPrev = srcFactor;
<a name="l00403"></a>00403             srcFactor = std::min (srcFactor + sStep, 1.0);
<a name="l00404"></a>00404             sStep *= 1.5;
<a name="l00405"></a>00405         }
<a name="l00406"></a>00406         <span class="keywordflow">else</span>
<a name="l00407"></a>00407         {
<a name="l00408"></a>00408             srcFactor = std::min (srcFactor + sStep, 1.0);
<a name="l00409"></a>00409         }
<a name="l00410"></a>00410     }
<a name="l00411"></a>00411     <span class="comment">// continue until no source factor is necessary</span>
<a name="l00412"></a>00412     <span class="keywordflow">while</span> (sPrev &lt; 1);
<a name="l00413"></a>00413 
<a name="l00414"></a>00414     subnet-&gt;setSrcFactor (1);
<a name="l00415"></a>00415     <span class="keywordflow">return</span> error;
<a name="l00416"></a>00416 }
<a name="l00417"></a>00417 
<a name="l00418"></a>00418 <span class="comment">/* The function returns an appropriate text representation for the</span>
<a name="l00419"></a>00419 <span class="comment">   currently used convergence helper algorithm. */</span>
<a name="l00420"></a>00420 <span class="keyword">template</span> &lt;<span class="keyword">class</span> nr_type_t&gt;
<a name="l00421"></a><a class="code" href="classqucs_1_1nasolver.html#ae68acf60163abbc10f7a0cbe48b0164c">00421</a> <span class="keyword">const</span> <span class="keywordtype">char</span> * <a class="code" href="classqucs_1_1nasolver.html">nasolver&lt;nr_type_t&gt;::getHelperDescription</a> (<span class="keywordtype">void</span>)
<a name="l00422"></a>00422 {
<a name="l00423"></a>00423     <span class="keywordflow">if</span> (convHelper == <a class="code" href="nasolver_8h.html#aa82f6cb8837d1998b3d2944d841870b4">CONV_Attenuation</a>)
<a name="l00424"></a>00424     {
<a name="l00425"></a>00425         <span class="keywordflow">return</span> <span class="stringliteral">&quot;RHS attenuation&quot;</span>;
<a name="l00426"></a>00426     }
<a name="l00427"></a>00427     <span class="keywordflow">else</span> <span class="keywordflow">if</span>  (convHelper == <a class="code" href="nasolver_8h.html#abbd20ba066ff4757da98afbcb782c010">CONV_LineSearch</a>)
<a name="l00428"></a>00428     {
<a name="l00429"></a>00429         <span class="keywordflow">return</span> <span class="stringliteral">&quot;line search&quot;</span>;
<a name="l00430"></a>00430     }
<a name="l00431"></a>00431     <span class="keywordflow">else</span> <span class="keywordflow">if</span>  (convHelper == <a class="code" href="nasolver_8h.html#acbe2ee03561cd901e9175a2492a9b3a0">CONV_SteepestDescent</a>)
<a name="l00432"></a>00432     {
<a name="l00433"></a>00433         <span class="keywordflow">return</span> <span class="stringliteral">&quot;steepest descent&quot;</span>;
<a name="l00434"></a>00434     }
<a name="l00435"></a>00435     <span class="keywordflow">else</span> <span class="keywordflow">if</span>  (convHelper == <a class="code" href="nasolver_8h.html#ab0ffe799dee22bac38939c2b291ab10b">CONV_GMinStepping</a>)
<a name="l00436"></a>00436     {
<a name="l00437"></a>00437         <span class="keywordflow">return</span> <span class="stringliteral">&quot;gMin stepping&quot;</span>;
<a name="l00438"></a>00438     }
<a name="l00439"></a>00439     <span class="keywordflow">else</span> <span class="keywordflow">if</span>  (convHelper == <a class="code" href="nasolver_8h.html#a2bb69972dfff8ce66b0505cba2b8a119">CONV_SourceStepping</a>)
<a name="l00440"></a>00440     {
<a name="l00441"></a>00441         <span class="keywordflow">return</span> <span class="stringliteral">&quot;source stepping&quot;</span>;
<a name="l00442"></a>00442     }
<a name="l00443"></a>00443     <span class="keywordflow">return</span> <span class="stringliteral">&quot;none&quot;</span>;
<a name="l00444"></a>00444 }
<a name="l00445"></a>00445 
<a name="l00446"></a>00446 <span class="comment">/* This is the non-linear iterative nodal analysis netlist solver. */</span>
<a name="l00447"></a>00447 <span class="keyword">template</span> &lt;<span class="keyword">class</span> nr_type_t&gt;
<a name="l00448"></a><a class="code" href="classqucs_1_1nasolver.html#af282a569d681620b47202bb514a465cb">00448</a> <span class="keywordtype">int</span> <a class="code" href="classqucs_1_1nasolver.html">nasolver&lt;nr_type_t&gt;::solve_nonlinear</a> (<span class="keywordtype">void</span>)
<a name="l00449"></a>00449 {
<a name="l00450"></a>00450     qucs::exception * e;
<a name="l00451"></a>00451     <span class="keywordtype">int</span> convergence, run = 0, MaxIterations, error = 0;
<a name="l00452"></a>00452 
<a name="l00453"></a>00453     <span class="comment">// fetch simulation properties</span>
<a name="l00454"></a>00454     MaxIterations = getPropertyInteger (<span class="stringliteral">&quot;MaxIter&quot;</span>);
<a name="l00455"></a>00455     reltol = getPropertyDouble (<span class="stringliteral">&quot;reltol&quot;</span>);
<a name="l00456"></a>00456     abstol = getPropertyDouble (<span class="stringliteral">&quot;abstol&quot;</span>);
<a name="l00457"></a>00457     vntol = getPropertyDouble (<span class="stringliteral">&quot;vntol&quot;</span>);
<a name="l00458"></a>00458     updateMatrix = 1;
<a name="l00459"></a>00459 
<a name="l00460"></a>00460     <span class="keywordflow">if</span> (convHelper == <a class="code" href="nasolver_8h.html#ab0ffe799dee22bac38939c2b291ab10b">CONV_GMinStepping</a>)
<a name="l00461"></a>00461     {
<a name="l00462"></a>00462         <span class="comment">// use the alternative non-linear solver solve_nonlinear_continuation_gMin</span>
<a name="l00463"></a>00463         <span class="comment">// instead of the basic solver provided by this function</span>
<a name="l00464"></a>00464         iterations = 0;
<a name="l00465"></a>00465         error = solve_nonlinear_continuation_gMin ();
<a name="l00466"></a>00466         <span class="keywordflow">return</span> error;
<a name="l00467"></a>00467     }
<a name="l00468"></a>00468     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (convHelper == <a class="code" href="nasolver_8h.html#a2bb69972dfff8ce66b0505cba2b8a119">CONV_SourceStepping</a>)
<a name="l00469"></a>00469     {
<a name="l00470"></a>00470         <span class="comment">// use the alternative non-linear solver solve_nonlinear_continuation_Source</span>
<a name="l00471"></a>00471         <span class="comment">// instead of the basic solver provided by this function</span>
<a name="l00472"></a>00472         iterations = 0;
<a name="l00473"></a>00473         error = solve_nonlinear_continuation_Source ();
<a name="l00474"></a>00474         <span class="keywordflow">return</span> error;
<a name="l00475"></a>00475     }
<a name="l00476"></a>00476 
<a name="l00477"></a>00477     <span class="comment">// run solving loop until convergence is reached</span>
<a name="l00478"></a>00478     <span class="keywordflow">do</span>
<a name="l00479"></a>00479     {
<a name="l00480"></a>00480         error = solve_once ();
<a name="l00481"></a>00481         <span class="keywordflow">if</span> (!error)
<a name="l00482"></a>00482         {
<a name="l00483"></a>00483             <span class="comment">// convergence check</span>
<a name="l00484"></a>00484             convergence = (run &gt; 0) ? checkConvergence () : 0;
<a name="l00485"></a>00485             savePreviousIteration ();
<a name="l00486"></a>00486             run++;
<a name="l00487"></a>00487             <span class="comment">// control fixpoint iterations</span>
<a name="l00488"></a>00488             <span class="keywordflow">if</span> (fixpoint)
<a name="l00489"></a>00489             {
<a name="l00490"></a>00490                 <span class="keywordflow">if</span> (convergence &amp;&amp; !updateMatrix)
<a name="l00491"></a>00491                 {
<a name="l00492"></a>00492                     updateMatrix = 1;
<a name="l00493"></a>00493                     convergence = 0;
<a name="l00494"></a>00494                 }
<a name="l00495"></a>00495                 <span class="keywordflow">else</span>
<a name="l00496"></a>00496                 {
<a name="l00497"></a>00497                     updateMatrix = 0;
<a name="l00498"></a>00498                 }
<a name="l00499"></a>00499             }
<a name="l00500"></a>00500         }
<a name="l00501"></a>00501         <span class="keywordflow">else</span>
<a name="l00502"></a>00502         {
<a name="l00503"></a>00503             <span class="keywordflow">break</span>;
<a name="l00504"></a>00504         }
<a name="l00505"></a>00505     }
<a name="l00506"></a>00506     <span class="keywordflow">while</span> (!convergence &amp;&amp;
<a name="l00507"></a>00507             run &lt; MaxIterations * (1 + convHelper ? 1 : 0));
<a name="l00508"></a>00508 
<a name="l00509"></a>00509     <span class="keywordflow">if</span> (run &gt;= MaxIterations || error)
<a name="l00510"></a>00510     {
<a name="l00511"></a>00511         e = <span class="keyword">new</span> qucs::exception (<a class="code" href="structqucs.html#ac060e999cf6725990fdd6c65600a62e5a28c96ff10d13b86706a9375af2dd7fe0">EXCEPTION_NO_CONVERGENCE</a>);
<a name="l00512"></a>00512         e-&gt;setText (<span class="stringliteral">&quot;no convergence in %s analysis after %d iterations&quot;</span>,
<a name="l00513"></a>00513                     desc.c_str(), run);
<a name="l00514"></a>00514         <a class="code" href="exceptionstack_8h.html#a8da005873bb805e4071f4b7cd9da6cdb">throw_exception</a> (e);
<a name="l00515"></a>00515         error++;
<a name="l00516"></a>00516     }
<a name="l00517"></a>00517 
<a name="l00518"></a>00518     iterations = run;
<a name="l00519"></a>00519     <span class="keywordflow">return</span> error;
<a name="l00520"></a>00520 }
<a name="l00521"></a>00521 
<a name="l00522"></a>00522 <span class="comment">/* This is the linear nodal analysis netlist solver. */</span>
<a name="l00523"></a>00523 <span class="keyword">template</span> &lt;<span class="keyword">class</span> nr_type_t&gt;
<a name="l00524"></a><a class="code" href="classqucs_1_1nasolver.html#aa6569bfed1dfee556ee79842373509bf">00524</a> <span class="keywordtype">int</span> <a class="code" href="classqucs_1_1nasolver.html">nasolver&lt;nr_type_t&gt;::solve_linear</a> (<span class="keywordtype">void</span>)
<a name="l00525"></a>00525 {
<a name="l00526"></a>00526     updateMatrix = 1;
<a name="l00527"></a>00527     <span class="keywordflow">return</span> solve_once ();
<a name="l00528"></a>00528 }
<a name="l00529"></a>00529 
<a name="l00530"></a>00530 <span class="comment">/* Applying the MNA (Modified Nodal Analysis) to a circuit with</span>
<a name="l00531"></a>00531 <span class="comment">   passive elements and independent current and voltage sources</span>
<a name="l00532"></a>00532 <span class="comment">   results in a matrix equation of the form Ax = z.  This function</span>
<a name="l00533"></a>00533 <span class="comment">   generates the A and z matrix. */</span>
<a name="l00534"></a>00534 <span class="keyword">template</span> &lt;<span class="keyword">class</span> nr_type_t&gt;
<a name="l00535"></a><a class="code" href="classqucs_1_1nasolver.html#a0003b724e5c5801a3fac5d9b2863fb78">00535</a> <span class="keywordtype">void</span> <a class="code" href="classqucs_1_1nasolver.html">nasolver&lt;nr_type_t&gt;::createMatrix</a> (<span class="keywordtype">void</span>)
<a name="l00536"></a>00536 {
<a name="l00537"></a>00537 
<a name="l00538"></a>00538     <span class="comment">/* Generate the A matrix.  The A matrix consists of four (4) minor</span>
<a name="l00539"></a>00539 <span class="comment">       matrices in the form     +-   -+</span>
<a name="l00540"></a>00540 <span class="comment">                            A = | G B |</span>
<a name="l00541"></a>00541 <span class="comment">                                | C D |</span>
<a name="l00542"></a>00542 <span class="comment">                      +-   -+.</span>
<a name="l00543"></a>00543 <span class="comment">       Each of these minor matrices is going to be generated here. */</span>
<a name="l00544"></a>00544     <span class="keywordflow">if</span> (updateMatrix)
<a name="l00545"></a>00545     {
<a name="l00546"></a>00546         createGMatrix ();
<a name="l00547"></a>00547         createBMatrix ();
<a name="l00548"></a>00548         createCMatrix ();
<a name="l00549"></a>00549         createDMatrix ();
<a name="l00550"></a>00550     }
<a name="l00551"></a>00551 
<a name="l00552"></a>00552     <span class="comment">/* Adjust G matrix if requested. */</span>
<a name="l00553"></a>00553     <span class="keywordflow">if</span> (convHelper == <a class="code" href="nasolver_8h.html#ab0ffe799dee22bac38939c2b291ab10b">CONV_GMinStepping</a>)
<a name="l00554"></a>00554     {
<a name="l00555"></a>00555         <span class="keywordtype">int</span> <a class="code" href="equation_8cpp.html#a540f72cb9bcf86a19e3bbc259b9ec3e0">N</a> = countNodes ();
<a name="l00556"></a>00556         <span class="keywordtype">int</span> <a class="code" href="evaluate_8cpp.html#a92592142cb41364b6fe6ef9cc1a16dbd">M</a> = countVoltageSources ();
<a name="l00557"></a>00557         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code" href="parse__mdl_8y.html#aecba4cab5e52994730d1e21424997b33">n</a> = 0; <a class="code" href="parse__mdl_8y.html#aecba4cab5e52994730d1e21424997b33">n</a> &lt; N + <a class="code" href="evaluate_8cpp.html#a92592142cb41364b6fe6ef9cc1a16dbd">M</a>; <a class="code" href="parse__mdl_8y.html#aecba4cab5e52994730d1e21424997b33">n</a>++)
<a name="l00558"></a>00558         {
<a name="l00559"></a>00559             <a class="code" href="eqndefined_8cpp.html#a70993d52766e31cb0157958a18aa499a">A</a>-&gt;set (<a class="code" href="parse__mdl_8y.html#aecba4cab5e52994730d1e21424997b33">n</a>, <a class="code" href="parse__mdl_8y.html#aecba4cab5e52994730d1e21424997b33">n</a>, <a class="code" href="eqndefined_8cpp.html#a70993d52766e31cb0157958a18aa499a">A</a>-&gt;get (<a class="code" href="parse__mdl_8y.html#aecba4cab5e52994730d1e21424997b33">n</a>, <a class="code" href="parse__mdl_8y.html#aecba4cab5e52994730d1e21424997b33">n</a>) + gMin);
<a name="l00560"></a>00560         }
<a name="l00561"></a>00561     }
<a name="l00562"></a>00562 
<a name="l00563"></a>00563     <span class="comment">/* Generate the z Matrix.  The z Matrix consists of two (2) minor</span>
<a name="l00564"></a>00564 <span class="comment">       matrices in the form     +- -+</span>
<a name="l00565"></a>00565 <span class="comment">                            z = | i |</span>
<a name="l00566"></a>00566 <span class="comment">                                | e |</span>
<a name="l00567"></a>00567 <span class="comment">                      +- -+.</span>
<a name="l00568"></a>00568 <span class="comment">       Each of these minor matrices is going to be generated here. */</span>
<a name="l00569"></a>00569     createZVector ();
<a name="l00570"></a>00570 }
<a name="l00571"></a>00571 
<a name="l00572"></a>00572 <span class="comment">/* This MatVal() functionality is just helper to get the correct</span>
<a name="l00573"></a>00573 <span class="comment">   values from the circuit&#39;s matrices.  The additional (unused)</span>
<a name="l00574"></a>00574 <span class="comment">   argument is used to differentiate between the two possible</span>
<a name="l00575"></a>00575 <span class="comment">   types. */</span>
<a name="l00576"></a><a class="code" href="nasolver_8cpp.html#a220f4ccccd29d482d2059cc54e84285a">00576</a> <span class="preprocessor">#define MatVal(x) MatValX (x, (nr_type_t *) 0)</span>
<a name="l00577"></a>00577 <span class="preprocessor"></span>
<a name="l00578"></a>00578 <span class="keyword">template</span> &lt;<span class="keyword">class</span> nr_type_t&gt;
<a name="l00579"></a><a class="code" href="classqucs_1_1nasolver.html#ad4ba631edb46e5415d7da3225229fe5b">00579</a> nr_type_t <a class="code" href="classqucs_1_1nasolver.html">nasolver&lt;nr_type_t&gt;::MatValX</a> (<a class="code" href="complex_8h.html#a7ad1a12245ad87a9d81d6bcc18afacae">nr_complex_t</a> z, <a class="code" href="complex_8h.html#a7ad1a12245ad87a9d81d6bcc18afacae">nr_complex_t</a> *)
<a name="l00580"></a>00580 {
<a name="l00581"></a>00581     <span class="keywordflow">return</span> z;
<a name="l00582"></a>00582 }
<a name="l00583"></a>00583 
<a name="l00584"></a>00584 <span class="keyword">template</span> &lt;<span class="keyword">class</span> nr_type_t&gt;
<a name="l00585"></a><a class="code" href="classqucs_1_1nasolver.html#ab32126e0ea32163fb313a7a15a84215a">00585</a> nr_type_t <a class="code" href="classqucs_1_1nasolver.html">nasolver&lt;nr_type_t&gt;::MatValX</a> (<a class="code" href="complex_8h.html#a7ad1a12245ad87a9d81d6bcc18afacae">nr_complex_t</a> z, <a class="code" href="config_8h.html#a014aadc409afb297b8247c13f8ca89be">nr_double_t</a> *)
<a name="l00586"></a>00586 {
<a name="l00587"></a>00587     <span class="keywordflow">return</span> <a class="code" href="namespacequcs.html#a0cc73c27d7d13b2200f2fddbb064dce6" title="Real part matrix.">real</a> (z);
<a name="l00588"></a>00588 }
<a name="l00589"></a>00589 
<a name="l00590"></a>00590 <span class="comment">/* The B matrix is an MxN matrix with only 0, 1 and -1 elements.  Each</span>
<a name="l00591"></a>00591 <span class="comment">   location in the matrix corresponds to a particular voltage source</span>
<a name="l00592"></a>00592 <span class="comment">   (first dimension) or a node (second dimension).  If the positive</span>
<a name="l00593"></a>00593 <span class="comment">   terminal of the ith voltage source is connected to node k, then the</span>
<a name="l00594"></a>00594 <span class="comment">   element (i,k) in the B matrix is a 1.  If the negative terminal of</span>
<a name="l00595"></a>00595 <span class="comment">   the ith voltage source is connected to node k, then the element</span>
<a name="l00596"></a>00596 <span class="comment">   (i,k) in the B matrix is a -1.  Otherwise, elements of the B matrix</span>
<a name="l00597"></a>00597 <span class="comment">   are zero. */</span>
<a name="l00598"></a>00598 <span class="keyword">template</span> &lt;<span class="keyword">class</span> nr_type_t&gt;
<a name="l00599"></a><a class="code" href="classqucs_1_1nasolver.html#ab61473b2053822b8c7f7bfdf5de5de9f">00599</a> <span class="keywordtype">void</span> <a class="code" href="classqucs_1_1nasolver.html">nasolver&lt;nr_type_t&gt;::createBMatrix</a> (<span class="keywordtype">void</span>)
<a name="l00600"></a>00600 {
<a name="l00601"></a>00601     <span class="keywordtype">int</span> <a class="code" href="equation_8cpp.html#a540f72cb9bcf86a19e3bbc259b9ec3e0">N</a> = countNodes ();
<a name="l00602"></a>00602     <span class="keywordtype">int</span> <a class="code" href="evaluate_8cpp.html#a92592142cb41364b6fe6ef9cc1a16dbd">M</a> = countVoltageSources ();
<a name="l00603"></a>00603     <a class="code" href="classqucs_1_1circuit.html" title="base class for qucs circuit elements.">circuit</a> * vs;
<a name="l00604"></a>00604     <span class="keyword">struct </span><a class="code" href="structqucs_1_1nodelist__t.html">nodelist_t</a> * <a class="code" href="parse__mdl_8y.html#aecba4cab5e52994730d1e21424997b33">n</a>;
<a name="l00605"></a>00605     nr_type_t val;
<a name="l00606"></a>00606 
<a name="l00607"></a>00607     <span class="comment">// go through each voltage sources (first dimension)</span>
<a name="l00608"></a>00608     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a> = 0; <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a> &lt; <a class="code" href="evaluate_8cpp.html#a92592142cb41364b6fe6ef9cc1a16dbd">M</a>; <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>++)
<a name="l00609"></a>00609     {
<a name="l00610"></a>00610         vs = findVoltageSource (<a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>);
<a name="l00611"></a>00611         <span class="comment">// go through each node (second dimension)</span>
<a name="l00612"></a>00612         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a> = 0; <a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a> &lt; <a class="code" href="equation_8cpp.html#a540f72cb9bcf86a19e3bbc259b9ec3e0">N</a>; <a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>++)
<a name="l00613"></a>00613         {
<a name="l00614"></a>00614             val = 0.0;
<a name="l00615"></a>00615             n = nlist-&gt;getNode (<a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>);
<a name="l00616"></a>00616             <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;current : *n)
<a name="l00617"></a>00617             {
<a name="l00618"></a>00618                 <span class="comment">// is voltage source connected to node ?</span>
<a name="l00619"></a>00619               <span class="keywordflow">if</span> (current-&gt;getCircuit () == vs)
<a name="l00620"></a>00620                 {
<a name="l00621"></a>00621                   val += <a class="code" href="nasolver_8cpp.html#a220f4ccccd29d482d2059cc54e84285a">MatVal</a> (vs-&gt;<a class="code" href="classqucs_1_1circuit.html#a5ce27e0942e16711738debe9e23e5310">getB</a> (current-&gt;getPort (), <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>));
<a name="l00622"></a>00622                 }
<a name="l00623"></a>00623             }
<a name="l00624"></a>00624             <span class="comment">// put value into B matrix</span>
<a name="l00625"></a>00625             <a class="code" href="eqndefined_8cpp.html#a70993d52766e31cb0157958a18aa499a">A</a>-&gt;set (<a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>, <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a> + N, val);
<a name="l00626"></a>00626         }
<a name="l00627"></a>00627     }
<a name="l00628"></a>00628 }
<a name="l00629"></a>00629 
<a name="l00630"></a>00630 <span class="comment">/* The C matrix is an NxM matrix with only 0, 1 and -1 elements.  Each</span>
<a name="l00631"></a>00631 <span class="comment">   location in the matrix corresponds to a particular node (first</span>
<a name="l00632"></a>00632 <span class="comment">   dimension) or a voltage source (first dimension).  If the positive</span>
<a name="l00633"></a>00633 <span class="comment">   terminal of the ith voltage source is connected to node k, then the</span>
<a name="l00634"></a>00634 <span class="comment">   element (k,i) in the C matrix is a 1.  If the negative terminal of</span>
<a name="l00635"></a>00635 <span class="comment">   the ith voltage source is connected to node k, then the element</span>
<a name="l00636"></a>00636 <span class="comment">   (k,i) in the C matrix is a -1.  Otherwise, elements of the C matrix</span>
<a name="l00637"></a>00637 <span class="comment">   are zero. */</span>
<a name="l00638"></a>00638 <span class="keyword">template</span> &lt;<span class="keyword">class</span> nr_type_t&gt;
<a name="l00639"></a><a class="code" href="classqucs_1_1nasolver.html#a478f927ceeadf7c40799f3cedc753891">00639</a> <span class="keywordtype">void</span> <a class="code" href="classqucs_1_1nasolver.html">nasolver&lt;nr_type_t&gt;::createCMatrix</a> (<span class="keywordtype">void</span>)
<a name="l00640"></a>00640 {
<a name="l00641"></a>00641     <span class="keywordtype">int</span> <a class="code" href="equation_8cpp.html#a540f72cb9bcf86a19e3bbc259b9ec3e0">N</a> = countNodes ();
<a name="l00642"></a>00642     <span class="keywordtype">int</span> <a class="code" href="evaluate_8cpp.html#a92592142cb41364b6fe6ef9cc1a16dbd">M</a> = countVoltageSources ();
<a name="l00643"></a>00643     <a class="code" href="classqucs_1_1circuit.html" title="base class for qucs circuit elements.">circuit</a> * vs;
<a name="l00644"></a>00644     <span class="keyword">struct </span><a class="code" href="structqucs_1_1nodelist__t.html">nodelist_t</a> * <a class="code" href="parse__mdl_8y.html#aecba4cab5e52994730d1e21424997b33">n</a>;
<a name="l00645"></a>00645     nr_type_t val;
<a name="l00646"></a>00646 
<a name="l00647"></a>00647     <span class="comment">// go through each voltage sources (second dimension)</span>
<a name="l00648"></a>00648     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a> = 0; <a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a> &lt; <a class="code" href="evaluate_8cpp.html#a92592142cb41364b6fe6ef9cc1a16dbd">M</a>; <a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>++)
<a name="l00649"></a>00649     {
<a name="l00650"></a>00650         vs = findVoltageSource (<a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>);
<a name="l00651"></a>00651         <span class="comment">// go through each node (first dimension)</span>
<a name="l00652"></a>00652         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a> = 0; <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a> &lt; <a class="code" href="equation_8cpp.html#a540f72cb9bcf86a19e3bbc259b9ec3e0">N</a>; <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>++)
<a name="l00653"></a>00653         {
<a name="l00654"></a>00654             val = 0.0;
<a name="l00655"></a>00655             n = nlist-&gt;getNode (<a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>);
<a name="l00656"></a>00656             <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;current: *n)
<a name="l00657"></a>00657             {
<a name="l00658"></a>00658                 <span class="comment">// is voltage source connected to node ?</span>
<a name="l00659"></a>00659               <span class="keywordflow">if</span> (current-&gt;getCircuit () == vs)
<a name="l00660"></a>00660                 {
<a name="l00661"></a>00661                   val += <a class="code" href="nasolver_8cpp.html#a220f4ccccd29d482d2059cc54e84285a">MatVal</a> (vs-&gt;<a class="code" href="classqucs_1_1circuit.html#ae7c6a58f6b9168b47933b91899f92918">getC</a> (<a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>, current-&gt;getPort ()));
<a name="l00662"></a>00662                 }
<a name="l00663"></a>00663             }
<a name="l00664"></a>00664             <span class="comment">// put value into C matrix</span>
<a name="l00665"></a>00665             <a class="code" href="eqndefined_8cpp.html#a70993d52766e31cb0157958a18aa499a">A</a>-&gt;set (<a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a> + N, <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>, val);
<a name="l00666"></a>00666         }
<a name="l00667"></a>00667     }
<a name="l00668"></a>00668 }
<a name="l00669"></a>00669 
<a name="l00670"></a>00670 <span class="comment">/* The D matrix is an MxM matrix that is composed entirely of zeros.</span>
<a name="l00671"></a>00671 <span class="comment">   It can be non-zero if dependent sources are considered. */</span>
<a name="l00672"></a>00672 <span class="keyword">template</span> &lt;<span class="keyword">class</span> nr_type_t&gt;
<a name="l00673"></a><a class="code" href="classqucs_1_1nasolver.html#a126b73c9a8248d1f7ce6f93b8067d1ce">00673</a> <span class="keywordtype">void</span> <a class="code" href="classqucs_1_1nasolver.html">nasolver&lt;nr_type_t&gt;::createDMatrix</a> (<span class="keywordtype">void</span>)
<a name="l00674"></a>00674 {
<a name="l00675"></a>00675     <span class="keywordtype">int</span> <a class="code" href="evaluate_8cpp.html#a92592142cb41364b6fe6ef9cc1a16dbd">M</a> = countVoltageSources ();
<a name="l00676"></a>00676     <span class="keywordtype">int</span> <a class="code" href="equation_8cpp.html#a540f72cb9bcf86a19e3bbc259b9ec3e0">N</a> = countNodes ();
<a name="l00677"></a>00677     <a class="code" href="classqucs_1_1circuit.html" title="base class for qucs circuit elements.">circuit</a> * vsr, * vsc;
<a name="l00678"></a>00678     nr_type_t val;
<a name="l00679"></a>00679     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a> = 0; <a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a> &lt; <a class="code" href="evaluate_8cpp.html#a92592142cb41364b6fe6ef9cc1a16dbd">M</a>; <a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>++)
<a name="l00680"></a>00680     {
<a name="l00681"></a>00681         vsr = findVoltageSource (<a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>);
<a name="l00682"></a>00682         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a> = 0; <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a> &lt; <a class="code" href="evaluate_8cpp.html#a92592142cb41364b6fe6ef9cc1a16dbd">M</a>; <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>++)
<a name="l00683"></a>00683         {
<a name="l00684"></a>00684             vsc = findVoltageSource (<a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>);
<a name="l00685"></a>00685             val = 0.0;
<a name="l00686"></a>00686             <span class="keywordflow">if</span> (vsr == vsc)
<a name="l00687"></a>00687             {
<a name="l00688"></a>00688                 val = <a class="code" href="nasolver_8cpp.html#a220f4ccccd29d482d2059cc54e84285a">MatVal</a> (vsr-&gt;<a class="code" href="classqucs_1_1circuit.html#a9c566f8e07eff2dd22a36641e6282448">getD</a> (<a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>, <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>));
<a name="l00689"></a>00689             }
<a name="l00690"></a>00690             <a class="code" href="eqndefined_8cpp.html#a70993d52766e31cb0157958a18aa499a">A</a>-&gt;set (<a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a> + N, <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a> + N, val);
<a name="l00691"></a>00691         }
<a name="l00692"></a>00692     }
<a name="l00693"></a>00693 }
<a name="l00694"></a>00694 
<a name="l00695"></a>00695 <span class="comment">/* The G matrix is an NxN matrix formed in two steps.</span>
<a name="l00696"></a>00696 <span class="comment">   1. Each element in the diagonal matrix is equal to the sum of the</span>
<a name="l00697"></a>00697 <span class="comment">   conductance of each element connected to the corresponding node.</span>
<a name="l00698"></a>00698 <span class="comment">   2. The off diagonal elements are the negative conductance of the</span>
<a name="l00699"></a>00699 <span class="comment">   element connected to the pair of corresponding nodes.  Therefore a</span>
<a name="l00700"></a>00700 <span class="comment">   resistor between nodes 1 and 2 goes into the G matrix at location</span>
<a name="l00701"></a>00701 <span class="comment">   (1,2) and location (2,1).  If an element is grounded, it will only</span>
<a name="l00702"></a>00702 <span class="comment">   have contribute to one entry in the G matrix -- at the appropriate</span>
<a name="l00703"></a>00703 <span class="comment">   location on the diagonal. */</span>
<a name="l00704"></a>00704 <span class="keyword">template</span> &lt;<span class="keyword">class</span> nr_type_t&gt;
<a name="l00705"></a><a class="code" href="classqucs_1_1nasolver.html#a53247cf2e548e6d858dc49684e2caf4d">00705</a> <span class="keywordtype">void</span> <a class="code" href="classqucs_1_1nasolver.html">nasolver&lt;nr_type_t&gt;::createGMatrix</a> (<span class="keywordtype">void</span>)
<a name="l00706"></a>00706 {
<a name="l00707"></a>00707     <span class="keywordtype">int</span> pr, pc, <a class="code" href="equation_8cpp.html#a540f72cb9bcf86a19e3bbc259b9ec3e0">N</a> = countNodes ();
<a name="l00708"></a>00708     nr_type_t g;
<a name="l00709"></a>00709     <span class="keyword">struct </span><a class="code" href="structqucs_1_1nodelist__t.html">nodelist_t</a> * nr, * nc;
<a name="l00710"></a>00710     <a class="code" href="classqucs_1_1circuit.html" title="base class for qucs circuit elements.">circuit</a> * ct;
<a name="l00711"></a>00711 
<a name="l00712"></a>00712     <span class="comment">// go through each column of the G matrix</span>
<a name="l00713"></a>00713     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a> = 0; <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a> &lt; <a class="code" href="equation_8cpp.html#a540f72cb9bcf86a19e3bbc259b9ec3e0">N</a>; <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>++)
<a name="l00714"></a>00714     {
<a name="l00715"></a>00715         nc = nlist-&gt;getNode (<a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>);
<a name="l00716"></a>00716         <span class="comment">// go through each row of the G matrix</span>
<a name="l00717"></a>00717         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a> = 0; <a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a> &lt; <a class="code" href="equation_8cpp.html#a540f72cb9bcf86a19e3bbc259b9ec3e0">N</a>; <a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>++)
<a name="l00718"></a>00718         {
<a name="l00719"></a>00719             nr = nlist-&gt;getNode (<a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>);
<a name="l00720"></a>00720             g = 0.0;
<a name="l00721"></a>00721             <span class="comment">// sum up the conductance of each connected circuit</span>
<a name="l00722"></a>00722             <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; currentnc  : *nc)
<a name="l00723"></a>00723               <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; currentnr: *nr)
<a name="l00724"></a>00724                 <span class="keywordflow">if</span> (currentnc-&gt;getCircuit () == currentnr-&gt;getCircuit ())
<a name="l00725"></a>00725                   {
<a name="l00726"></a>00726                     ct = currentnc-&gt;getCircuit ();
<a name="l00727"></a>00727                     pc = currentnc-&gt;<a class="code" href="classqucs_1_1circuit.html#a17043c703b3b7383280683e879de1895">getPort</a> ();
<a name="l00728"></a>00728                     pr = currentnr-&gt;getPort ();
<a name="l00729"></a>00729                     g += <a class="code" href="nasolver_8cpp.html#a220f4ccccd29d482d2059cc54e84285a">MatVal</a> (ct-&gt;<a class="code" href="classqucs_1_1circuit.html#a3330ef02ed45fce0d4eb09a44300a1e9">getY</a> (pr, pc));
<a name="l00730"></a>00730                   }
<a name="l00731"></a>00731             <span class="comment">// put value into G matrix</span>
<a name="l00732"></a>00732             <a class="code" href="eqndefined_8cpp.html#a70993d52766e31cb0157958a18aa499a">A</a>-&gt;set (<a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>, <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>, g);
<a name="l00733"></a>00733         }
<a name="l00734"></a>00734     }
<a name="l00735"></a>00735 }
<a name="l00736"></a>00736 
<a name="l00737"></a>00737 <span class="comment">/* The following function creates the (N+M)x(N+M) noise current</span>
<a name="l00738"></a>00738 <span class="comment">   correlation matrix used during the AC noise computations.  */</span>
<a name="l00739"></a>00739 <span class="keyword">template</span> &lt;<span class="keyword">class</span> nr_type_t&gt;
<a name="l00740"></a><a class="code" href="classqucs_1_1nasolver.html#a6945245ab021dbf2c688c643a60e972d">00740</a> <span class="keywordtype">void</span> <a class="code" href="classqucs_1_1nasolver.html">nasolver&lt;nr_type_t&gt;::createNoiseMatrix</a> (<span class="keywordtype">void</span>)
<a name="l00741"></a>00741 {
<a name="l00742"></a>00742     <span class="keywordtype">int</span> pr, pc, <a class="code" href="equation_8cpp.html#a540f72cb9bcf86a19e3bbc259b9ec3e0">N</a> = countNodes ();
<a name="l00743"></a>00743     <span class="keywordtype">int</span> <a class="code" href="evaluate_8cpp.html#a92592142cb41364b6fe6ef9cc1a16dbd">M</a> = countVoltageSources ();
<a name="l00744"></a>00744     <span class="keyword">struct </span><a class="code" href="structqucs_1_1nodelist__t.html">nodelist_t</a> * <a class="code" href="parse__mdl_8y.html#aecba4cab5e52994730d1e21424997b33">n</a>;
<a name="l00745"></a>00745     nr_type_t val;
<a name="l00746"></a>00746     <span class="keywordtype">int</span> <a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>, <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>, ri, ci;
<a name="l00747"></a>00747     <span class="keyword">struct </span><a class="code" href="structqucs_1_1nodelist__t.html">nodelist_t</a> * nr, * nc;
<a name="l00748"></a>00748     <a class="code" href="classqucs_1_1circuit.html" title="base class for qucs circuit elements.">circuit</a> * ct;
<a name="l00749"></a>00749 
<a name="l00750"></a>00750     <span class="comment">// create new Cy matrix if necessary</span>
<a name="l00751"></a>00751     <span class="keywordflow">if</span> (<a class="code" href="eqndefined_8cpp.html#ad1368c2a0fa68385ecdd9f1016563c08">C</a> != NULL) <span class="keyword">delete</span> <a class="code" href="eqndefined_8cpp.html#ad1368c2a0fa68385ecdd9f1016563c08">C</a>;
<a name="l00752"></a>00752     <a class="code" href="eqndefined_8cpp.html#ad1368c2a0fa68385ecdd9f1016563c08">C</a> = <span class="keyword">new</span> <a class="code" href="classqucs_1_1tmatrix.html">tmatrix&lt;nr_type_t&gt;</a> (N + <a class="code" href="evaluate_8cpp.html#a92592142cb41364b6fe6ef9cc1a16dbd">M</a>);
<a name="l00753"></a>00753 
<a name="l00754"></a>00754     <span class="comment">// go through each column of the Cy matrix</span>
<a name="l00755"></a>00755     <span class="keywordflow">for</span> (c = 0; c &lt; <a class="code" href="equation_8cpp.html#a540f72cb9bcf86a19e3bbc259b9ec3e0">N</a>; c++)
<a name="l00756"></a>00756     {
<a name="l00757"></a>00757         nc = nlist-&gt;getNode (c);
<a name="l00758"></a>00758         <span class="comment">// go through each row of the Cy matrix</span>
<a name="l00759"></a>00759         <span class="keywordflow">for</span> (r = 0; r &lt; <a class="code" href="equation_8cpp.html#a540f72cb9bcf86a19e3bbc259b9ec3e0">N</a>; r++)
<a name="l00760"></a>00760         {
<a name="l00761"></a>00761             nr = nlist-&gt;getNode (r);
<a name="l00762"></a>00762             val = 0.0;
<a name="l00763"></a>00763             <span class="comment">// sum up the noise-correlation of each connected circuit</span>
<a name="l00764"></a>00764             <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; currentnc: *nc)
<a name="l00765"></a>00765                 <span class="comment">/* a = 0; a &lt; nc-&gt;size(); a++ */</span>
<a name="l00766"></a>00766               <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;currentnr : *nr)
<a name="l00767"></a>00767                 <span class="comment">/* b = 0; b &lt; nr-&gt;size(); b++) */</span>
<a name="l00768"></a>00768                     <span class="keywordflow">if</span> (currentnc-&gt;getCircuit () == currentnr-&gt;getCircuit ())
<a name="l00769"></a>00769                     {
<a name="l00770"></a>00770                         ct = currentnc-&gt;getCircuit ();
<a name="l00771"></a>00771                         pc = currentnc-&gt;<a class="code" href="classqucs_1_1circuit.html#a17043c703b3b7383280683e879de1895">getPort</a> ();
<a name="l00772"></a>00772                         pr = currentnr-&gt;getPort ();
<a name="l00773"></a>00773                         val += <a class="code" href="nasolver_8cpp.html#a220f4ccccd29d482d2059cc54e84285a">MatVal</a> (ct-&gt;<a class="code" href="classqucs_1_1circuit.html#aced0e5d4ad6c9035438ca25857f291e0">getN</a> (pr, pc));
<a name="l00774"></a>00774                     }
<a name="l00775"></a>00775             <span class="comment">// put value into Cy matrix</span>
<a name="l00776"></a>00776             <a class="code" href="eqndefined_8cpp.html#ad1368c2a0fa68385ecdd9f1016563c08">C</a>-&gt;set (r, c, val);
<a name="l00777"></a>00777         }
<a name="l00778"></a>00778     }
<a name="l00779"></a>00779 
<a name="l00780"></a>00780     <span class="comment">// go through each additional voltage source and put coefficients into</span>
<a name="l00781"></a>00781     <span class="comment">// the noise current correlation matrix</span>
<a name="l00782"></a>00782     <a class="code" href="classqucs_1_1circuit.html" title="base class for qucs circuit elements.">circuit</a> * vsr, * vsc;
<a name="l00783"></a>00783     <span class="keywordflow">for</span> (r = 0; r &lt; <a class="code" href="evaluate_8cpp.html#a92592142cb41364b6fe6ef9cc1a16dbd">M</a>; r++)
<a name="l00784"></a>00784     {
<a name="l00785"></a>00785         vsr = findVoltageSource (r);
<a name="l00786"></a>00786         <span class="keywordflow">for</span> (c = 0; c &lt; <a class="code" href="evaluate_8cpp.html#a92592142cb41364b6fe6ef9cc1a16dbd">M</a>; c++)
<a name="l00787"></a>00787         {
<a name="l00788"></a>00788             vsc = findVoltageSource (c);
<a name="l00789"></a>00789             val = 0.0;
<a name="l00790"></a>00790             <span class="keywordflow">if</span> (vsr == vsc)
<a name="l00791"></a>00791             {
<a name="l00792"></a>00792                 ri = vsr-&gt;<a class="code" href="classqucs_1_1circuit.html#aed2de3b676324a1c1ded4e0f3c6025a4" title="Get the number of ports the circuit element has.">getSize</a> () + r - vsr-&gt;<a class="code" href="classqucs_1_1circuit.html#a393ca06fd0735f88c9cd98e82a67a074">getVoltageSource</a> ();
<a name="l00793"></a>00793                 ci = vsc-&gt;<a class="code" href="classqucs_1_1circuit.html#aed2de3b676324a1c1ded4e0f3c6025a4" title="Get the number of ports the circuit element has.">getSize</a> () + c - vsc-&gt;<a class="code" href="classqucs_1_1circuit.html#a393ca06fd0735f88c9cd98e82a67a074">getVoltageSource</a> ();
<a name="l00794"></a>00794                 val = <a class="code" href="nasolver_8cpp.html#a220f4ccccd29d482d2059cc54e84285a">MatVal</a> (vsr-&gt;<a class="code" href="classqucs_1_1circuit.html#aced0e5d4ad6c9035438ca25857f291e0">getN</a> (ri, ci));
<a name="l00795"></a>00795             }
<a name="l00796"></a>00796             <a class="code" href="eqndefined_8cpp.html#ad1368c2a0fa68385ecdd9f1016563c08">C</a>-&gt;set (r + N, c + N, val);
<a name="l00797"></a>00797         }
<a name="l00798"></a>00798     }
<a name="l00799"></a>00799 
<a name="l00800"></a>00800     <span class="comment">// go through each additional voltage source</span>
<a name="l00801"></a>00801     <span class="keywordflow">for</span> (r = 0; r &lt; <a class="code" href="evaluate_8cpp.html#a92592142cb41364b6fe6ef9cc1a16dbd">M</a>; r++)
<a name="l00802"></a>00802     {
<a name="l00803"></a>00803         vsr = findVoltageSource (r);
<a name="l00804"></a>00804         <span class="comment">// go through each node</span>
<a name="l00805"></a>00805         <span class="keywordflow">for</span> (c = 0; c &lt; <a class="code" href="equation_8cpp.html#a540f72cb9bcf86a19e3bbc259b9ec3e0">N</a>; c++)
<a name="l00806"></a>00806         {
<a name="l00807"></a>00807             val = 0.0;
<a name="l00808"></a>00808             n = nlist-&gt;getNode (c);
<a name="l00809"></a>00809             <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;currentn: *n)
<a name="l00810"></a>00810               <span class="comment">/*i = 0; i &lt; n-&gt;size(); i++ )*/</span>
<a name="l00811"></a>00811             {
<a name="l00812"></a>00812                 <span class="comment">// is voltage source connected to node ?</span>
<a name="l00813"></a>00813                 <span class="keywordflow">if</span> (currentn-&gt;getCircuit () == vsr)
<a name="l00814"></a>00814                 {
<a name="l00815"></a>00815                     ri = vsr-&gt;<a class="code" href="classqucs_1_1circuit.html#aed2de3b676324a1c1ded4e0f3c6025a4" title="Get the number of ports the circuit element has.">getSize</a> () + r - vsr-&gt;<a class="code" href="classqucs_1_1circuit.html#a393ca06fd0735f88c9cd98e82a67a074">getVoltageSource</a> ();
<a name="l00816"></a>00816                     ci = currentn-&gt;getPort ();
<a name="l00817"></a>00817                     val += <a class="code" href="nasolver_8cpp.html#a220f4ccccd29d482d2059cc54e84285a">MatVal</a> (vsr-&gt;<a class="code" href="classqucs_1_1circuit.html#aced0e5d4ad6c9035438ca25857f291e0">getN</a> (ri, ci));
<a name="l00818"></a>00818                 }
<a name="l00819"></a>00819             }
<a name="l00820"></a>00820             <span class="comment">// put value into Cy matrix</span>
<a name="l00821"></a>00821             <a class="code" href="eqndefined_8cpp.html#ad1368c2a0fa68385ecdd9f1016563c08">C</a>-&gt;set (r + N, c, val);
<a name="l00822"></a>00822         }
<a name="l00823"></a>00823     }
<a name="l00824"></a>00824 
<a name="l00825"></a>00825     <span class="comment">// go through each voltage source</span>
<a name="l00826"></a>00826     <span class="keywordflow">for</span> (c = 0; c &lt; <a class="code" href="evaluate_8cpp.html#a92592142cb41364b6fe6ef9cc1a16dbd">M</a>; c++)
<a name="l00827"></a>00827     {
<a name="l00828"></a>00828         vsc = findVoltageSource (c);
<a name="l00829"></a>00829         <span class="comment">// go through each node</span>
<a name="l00830"></a>00830         <span class="keywordflow">for</span> (r = 0; r &lt; <a class="code" href="equation_8cpp.html#a540f72cb9bcf86a19e3bbc259b9ec3e0">N</a>; r++)
<a name="l00831"></a>00831         {
<a name="l00832"></a>00832             val = 0.0;
<a name="l00833"></a>00833             n = nlist-&gt;getNode (r);
<a name="l00834"></a>00834             <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; currentn: *n)<span class="comment">/*i = 0; i &lt; n-&gt;size(); i++)*/</span>
<a name="l00835"></a>00835             {
<a name="l00836"></a>00836                 <span class="comment">// is voltage source connected to node ?</span>
<a name="l00837"></a>00837                 <span class="keywordflow">if</span> (currentn-&gt;getCircuit () == vsc)
<a name="l00838"></a>00838                 {
<a name="l00839"></a>00839                     ci = vsc-&gt;<a class="code" href="classqucs_1_1circuit.html#aed2de3b676324a1c1ded4e0f3c6025a4" title="Get the number of ports the circuit element has.">getSize</a> () + c - vsc-&gt;<a class="code" href="classqucs_1_1circuit.html#a393ca06fd0735f88c9cd98e82a67a074">getVoltageSource</a> ();
<a name="l00840"></a>00840                     ri = currentn-&gt;getPort ();
<a name="l00841"></a>00841                     val += <a class="code" href="nasolver_8cpp.html#a220f4ccccd29d482d2059cc54e84285a">MatVal</a> (vsc-&gt;<a class="code" href="classqucs_1_1circuit.html#aced0e5d4ad6c9035438ca25857f291e0">getN</a> (ri, ci));
<a name="l00842"></a>00842                 }
<a name="l00843"></a>00843             }
<a name="l00844"></a>00844             <span class="comment">// put value into Cy matrix</span>
<a name="l00845"></a>00845             <a class="code" href="eqndefined_8cpp.html#ad1368c2a0fa68385ecdd9f1016563c08">C</a>-&gt;set (r, c + N, val);
<a name="l00846"></a>00846         }
<a name="l00847"></a>00847     }
<a name="l00848"></a>00848 
<a name="l00849"></a>00849 }
<a name="l00850"></a>00850 
<a name="l00851"></a>00851 <span class="comment">/* The i matrix is an 1xN matrix with each element of the matrix</span>
<a name="l00852"></a>00852 <span class="comment">   corresponding to a particular node.  The value of each element of i</span>
<a name="l00853"></a>00853 <span class="comment">   is determined by the sum of current sources into the corresponding</span>
<a name="l00854"></a>00854 <span class="comment">   node.  If there are no current sources connected to the node, the</span>
<a name="l00855"></a>00855 <span class="comment">   value is zero. */</span>
<a name="l00856"></a>00856 <span class="keyword">template</span> &lt;<span class="keyword">class</span> nr_type_t&gt;
<a name="l00857"></a><a class="code" href="classqucs_1_1nasolver.html#a6297860c2de13927f8856c22e3bf05d3">00857</a> <span class="keywordtype">void</span> <a class="code" href="classqucs_1_1nasolver.html">nasolver&lt;nr_type_t&gt;::createIVector</a> (<span class="keywordtype">void</span>)
<a name="l00858"></a>00858 {
<a name="l00859"></a>00859     <span class="keywordtype">int</span> <a class="code" href="equation_8cpp.html#a540f72cb9bcf86a19e3bbc259b9ec3e0">N</a> = countNodes ();
<a name="l00860"></a>00860     nr_type_t val;
<a name="l00861"></a>00861     <span class="keyword">struct </span><a class="code" href="structqucs_1_1nodelist__t.html">nodelist_t</a> * <a class="code" href="parse__mdl_8y.html#aecba4cab5e52994730d1e21424997b33">n</a>;
<a name="l00862"></a>00862     <a class="code" href="classqucs_1_1circuit.html" title="base class for qucs circuit elements.">circuit</a> * is;
<a name="l00863"></a>00863 
<a name="l00864"></a>00864     <span class="comment">// go through each node</span>
<a name="l00865"></a>00865     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a> = 0; <a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a> &lt; <a class="code" href="equation_8cpp.html#a540f72cb9bcf86a19e3bbc259b9ec3e0">N</a>; <a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>++)
<a name="l00866"></a>00866     {
<a name="l00867"></a>00867         val = 0.0;
<a name="l00868"></a>00868         n = nlist-&gt;getNode (<a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>);
<a name="l00869"></a>00869         <span class="comment">// go through each circuit connected to the node</span>
<a name="l00870"></a>00870         <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;currentn: *n)<span class="comment">/* int i = 0; i &lt; n-&gt;size(); i++)*/</span>
<a name="l00871"></a>00871         {
<a name="l00872"></a>00872           is = currentn-&gt;getCircuit ();
<a name="l00873"></a>00873           <span class="comment">// is this a current source ?</span>
<a name="l00874"></a>00874           <span class="keywordflow">if</span> (is-&gt;<a class="code" href="classqucs_1_1circuit.html#a6bd96470c26b78584d9b768ad18bbe26">isISource</a> () || is-&gt;<a class="code" href="classqucs_1_1circuit.html#afe88405035b514cb9c3f85a958c22e08">isNonLinear</a> ())
<a name="l00875"></a>00875             {
<a name="l00876"></a>00876               val += <a class="code" href="nasolver_8cpp.html#a220f4ccccd29d482d2059cc54e84285a">MatVal</a> (is-&gt;<a class="code" href="classqucs_1_1circuit.html#af96530899423e89fa1e05b281db62297">getI</a> (currentn-&gt;getPort ()));
<a name="l00877"></a>00877             }
<a name="l00878"></a>00878         }
<a name="l00879"></a>00879         <span class="comment">// put value into i vector</span>
<a name="l00880"></a>00880         z-&gt;set (<a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>, val);
<a name="l00881"></a>00881     }
<a name="l00882"></a>00882 }
<a name="l00883"></a>00883 
<a name="l00884"></a>00884 <span class="comment">/* The e matrix is a 1xM matrix with each element of the matrix equal</span>
<a name="l00885"></a>00885 <span class="comment">   in value to the corresponding independent voltage source. */</span>
<a name="l00886"></a>00886 <span class="keyword">template</span> &lt;<span class="keyword">class</span> nr_type_t&gt;
<a name="l00887"></a><a class="code" href="classqucs_1_1nasolver.html#a7018cfcde9b39f43aad79da498074254">00887</a> <span class="keywordtype">void</span> <a class="code" href="classqucs_1_1nasolver.html">nasolver&lt;nr_type_t&gt;::createEVector</a> (<span class="keywordtype">void</span>)
<a name="l00888"></a>00888 {
<a name="l00889"></a>00889     <span class="keywordtype">int</span> <a class="code" href="equation_8cpp.html#a540f72cb9bcf86a19e3bbc259b9ec3e0">N</a> = countNodes ();
<a name="l00890"></a>00890     <span class="keywordtype">int</span> <a class="code" href="evaluate_8cpp.html#a92592142cb41364b6fe6ef9cc1a16dbd">M</a> = countVoltageSources ();
<a name="l00891"></a>00891     nr_type_t val;
<a name="l00892"></a>00892     <a class="code" href="classqucs_1_1circuit.html" title="base class for qucs circuit elements.">circuit</a> * vs;
<a name="l00893"></a>00893 
<a name="l00894"></a>00894     <span class="comment">// go through each voltage source</span>
<a name="l00895"></a>00895     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a> = 0; <a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a> &lt; <a class="code" href="evaluate_8cpp.html#a92592142cb41364b6fe6ef9cc1a16dbd">M</a>; <a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>++)
<a name="l00896"></a>00896     {
<a name="l00897"></a>00897         vs = findVoltageSource (<a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>);
<a name="l00898"></a>00898         val = <a class="code" href="nasolver_8cpp.html#a220f4ccccd29d482d2059cc54e84285a">MatVal</a> (vs-&gt;<a class="code" href="classqucs_1_1circuit.html#a502a0288b7cdae7d24853590eb3eb8cd">getE</a> (<a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>));
<a name="l00899"></a>00899         <span class="comment">// put value into e vector</span>
<a name="l00900"></a>00900         z-&gt;set (<a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a> + N, val);
<a name="l00901"></a>00901     }
<a name="l00902"></a>00902 }
<a name="l00903"></a>00903 
<a name="l00904"></a>00904 <span class="comment">// The function loads the right hand side vector.</span>
<a name="l00905"></a>00905 <span class="keyword">template</span> &lt;<span class="keyword">class</span> nr_type_t&gt;
<a name="l00906"></a><a class="code" href="classqucs_1_1nasolver.html#adc22b0b574f649f5c1f9556e5719a21b">00906</a> <span class="keywordtype">void</span> <a class="code" href="classqucs_1_1nasolver.html">nasolver&lt;nr_type_t&gt;::createZVector</a> (<span class="keywordtype">void</span>)
<a name="l00907"></a>00907 {
<a name="l00908"></a>00908     createIVector ();
<a name="l00909"></a>00909     createEVector ();
<a name="l00910"></a>00910 }
<a name="l00911"></a>00911 
<a name="l00912"></a>00912 <span class="comment">// Returns the number of nodes in the nodelist, excluding the ground node.</span>
<a name="l00913"></a>00913 <span class="keyword">template</span> &lt;<span class="keyword">class</span> nr_type_t&gt;
<a name="l00914"></a><a class="code" href="classqucs_1_1nasolver.html#a32f6859eb73548191778080b37c71ac0">00914</a> <span class="keywordtype">int</span> <a class="code" href="classqucs_1_1nasolver.html">nasolver&lt;nr_type_t&gt;::countNodes</a> (<span class="keywordtype">void</span>)
<a name="l00915"></a>00915 {
<a name="l00916"></a>00916     <span class="keywordflow">return</span> nlist-&gt;length () - 1;
<a name="l00917"></a>00917 }
<a name="l00918"></a>00918 
<a name="l00919"></a>00919 <span class="comment">// Returns the node number of the give node name.</span>
<a name="l00920"></a>00920 <span class="keyword">template</span> &lt;<span class="keyword">class</span> nr_type_t&gt;
<a name="l00921"></a><a class="code" href="classqucs_1_1nasolver.html#a07d28072d8389ef21dc63a33307f65e6">00921</a> <span class="keywordtype">int</span> <a class="code" href="classqucs_1_1nasolver.html">nasolver&lt;nr_type_t&gt;::getNodeNr</a> (<span class="keyword">const</span> <a class="code" href="namespacetesting_1_1internal.html#a5ca8a348395a6145775c1a2334e21889">std::string</a> &amp;<a class="code" href="parse__spice_8y.html#ab50d783982593ef993ea0b68f7ad8b80">str</a>)
<a name="l00922"></a>00922 {
<a name="l00923"></a>00923     <span class="keywordflow">return</span> nlist-&gt;<a class="code" href="classqucs_1_1nasolver.html#a07d28072d8389ef21dc63a33307f65e6">getNodeNr</a> (str);
<a name="l00924"></a>00924 }
<a name="l00925"></a>00925 
<a name="l00926"></a>00926 <span class="comment">/* The function returns the assigned node number for the port of the</span>
<a name="l00927"></a>00927 <span class="comment">   given circuits.  It returns -1 if there is no such node. */</span>
<a name="l00928"></a>00928 <span class="keyword">template</span> &lt;<span class="keyword">class</span> nr_type_t&gt;
<a name="l00929"></a><a class="code" href="classqucs_1_1nasolver.html#a44fcadbb8ed1dc470504713a14615182">00929</a> <span class="keywordtype">int</span> <a class="code" href="classqucs_1_1nasolver.html">nasolver&lt;nr_type_t&gt;::findAssignedNode</a> (<a class="code" href="classqucs_1_1circuit.html" title="base class for qucs circuit elements.">circuit</a> * <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>, <span class="keywordtype">int</span> port)
<a name="l00930"></a>00930 {
<a name="l00931"></a>00931     <span class="keywordtype">int</span> <a class="code" href="equation_8cpp.html#a540f72cb9bcf86a19e3bbc259b9ec3e0">N</a> = countNodes ();
<a name="l00932"></a>00932     <span class="keyword">struct </span><a class="code" href="structqucs_1_1nodelist__t.html">nodelist_t</a> * <a class="code" href="parse__mdl_8y.html#aecba4cab5e52994730d1e21424997b33">n</a>;
<a name="l00933"></a>00933     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a> = 0; <a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a> &lt; <a class="code" href="equation_8cpp.html#a540f72cb9bcf86a19e3bbc259b9ec3e0">N</a>; <a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>++)
<a name="l00934"></a>00934     {
<a name="l00935"></a>00935         n = nlist-&gt;getNode (<a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>);
<a name="l00936"></a>00936         <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;currentn : *n) <span class="comment">/*int i = 0; i &lt; n-&gt;size(); i++)*/</span>
<a name="l00937"></a>00937             <span class="keywordflow">if</span> (c == currentn-&gt;getCircuit ())
<a name="l00938"></a>00938                 <span class="keywordflow">if</span> (port == currentn-&gt;getPort ())
<a name="l00939"></a>00939                     <span class="keywordflow">return</span> <a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>;
<a name="l00940"></a>00940     }
<a name="l00941"></a>00941     <span class="keywordflow">return</span> -1;
<a name="l00942"></a>00942 }
<a name="l00943"></a>00943 
<a name="l00944"></a>00944 <span class="comment">// Returns the number of voltage sources in the nodelist.</span>
<a name="l00945"></a>00945 <span class="keyword">template</span> &lt;<span class="keyword">class</span> nr_type_t&gt;
<a name="l00946"></a><a class="code" href="classqucs_1_1nasolver.html#a5430c3ad45bf7327d9f1e343159d0f43">00946</a> <span class="keywordtype">int</span> <a class="code" href="classqucs_1_1nasolver.html">nasolver&lt;nr_type_t&gt;::countVoltageSources</a> (<span class="keywordtype">void</span>)
<a name="l00947"></a>00947 {
<a name="l00948"></a>00948     <span class="keywordflow">return</span> subnet-&gt;getVoltageSources ();
<a name="l00949"></a>00949 }
<a name="l00950"></a>00950 
<a name="l00951"></a>00951 <span class="comment">/* The function returns the voltage source circuit object</span>
<a name="l00952"></a>00952 <span class="comment">   corresponding to the given number.  If there is no such voltage</span>
<a name="l00953"></a>00953 <span class="comment">   source it returns NULL. */</span>
<a name="l00954"></a>00954 <span class="keyword">template</span> &lt;<span class="keyword">class</span> nr_type_t&gt;
<a name="l00955"></a><a class="code" href="classqucs_1_1nasolver.html#a10c01ac4bc6854599dd1d6f6d090cc75">00955</a> <a class="code" href="classqucs_1_1circuit.html" title="base class for qucs circuit elements.">circuit</a> * <a class="code" href="classqucs_1_1nasolver.html">nasolver&lt;nr_type_t&gt;::findVoltageSource</a> (<span class="keywordtype">int</span> <a class="code" href="parse__mdl_8y.html#aecba4cab5e52994730d1e21424997b33">n</a>)
<a name="l00956"></a>00956 {
<a name="l00957"></a>00957     <a class="code" href="classqucs_1_1circuit.html" title="base class for qucs circuit elements.">circuit</a> * root = subnet-&gt;getRoot ();
<a name="l00958"></a>00958     <span class="keywordflow">for</span> (<a class="code" href="classqucs_1_1circuit.html" title="base class for qucs circuit elements.">circuit</a> * <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a> = root; <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a> != NULL; <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a> = (<a class="code" href="classqucs_1_1circuit.html" title="base class for qucs circuit elements.">circuit</a> *) <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>-&gt;<a class="code" href="classqucs_1_1eqn_1_1node.html#ad2f8b4edb365f182a9c9eed4af7491fc">getNext</a> ())
<a name="l00959"></a>00959     {
<a name="l00960"></a>00960         <span class="keywordflow">if</span> (n &gt;= <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>-&gt;getVoltageSource () &amp;&amp;
<a name="l00961"></a>00961                 n &lt;= <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>-&gt;getVoltageSource () + <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>-&gt;getVoltageSources () - 1)
<a name="l00962"></a>00962             <span class="keywordflow">return</span> <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>;
<a name="l00963"></a>00963     }
<a name="l00964"></a>00964     <span class="keywordflow">return</span> NULL;
<a name="l00965"></a>00965 }
<a name="l00966"></a>00966 
<a name="l00967"></a>00967 <span class="comment">/* The function applies unique voltage source identifiers to each</span>
<a name="l00968"></a>00968 <span class="comment">   voltage source (explicit and built in internal ones) in the list of</span>
<a name="l00969"></a>00969 <span class="comment">   registered circuits. */</span>
<a name="l00970"></a>00970 <span class="keyword">template</span> &lt;<span class="keyword">class</span> nr_type_t&gt;
<a name="l00971"></a><a class="code" href="classqucs_1_1nasolver.html#aa3958c69c3b0df7815521c7cfd5feff7">00971</a> <span class="keywordtype">void</span> <a class="code" href="classqucs_1_1nasolver.html">nasolver&lt;nr_type_t&gt;::assignVoltageSources</a> (<span class="keywordtype">void</span>)
<a name="l00972"></a>00972 {
<a name="l00973"></a>00973     <a class="code" href="classqucs_1_1circuit.html" title="base class for qucs circuit elements.">circuit</a> * root = subnet-&gt;getRoot ();
<a name="l00974"></a>00974     <span class="keywordtype">int</span> nSources = 0;
<a name="l00975"></a>00975     <span class="keywordflow">for</span> (<a class="code" href="classqucs_1_1circuit.html" title="base class for qucs circuit elements.">circuit</a> * <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a> = root; <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a> != NULL; <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a> = (<a class="code" href="classqucs_1_1circuit.html" title="base class for qucs circuit elements.">circuit</a> *) <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>-&gt;<a class="code" href="classqucs_1_1eqn_1_1node.html#ad2f8b4edb365f182a9c9eed4af7491fc">getNext</a> ())
<a name="l00976"></a>00976     {
<a name="l00977"></a>00977         <span class="keywordflow">if</span> (<a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>-&gt;getVoltageSources () &gt; 0)
<a name="l00978"></a>00978         {
<a name="l00979"></a>00979             <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>-&gt;setVoltageSource (nSources);
<a name="l00980"></a>00980             nSources += <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>-&gt;getVoltageSources ();
<a name="l00981"></a>00981         }
<a name="l00982"></a>00982     }
<a name="l00983"></a>00983     subnet-&gt;setVoltageSources (nSources);
<a name="l00984"></a>00984 }
<a name="l00985"></a>00985 
<a name="l00986"></a>00986 <span class="comment">/* The matrix equation Ax = z is solved by x = A^-1*z.  The function</span>
<a name="l00987"></a>00987 <span class="comment">   applies the operation to the previously generated matrices. */</span>
<a name="l00988"></a>00988 <span class="keyword">template</span> &lt;<span class="keyword">class</span> nr_type_t&gt;
<a name="l00989"></a><a class="code" href="classqucs_1_1nasolver.html#a53c0bcf9d6f7457f9cc8b9fbe685f66e">00989</a> <span class="keywordtype">void</span> <a class="code" href="classqucs_1_1nasolver.html">nasolver&lt;nr_type_t&gt;::runMNA</a> (<span class="keywordtype">void</span>)
<a name="l00990"></a>00990 {
<a name="l00991"></a>00991 
<a name="l00992"></a>00992     <span class="comment">// just solve the equation system here</span>
<a name="l00993"></a>00993     <a class="code" href="parse__netlist_8y.html#aad664ad10957bf531dcce47612c7677a">eqns</a>-&gt;setAlgo (eqnAlgo);
<a name="l00994"></a>00994     <a class="code" href="parse__netlist_8y.html#aad664ad10957bf531dcce47612c7677a">eqns</a>-&gt;passEquationSys (updateMatrix ? <a class="code" href="eqndefined_8cpp.html#a70993d52766e31cb0157958a18aa499a">A</a> : NULL, <a class="code" href="parse__mdl_8y.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>, z);
<a name="l00995"></a>00995     <a class="code" href="parse__netlist_8y.html#aad664ad10957bf531dcce47612c7677a">eqns</a>-&gt;solve ();
<a name="l00996"></a>00996 
<a name="l00997"></a>00997     <span class="comment">// if damped Newton-Raphson is requested</span>
<a name="l00998"></a>00998     <span class="keywordflow">if</span> (xprev != NULL &amp;&amp; <a class="code" href="exceptionstack_8h.html#af6a3e10f858ba64bd0aee79b0bc2ca6c">top_exception</a> () == NULL)
<a name="l00999"></a>00999     {
<a name="l01000"></a>01000         <span class="keywordflow">if</span> (convHelper == <a class="code" href="nasolver_8h.html#aa82f6cb8837d1998b3d2944d841870b4">CONV_Attenuation</a>)
<a name="l01001"></a>01001         {
<a name="l01002"></a>01002             applyAttenuation ();
<a name="l01003"></a>01003         }
<a name="l01004"></a>01004         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (convHelper == <a class="code" href="nasolver_8h.html#abbd20ba066ff4757da98afbcb782c010">CONV_LineSearch</a>)
<a name="l01005"></a>01005         {
<a name="l01006"></a>01006             lineSearch ();
<a name="l01007"></a>01007         }
<a name="l01008"></a>01008         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (convHelper == <a class="code" href="nasolver_8h.html#acbe2ee03561cd901e9175a2492a9b3a0">CONV_SteepestDescent</a>)
<a name="l01009"></a>01009         {
<a name="l01010"></a>01010             steepestDescent ();
<a name="l01011"></a>01011         }
<a name="l01012"></a>01012     }
<a name="l01013"></a>01013 }
<a name="l01014"></a>01014 
<a name="l01015"></a>01015 <span class="comment">/* This function applies a damped Newton-Raphson (limiting scheme) to</span>
<a name="l01016"></a>01016 <span class="comment">   the current solution vector in the form x1 = x0 + a * (x1 - x0).  This</span>
<a name="l01017"></a>01017 <span class="comment">   convergence helper is heuristic and does not ensure global convergence. */</span>
<a name="l01018"></a>01018 <span class="keyword">template</span> &lt;<span class="keyword">class</span> nr_type_t&gt;
<a name="l01019"></a><a class="code" href="classqucs_1_1nasolver.html#a75ae41e47a3d513eeb66912d7312878e">01019</a> <span class="keywordtype">void</span> <a class="code" href="classqucs_1_1nasolver.html">nasolver&lt;nr_type_t&gt;::applyAttenuation</a> (<span class="keywordtype">void</span>)
<a name="l01020"></a>01020 {
<a name="l01021"></a>01021     <a class="code" href="config_8h.html#a014aadc409afb297b8247c13f8ca89be">nr_double_t</a> alpha = 1.0, nMax;
<a name="l01022"></a>01022 
<a name="l01023"></a>01023     <span class="comment">// create solution difference vector and find maximum deviation</span>
<a name="l01024"></a>01024     <a class="code" href="classqucs_1_1tvector.html">tvector&lt;nr_type_t&gt;</a> dx = *<a class="code" href="parse__mdl_8y.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a> - *xprev;
<a name="l01025"></a>01025     nMax = <a class="code" href="namespacequcs.html#a50191491a9970f32dc549b7ecdbf0ebb">maxnorm</a> (dx);
<a name="l01026"></a>01026 
<a name="l01027"></a>01027     <span class="comment">// compute appropriate damping factor</span>
<a name="l01028"></a>01028     <span class="keywordflow">if</span> (nMax &gt; 0.0)
<a name="l01029"></a>01029     {
<a name="l01030"></a>01030         <a class="code" href="config_8h.html#a014aadc409afb297b8247c13f8ca89be">nr_double_t</a> g = 1.0;
<a name="l01031"></a>01031         alpha = std::min (0.9, g / nMax);
<a name="l01032"></a>01032         <span class="keywordflow">if</span> (alpha &lt; 0.1) alpha = 0.1;
<a name="l01033"></a>01033     }
<a name="l01034"></a>01034 
<a name="l01035"></a>01035     <span class="comment">// apply damped solution vector</span>
<a name="l01036"></a>01036     *<a class="code" href="parse__mdl_8y.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a> = *xprev + alpha * dx;
<a name="l01037"></a>01037 }
<a name="l01038"></a>01038 
<a name="l01039"></a>01039 <span class="comment">/* This is damped Newton-Raphson using nested iterations in order to</span>
<a name="l01040"></a>01040 <span class="comment">   find a better damping factor.  It identifies a damping factor in</span>
<a name="l01041"></a>01041 <span class="comment">   the interval [0,1] which minimizes the right hand side vector.  The</span>
<a name="l01042"></a>01042 <span class="comment">   algorithm actually ensures global convergence but pushes the</span>
<a name="l01043"></a>01043 <span class="comment">   solution to local minimums, i.e. where the Jacobian matrix A may be</span>
<a name="l01044"></a>01044 <span class="comment">   singular. */</span>
<a name="l01045"></a>01045 <span class="keyword">template</span> &lt;<span class="keyword">class</span> nr_type_t&gt;
<a name="l01046"></a><a class="code" href="classqucs_1_1nasolver.html#ace057319b4f59952b294a23c8ce2e047">01046</a> <span class="keywordtype">void</span> <a class="code" href="classqucs_1_1nasolver.html">nasolver&lt;nr_type_t&gt;::lineSearch</a> (<span class="keywordtype">void</span>)
<a name="l01047"></a>01047 {
<a name="l01048"></a>01048     <a class="code" href="config_8h.html#a014aadc409afb297b8247c13f8ca89be">nr_double_t</a> alpha = 0.5, <a class="code" href="parse__mdl_8y.html#aecba4cab5e52994730d1e21424997b33">n</a>, nMin, aprev = 1.0, astep = 0.5, adiff;
<a name="l01049"></a>01049     <span class="keywordtype">int</span> dir = -1;
<a name="l01050"></a>01050 
<a name="l01051"></a>01051     <span class="comment">// compute solution deviation vector</span>
<a name="l01052"></a>01052     <a class="code" href="classqucs_1_1tvector.html">tvector&lt;nr_type_t&gt;</a> dx = *<a class="code" href="parse__mdl_8y.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a> - *xprev;
<a name="l01053"></a>01053     nMin = std::numeric_limits&lt;nr_double_t&gt;::max();
<a name="l01054"></a>01054 
<a name="l01055"></a>01055     <span class="keywordflow">do</span>
<a name="l01056"></a>01056     {
<a name="l01057"></a>01057         <span class="comment">// apply current damping factor and see what happens</span>
<a name="l01058"></a>01058         *<a class="code" href="parse__mdl_8y.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a> = *xprev + alpha * dx;
<a name="l01059"></a>01059 
<a name="l01060"></a>01060         <span class="comment">// recalculate Jacobian and right hand side</span>
<a name="l01061"></a>01061         saveSolution ();
<a name="l01062"></a>01062         calculate ();
<a name="l01063"></a>01063         createZVector ();
<a name="l01064"></a>01064 
<a name="l01065"></a>01065         <span class="comment">// calculate norm of right hand side vector</span>
<a name="l01066"></a>01066         <a class="code" href="parse__mdl_8y.html#aecba4cab5e52994730d1e21424997b33">n</a> = <a class="code" href="namespacequcs.html#a306364d94afda927aad792e0c1ff4e69" title="Compute euclidian norm of complex number.">norm</a> (*z);
<a name="l01067"></a>01067 
<a name="l01068"></a>01068         <span class="comment">// TODO: this is not perfect, but usable</span>
<a name="l01069"></a>01069         astep /= 2;
<a name="l01070"></a>01070         adiff = fabs (alpha - aprev);
<a name="l01071"></a>01071         <span class="keywordflow">if</span> (adiff &gt; 0.005)
<a name="l01072"></a>01072         {
<a name="l01073"></a>01073             aprev = alpha;
<a name="l01074"></a>01074             <span class="keywordflow">if</span> (<a class="code" href="parse__mdl_8y.html#aecba4cab5e52994730d1e21424997b33">n</a> &lt; nMin)
<a name="l01075"></a>01075             {
<a name="l01076"></a>01076                 nMin = <a class="code" href="parse__mdl_8y.html#aecba4cab5e52994730d1e21424997b33">n</a>;
<a name="l01077"></a>01077                 <span class="keywordflow">if</span> (alpha == 1) dir = -dir;
<a name="l01078"></a>01078                 alpha += astep * dir;
<a name="l01079"></a>01079             }
<a name="l01080"></a>01080             <span class="keywordflow">else</span>
<a name="l01081"></a>01081             {
<a name="l01082"></a>01082                 dir = -dir;
<a name="l01083"></a>01083                 alpha += 1.5 * astep * dir;
<a name="l01084"></a>01084             }
<a name="l01085"></a>01085         }
<a name="l01086"></a>01086     }
<a name="l01087"></a>01087     <span class="keywordflow">while</span> (adiff &gt; 0.005);
<a name="l01088"></a>01088 
<a name="l01089"></a>01089     <span class="comment">// apply final damping factor</span>
<a name="l01090"></a>01090     assert (alpha &gt; 0 &amp;&amp; alpha &lt;= 1);
<a name="l01091"></a>01091     *<a class="code" href="parse__mdl_8y.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a> = *xprev + alpha * dx;
<a name="l01092"></a>01092 }
<a name="l01093"></a>01093 
<a name="l01094"></a>01094 <span class="comment">/* The function looks for the optimal gradient for the right hand side</span>
<a name="l01095"></a>01095 <span class="comment">   vector using the so-called &#39;steepest descent&#39; method.  Though</span>
<a name="l01096"></a>01096 <span class="comment">   better than the one-dimensional linesearch (it doesn&#39;t push</span>
<a name="l01097"></a>01097 <span class="comment">   iterations into local minimums) it converges painfully slow. */</span>
<a name="l01098"></a>01098 <span class="keyword">template</span> &lt;<span class="keyword">class</span> nr_type_t&gt;
<a name="l01099"></a><a class="code" href="classqucs_1_1nasolver.html#a576b859ddf779a059b26cf668afec347">01099</a> <span class="keywordtype">void</span> <a class="code" href="classqucs_1_1nasolver.html">nasolver&lt;nr_type_t&gt;::steepestDescent</a> (<span class="keywordtype">void</span>)
<a name="l01100"></a>01100 {
<a name="l01101"></a>01101     <a class="code" href="config_8h.html#a014aadc409afb297b8247c13f8ca89be">nr_double_t</a> alpha = 1.0, sl, <a class="code" href="parse__mdl_8y.html#aecba4cab5e52994730d1e21424997b33">n</a>;
<a name="l01102"></a>01102 
<a name="l01103"></a>01103     <span class="comment">// compute solution deviation vector</span>
<a name="l01104"></a>01104     <a class="code" href="classqucs_1_1tvector.html">tvector&lt;nr_type_t&gt;</a> dx = *<a class="code" href="parse__mdl_8y.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a> - *xprev;
<a name="l01105"></a>01105     <a class="code" href="classqucs_1_1tvector.html">tvector&lt;nr_type_t&gt;</a> dz = *z - *zprev;
<a name="l01106"></a>01106     n = <a class="code" href="namespacequcs.html#a306364d94afda927aad792e0c1ff4e69" title="Compute euclidian norm of complex number.">norm</a> (*zprev);
<a name="l01107"></a>01107 
<a name="l01108"></a>01108     <span class="keywordflow">do</span>
<a name="l01109"></a>01109     {
<a name="l01110"></a>01110         <span class="comment">// apply current damping factor and see what happens</span>
<a name="l01111"></a>01111         *<a class="code" href="parse__mdl_8y.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a> = *xprev + alpha * dx;
<a name="l01112"></a>01112 
<a name="l01113"></a>01113         <span class="comment">// recalculate Jacobian and right hand side</span>
<a name="l01114"></a>01114         saveSolution ();
<a name="l01115"></a>01115         calculate ();
<a name="l01116"></a>01116         createZVector ();
<a name="l01117"></a>01117 
<a name="l01118"></a>01118         <span class="comment">// check gradient criteria, ThinkME: Is this correct?</span>
<a name="l01119"></a>01119         dz = *z - *zprev;
<a name="l01120"></a>01120         sl = <a class="code" href="namespacequcs.html#a0cc73c27d7d13b2200f2fddbb064dce6" title="Real part matrix.">real</a> (<a class="code" href="namespacequcs.html#a3c9648b3b0aab7b81797067ff891e7a2">sum</a> (dz * -dz));
<a name="l01121"></a>01121         <span class="keywordflow">if</span> (<a class="code" href="namespacequcs.html#a306364d94afda927aad792e0c1ff4e69" title="Compute euclidian norm of complex number.">norm</a> (*z) &lt; n + alpha * sl) <span class="keywordflow">break</span>;
<a name="l01122"></a>01122         alpha *= 0.7;
<a name="l01123"></a>01123     }
<a name="l01124"></a>01124     <span class="keywordflow">while</span> (alpha &gt; 0.001);
<a name="l01125"></a>01125 
<a name="l01126"></a>01126     <span class="comment">// apply final damping factor</span>
<a name="l01127"></a>01127     *<a class="code" href="parse__mdl_8y.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a> = *xprev + alpha * dx;
<a name="l01128"></a>01128 }
<a name="l01129"></a>01129 
<a name="l01130"></a>01130 <span class="comment">/* The function checks whether the iterative algorithm for linearizing</span>
<a name="l01131"></a>01131 <span class="comment">   the non-linear components in the network shows convergence.  It</span>
<a name="l01132"></a>01132 <span class="comment">   returns non-zero if it converges and zero otherwise. */</span>
<a name="l01133"></a>01133 <span class="keyword">template</span> &lt;<span class="keyword">class</span> nr_type_t&gt;
<a name="l01134"></a><a class="code" href="classqucs_1_1nasolver.html#a81a2489a468e3d8ee08ad07777967837">01134</a> <span class="keywordtype">int</span> <a class="code" href="classqucs_1_1nasolver.html">nasolver&lt;nr_type_t&gt;::checkConvergence</a> (<span class="keywordtype">void</span>)
<a name="l01135"></a>01135 {
<a name="l01136"></a>01136 
<a name="l01137"></a>01137     <span class="keywordtype">int</span> <a class="code" href="equation_8cpp.html#a540f72cb9bcf86a19e3bbc259b9ec3e0">N</a> = countNodes ();
<a name="l01138"></a>01138     <span class="keywordtype">int</span> <a class="code" href="evaluate_8cpp.html#a92592142cb41364b6fe6ef9cc1a16dbd">M</a> = countVoltageSources ();
<a name="l01139"></a>01139     <a class="code" href="config_8h.html#a014aadc409afb297b8247c13f8ca89be">nr_double_t</a> v_abs, v_rel, i_abs, i_rel;
<a name="l01140"></a>01140     <span class="keywordtype">int</span> <a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>;
<a name="l01141"></a>01141 
<a name="l01142"></a>01142     <span class="comment">// check the nodal voltage changes against the allowed absolute</span>
<a name="l01143"></a>01143     <span class="comment">// and relative tolerance values</span>
<a name="l01144"></a>01144     <span class="keywordflow">for</span> (r = 0; r &lt; <a class="code" href="equation_8cpp.html#a540f72cb9bcf86a19e3bbc259b9ec3e0">N</a>; r++)
<a name="l01145"></a>01145     {
<a name="l01146"></a>01146         v_abs = <a class="code" href="namespacequcs.html#ae19977dcd124dcf020fd21b46cf92e2f" title="Computes magnitude of each matrix element.">abs</a> (<a class="code" href="parse__mdl_8y.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>-&gt;get (r) - xprev-&gt;get (r));
<a name="l01147"></a>01147         v_rel = <a class="code" href="namespacequcs.html#ae19977dcd124dcf020fd21b46cf92e2f" title="Computes magnitude of each matrix element.">abs</a> (<a class="code" href="parse__mdl_8y.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>-&gt;get (r));
<a name="l01148"></a>01148         <span class="keywordflow">if</span> (v_abs &gt;= vntol + reltol * v_rel) <span class="keywordflow">return</span> 0;
<a name="l01149"></a>01149         <span class="keywordflow">if</span> (!convHelper)
<a name="l01150"></a>01150         {
<a name="l01151"></a>01151             i_abs = <a class="code" href="namespacequcs.html#ae19977dcd124dcf020fd21b46cf92e2f" title="Computes magnitude of each matrix element.">abs</a> (z-&gt;get (r) - zprev-&gt;get (r));
<a name="l01152"></a>01152             i_rel = <a class="code" href="namespacequcs.html#ae19977dcd124dcf020fd21b46cf92e2f" title="Computes magnitude of each matrix element.">abs</a> (z-&gt;get (r));
<a name="l01153"></a>01153             <span class="keywordflow">if</span> (i_abs &gt;= abstol + reltol * i_rel) <span class="keywordflow">return</span> 0;
<a name="l01154"></a>01154         }
<a name="l01155"></a>01155     }
<a name="l01156"></a>01156 
<a name="l01157"></a>01157     <span class="keywordflow">for</span> (r = 0; r &lt; <a class="code" href="evaluate_8cpp.html#a92592142cb41364b6fe6ef9cc1a16dbd">M</a>; r++)
<a name="l01158"></a>01158     {
<a name="l01159"></a>01159         i_abs = <a class="code" href="namespacequcs.html#ae19977dcd124dcf020fd21b46cf92e2f" title="Computes magnitude of each matrix element.">abs</a> (<a class="code" href="parse__mdl_8y.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>-&gt;get (r + N) - xprev-&gt;get (r + N));
<a name="l01160"></a>01160         i_rel = <a class="code" href="namespacequcs.html#ae19977dcd124dcf020fd21b46cf92e2f" title="Computes magnitude of each matrix element.">abs</a> (<a class="code" href="parse__mdl_8y.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>-&gt;get (r + N));
<a name="l01161"></a>01161         <span class="keywordflow">if</span> (i_abs &gt;= abstol + reltol * i_rel) <span class="keywordflow">return</span> 0;
<a name="l01162"></a>01162         <span class="keywordflow">if</span> (!convHelper)
<a name="l01163"></a>01163         {
<a name="l01164"></a>01164             v_abs = <a class="code" href="namespacequcs.html#ae19977dcd124dcf020fd21b46cf92e2f" title="Computes magnitude of each matrix element.">abs</a> (z-&gt;get (r + N) - zprev-&gt;get (r + N));
<a name="l01165"></a>01165             v_rel = <a class="code" href="namespacequcs.html#ae19977dcd124dcf020fd21b46cf92e2f" title="Computes magnitude of each matrix element.">abs</a> (z-&gt;get (r + N));
<a name="l01166"></a>01166             <span class="keywordflow">if</span> (v_abs &gt;= vntol + reltol * v_rel) <span class="keywordflow">return</span> 0;
<a name="l01167"></a>01167         }
<a name="l01168"></a>01168     }
<a name="l01169"></a>01169     <span class="keywordflow">return</span> 1;
<a name="l01170"></a>01170 }
<a name="l01171"></a>01171 
<a name="l01172"></a>01172 <span class="comment">/* The function saves the solution and right hand vector of the previous</span>
<a name="l01173"></a>01173 <span class="comment">   iteration. */</span>
<a name="l01174"></a>01174 <span class="keyword">template</span> &lt;<span class="keyword">class</span> nr_type_t&gt;
<a name="l01175"></a><a class="code" href="classqucs_1_1nasolver.html#a6bd4cab178fbff9e374e4cfa678fa0e1">01175</a> <span class="keywordtype">void</span> <a class="code" href="classqucs_1_1nasolver.html">nasolver&lt;nr_type_t&gt;::savePreviousIteration</a> (<span class="keywordtype">void</span>)
<a name="l01176"></a>01176 {
<a name="l01177"></a>01177     <span class="keywordflow">if</span> (xprev != NULL)
<a name="l01178"></a>01178         *xprev = *<a class="code" href="parse__mdl_8y.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>;
<a name="l01179"></a>01179     <span class="keywordflow">else</span>
<a name="l01180"></a>01180         xprev = <span class="keyword">new</span> <a class="code" href="classqucs_1_1tvector.html">tvector&lt;nr_type_t&gt;</a> (*x);
<a name="l01181"></a>01181     <span class="keywordflow">if</span> (zprev != NULL)
<a name="l01182"></a>01182         *zprev = *z;
<a name="l01183"></a>01183     <span class="keywordflow">else</span>
<a name="l01184"></a>01184         zprev = <span class="keyword">new</span> <a class="code" href="classqucs_1_1tvector.html">tvector&lt;nr_type_t&gt;</a> (*z);
<a name="l01185"></a>01185 }
<a name="l01186"></a>01186 
<a name="l01187"></a>01187 <span class="comment">/* The function restores the solution and right hand vector of the</span>
<a name="l01188"></a>01188 <span class="comment">   previous (successful) iteration. */</span>
<a name="l01189"></a>01189 <span class="keyword">template</span> &lt;<span class="keyword">class</span> nr_type_t&gt;
<a name="l01190"></a><a class="code" href="classqucs_1_1nasolver.html#a57b2d5c3694f01c3fa202b3069f250fc">01190</a> <span class="keywordtype">void</span> <a class="code" href="classqucs_1_1nasolver.html">nasolver&lt;nr_type_t&gt;::restorePreviousIteration</a> (<span class="keywordtype">void</span>)
<a name="l01191"></a>01191 {
<a name="l01192"></a>01192     <span class="keywordflow">if</span> (xprev != NULL) *<a class="code" href="parse__mdl_8y.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a> = *xprev;
<a name="l01193"></a>01193     <span class="keywordflow">if</span> (zprev != NULL) *z = *zprev;
<a name="l01194"></a>01194 }
<a name="l01195"></a>01195 
<a name="l01196"></a>01196 <span class="comment">/* The function restarts the NR iteration for each non-linear</span>
<a name="l01197"></a>01197 <span class="comment">   circuit. */</span>
<a name="l01198"></a>01198 <span class="keyword">template</span> &lt;<span class="keyword">class</span> nr_type_t&gt;
<a name="l01199"></a><a class="code" href="classqucs_1_1nasolver.html#af43b5667ac43e038df7dbc412af01dad">01199</a> <span class="keywordtype">void</span> <a class="code" href="classqucs_1_1nasolver.html">nasolver&lt;nr_type_t&gt;::restartNR</a> (<span class="keywordtype">void</span>)
<a name="l01200"></a>01200 {
<a name="l01201"></a>01201     <a class="code" href="classqucs_1_1circuit.html" title="base class for qucs circuit elements.">circuit</a> * root = subnet-&gt;getRoot ();
<a name="l01202"></a>01202     <span class="keywordflow">for</span> (<a class="code" href="classqucs_1_1circuit.html" title="base class for qucs circuit elements.">circuit</a> * <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a> = root; <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a> != NULL; <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a> = (<a class="code" href="classqucs_1_1circuit.html" title="base class for qucs circuit elements.">circuit</a> *) <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>-&gt;<a class="code" href="classqucs_1_1eqn_1_1node.html#ad2f8b4edb365f182a9c9eed4af7491fc">getNext</a> ())
<a name="l01203"></a>01203     {
<a name="l01204"></a>01204         <span class="keywordflow">if</span> (<a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>-&gt;isNonLinear ()) <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>-&gt;restartDC ();
<a name="l01205"></a>01205     }
<a name="l01206"></a>01206 }
<a name="l01207"></a>01207 
<a name="l01208"></a>01208 <span class="comment">/* This function goes through solution (the x vector) and saves the</span>
<a name="l01209"></a>01209 <span class="comment">   node voltages of the last iteration into each non-linear</span>
<a name="l01210"></a>01210 <span class="comment">   circuit. */</span>
<a name="l01211"></a>01211 <span class="keyword">template</span> &lt;<span class="keyword">class</span> nr_type_t&gt;
<a name="l01212"></a><a class="code" href="classqucs_1_1nasolver.html#ac998a78c46b7f410602165ec43b7729a">01212</a> <span class="keywordtype">void</span> <a class="code" href="classqucs_1_1nasolver.html">nasolver&lt;nr_type_t&gt;::saveNodeVoltages</a> (<span class="keywordtype">void</span>)
<a name="l01213"></a>01213 {
<a name="l01214"></a>01214     <span class="keywordtype">int</span> <a class="code" href="equation_8cpp.html#a540f72cb9bcf86a19e3bbc259b9ec3e0">N</a> = countNodes ();
<a name="l01215"></a>01215     <span class="keyword">struct </span><a class="code" href="structqucs_1_1nodelist__t.html">nodelist_t</a> * <a class="code" href="parse__mdl_8y.html#aecba4cab5e52994730d1e21424997b33">n</a>;
<a name="l01216"></a>01216     <span class="comment">// save all nodes except reference node</span>
<a name="l01217"></a>01217     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a> = 0; <a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a> &lt; <a class="code" href="equation_8cpp.html#a540f72cb9bcf86a19e3bbc259b9ec3e0">N</a>; <a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>++)
<a name="l01218"></a>01218     {
<a name="l01219"></a>01219         n = nlist-&gt;getNode (<a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>);
<a name="l01220"></a>01220         <span class="comment">/* for (int i = 0; i &lt; n-&gt;size(); i++)*/</span>
<a name="l01221"></a>01221         <span class="keywordflow">for</span>(<span class="keyword">auto</span> &amp;currentn: *n)
<a name="l01222"></a>01222         {
<a name="l01223"></a>01223           currentn-&gt;getCircuit()-&gt;setV (currentn-&gt;getPort (), <a class="code" href="parse__mdl_8y.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>-&gt;get (<a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>));
<a name="l01224"></a>01224         }
<a name="l01225"></a>01225     }
<a name="l01226"></a>01226     <span class="comment">// save reference node</span>
<a name="l01227"></a>01227     n = nlist-&gt;getNode (-1);
<a name="l01228"></a>01228     <span class="keywordflow">for</span>(<span class="keyword">auto</span> &amp;currentn: *n)
<a name="l01229"></a>01229       currentn-&gt;getCircuit()-&gt;setV (currentn-&gt;getPort (), 0.0);
<a name="l01230"></a>01230 }
<a name="l01231"></a>01231 
<a name="l01232"></a>01232 <span class="comment">/* This function goes through solution (the x vector) and saves the</span>
<a name="l01233"></a>01233 <span class="comment">   branch currents through the voltage sources of the last iteration</span>
<a name="l01234"></a>01234 <span class="comment">   into each circuit. */</span>
<a name="l01235"></a>01235 <span class="keyword">template</span> &lt;<span class="keyword">class</span> nr_type_t&gt;
<a name="l01236"></a><a class="code" href="classqucs_1_1nasolver.html#aa1b2da67a7dacf024bdae6073bc631ff">01236</a> <span class="keywordtype">void</span> <a class="code" href="classqucs_1_1nasolver.html">nasolver&lt;nr_type_t&gt;::saveBranchCurrents</a> (<span class="keywordtype">void</span>)
<a name="l01237"></a>01237 {
<a name="l01238"></a>01238     <span class="keywordtype">int</span> <a class="code" href="equation_8cpp.html#a540f72cb9bcf86a19e3bbc259b9ec3e0">N</a> = countNodes ();
<a name="l01239"></a>01239     <span class="keywordtype">int</span> <a class="code" href="evaluate_8cpp.html#a92592142cb41364b6fe6ef9cc1a16dbd">M</a> = countVoltageSources ();
<a name="l01240"></a>01240     <a class="code" href="classqucs_1_1circuit.html" title="base class for qucs circuit elements.">circuit</a> * vs;
<a name="l01241"></a>01241     <span class="comment">// save all branch currents of voltage sources</span>
<a name="l01242"></a>01242     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a> = 0; <a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a> &lt; <a class="code" href="evaluate_8cpp.html#a92592142cb41364b6fe6ef9cc1a16dbd">M</a>; <a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>++)
<a name="l01243"></a>01243     {
<a name="l01244"></a>01244         vs = findVoltageSource (<a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>);
<a name="l01245"></a>01245         vs-&gt;<a class="code" href="classqucs_1_1circuit.html#a89cd7508ccf7ffb8765b5ccbd5f3a1a8">setJ</a> (<a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>, <a class="code" href="parse__mdl_8y.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>-&gt;get (<a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a> + N));
<a name="l01246"></a>01246     }
<a name="l01247"></a>01247 }
<a name="l01248"></a>01248 
<a name="l01249"></a>01249 <span class="comment">// The function saves the solution vector into each circuit.</span>
<a name="l01250"></a>01250 <span class="keyword">template</span> &lt;<span class="keyword">class</span> nr_type_t&gt;
<a name="l01251"></a><a class="code" href="classqucs_1_1nasolver.html#a36a9a4b447ac6d6b73b32b8200ff30d2">01251</a> <span class="keywordtype">void</span> <a class="code" href="classqucs_1_1nasolver.html">nasolver&lt;nr_type_t&gt;::saveSolution</a> (<span class="keywordtype">void</span>)
<a name="l01252"></a>01252 {
<a name="l01253"></a>01253     saveNodeVoltages ();
<a name="l01254"></a>01254     saveBranchCurrents ();
<a name="l01255"></a>01255 }
<a name="l01256"></a>01256 
<a name="l01257"></a>01257 <span class="comment">// This function stores the solution (node voltages and branch currents).</span>
<a name="l01258"></a>01258 <span class="keyword">template</span> &lt;<span class="keyword">class</span> nr_type_t&gt;
<a name="l01259"></a><a class="code" href="classqucs_1_1nasolver.html#a27ff2d4b11b727f5091bd3a734f79ebb">01259</a> <span class="keywordtype">void</span> <a class="code" href="classqucs_1_1nasolver.html">nasolver&lt;nr_type_t&gt;::storeSolution</a> (<span class="keywordtype">void</span>)
<a name="l01260"></a>01260 {
<a name="l01261"></a>01261     <span class="comment">// cleanup solution previously</span>
<a name="l01262"></a>01262     solution.clear ();
<a name="l01263"></a>01263     <span class="keywordtype">int</span> <a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>;
<a name="l01264"></a>01264     <span class="keywordtype">int</span> <a class="code" href="equation_8cpp.html#a540f72cb9bcf86a19e3bbc259b9ec3e0">N</a> = countNodes ();
<a name="l01265"></a>01265     <span class="keywordtype">int</span> <a class="code" href="evaluate_8cpp.html#a92592142cb41364b6fe6ef9cc1a16dbd">M</a> = countVoltageSources ();
<a name="l01266"></a>01266     <span class="comment">// store all nodes except reference node</span>
<a name="l01267"></a>01267     <span class="keywordflow">for</span> (r = 0; r &lt; <a class="code" href="equation_8cpp.html#a540f72cb9bcf86a19e3bbc259b9ec3e0">N</a>; r++)
<a name="l01268"></a>01268     {
<a name="l01269"></a>01269         <span class="keyword">struct </span><a class="code" href="structqucs_1_1nodelist__t.html">nodelist_t</a> * <a class="code" href="parse__mdl_8y.html#aecba4cab5e52994730d1e21424997b33">n</a> = nlist-&gt;getNode (r);
<a name="l01270"></a>01270         nr_type_t gr = <a class="code" href="parse__mdl_8y.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>-&gt;get (r);
<a name="l01271"></a>01271         qucs::naentry&lt;nr_type_t&gt; entry(gr, 0);
<a name="l01272"></a>01272         solution.insert({{n-&gt;<a class="code" href="structqucs_1_1nodelist__t.html#a77b43c75dca945562a4b5d070d0f5510">name</a>, entry }});
<a name="l01273"></a>01273     }
<a name="l01274"></a>01274     <span class="comment">// store all branch currents of voltage sources</span>
<a name="l01275"></a>01275     <span class="keywordflow">for</span> (r = 0; r &lt; <a class="code" href="evaluate_8cpp.html#a92592142cb41364b6fe6ef9cc1a16dbd">M</a>; r++)
<a name="l01276"></a>01276     {
<a name="l01277"></a>01277         <a class="code" href="classqucs_1_1circuit.html" title="base class for qucs circuit elements.">circuit</a> * vs = findVoltageSource (r);
<a name="l01278"></a>01278         <span class="keywordtype">int</span> vn = r - vs-&gt;<a class="code" href="classqucs_1_1circuit.html#a393ca06fd0735f88c9cd98e82a67a074">getVoltageSource</a> () + 1;
<a name="l01279"></a>01279         nr_type_t xg = <a class="code" href="parse__mdl_8y.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>-&gt;get (r + N);
<a name="l01280"></a>01280         qucs::naentry&lt;nr_type_t&gt; entry(xg, vn);
<a name="l01281"></a>01281         solution.insert({{vs-&gt;<a class="code" href="classqucs_1_1object.html#a3134f6d4b6abda0fb40ac2a9fb4344cc" title="Get the name of the object.">getName</a> (), entry}});
<a name="l01282"></a>01282     }
<a name="l01283"></a>01283 }
<a name="l01284"></a>01284 
<a name="l01285"></a>01285 <span class="comment">// This function recalls the solution (node voltages and branch currents).</span>
<a name="l01286"></a>01286 <span class="keyword">template</span> &lt;<span class="keyword">class</span> nr_type_t&gt;
<a name="l01287"></a><a class="code" href="classqucs_1_1nasolver.html#a62657c830d9adfd5e818558c18e5f4d6">01287</a> <span class="keywordtype">void</span> <a class="code" href="classqucs_1_1nasolver.html">nasolver&lt;nr_type_t&gt;::recallSolution</a> (<span class="keywordtype">void</span>)
<a name="l01288"></a>01288 {
<a name="l01289"></a>01289     <span class="keywordtype">int</span> <a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>;
<a name="l01290"></a>01290     <span class="keywordtype">int</span> <a class="code" href="equation_8cpp.html#a540f72cb9bcf86a19e3bbc259b9ec3e0">N</a> = countNodes ();
<a name="l01291"></a>01291     <span class="keywordtype">int</span> <a class="code" href="evaluate_8cpp.html#a92592142cb41364b6fe6ef9cc1a16dbd">M</a> = countVoltageSources ();
<a name="l01292"></a>01292     <span class="comment">// store all nodes except reference node</span>
<a name="l01293"></a>01293     <span class="keywordflow">for</span> (r = 0; r &lt; <a class="code" href="equation_8cpp.html#a540f72cb9bcf86a19e3bbc259b9ec3e0">N</a>; r++)
<a name="l01294"></a>01294     {
<a name="l01295"></a>01295         <span class="keyword">struct </span><a class="code" href="structqucs_1_1nodelist__t.html">nodelist_t</a> * <a class="code" href="parse__mdl_8y.html#aecba4cab5e52994730d1e21424997b33">n</a> = nlist-&gt;getNode (r);
<a name="l01296"></a>01296         <span class="keyword">auto</span> na = solution.find(n-&gt;<a class="code" href="structqucs_1_1nodelist__t.html#a77b43c75dca945562a4b5d070d0f5510">name</a>);
<a name="l01297"></a>01297         <span class="keywordflow">if</span> (na != solution.end())
<a name="l01298"></a>01298           <span class="keywordflow">if</span> ((*na).second.current == 0)
<a name="l01299"></a>01299             <a class="code" href="parse__mdl_8y.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>-&gt;set (r, (*na).second.value);
<a name="l01300"></a>01300     }
<a name="l01301"></a>01301     <span class="comment">// store all branch currents of voltage sources</span>
<a name="l01302"></a>01302     <span class="keywordflow">for</span> (r = 0; r &lt; <a class="code" href="evaluate_8cpp.html#a92592142cb41364b6fe6ef9cc1a16dbd">M</a>; r++)
<a name="l01303"></a>01303     {
<a name="l01304"></a>01304         <a class="code" href="classqucs_1_1circuit.html" title="base class for qucs circuit elements.">circuit</a> * vs = findVoltageSource (r);
<a name="l01305"></a>01305         <span class="keywordtype">int</span> vn = r - vs-&gt;<a class="code" href="classqucs_1_1circuit.html#a393ca06fd0735f88c9cd98e82a67a074">getVoltageSource</a> () + 1;
<a name="l01306"></a>01306         <span class="keyword">auto</span> na = solution.find(vs-&gt;<a class="code" href="classqucs_1_1object.html#a3134f6d4b6abda0fb40ac2a9fb4344cc" title="Get the name of the object.">getName</a> ());
<a name="l01307"></a>01307         <span class="keywordflow">if</span> (na != solution.end())
<a name="l01308"></a>01308           <span class="keywordflow">if</span> ((*na).second.current == vn)
<a name="l01309"></a>01309             <a class="code" href="parse__mdl_8y.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>-&gt;set (r + N, (*na).second.value);
<a name="l01310"></a>01310     }
<a name="l01311"></a>01311 }
<a name="l01312"></a>01312 
<a name="l01313"></a>01313 <span class="comment">/* This function saves the results of a single solve() functionality</span>
<a name="l01314"></a>01314 <span class="comment">   into the output dataset. */</span>
<a name="l01315"></a>01315 <span class="keyword">template</span> &lt;<span class="keyword">class</span> nr_type_t&gt;
<a name="l01316"></a><a class="code" href="classqucs_1_1nasolver.html#a45e8941aa74dec4799210aa4072d31cc">01316</a> <span class="keywordtype">void</span> <a class="code" href="classqucs_1_1nasolver.html">nasolver&lt;nr_type_t&gt;::saveResults</a> (<span class="keyword">const</span> <a class="code" href="namespacetesting_1_1internal.html#a5ca8a348395a6145775c1a2334e21889">std::string</a> &amp;volts, <span class="keyword">const</span> <a class="code" href="namespacetesting_1_1internal.html#a5ca8a348395a6145775c1a2334e21889">std::string</a> &amp;amps,
<a name="l01317"></a>01317                                        <span class="keywordtype">int</span> saveOPs, qucs::vector * f)
<a name="l01318"></a>01318 {
<a name="l01319"></a>01319     <span class="keywordtype">int</span> <a class="code" href="equation_8cpp.html#a540f72cb9bcf86a19e3bbc259b9ec3e0">N</a> = countNodes ();
<a name="l01320"></a>01320     <span class="keywordtype">int</span> <a class="code" href="evaluate_8cpp.html#a92592142cb41364b6fe6ef9cc1a16dbd">M</a> = countVoltageSources ();
<a name="l01321"></a>01321 
<a name="l01322"></a>01322     <span class="comment">// add node voltage variables</span>
<a name="l01323"></a>01323     <span class="keywordflow">if</span> (!volts.empty())
<a name="l01324"></a>01324     {
<a name="l01325"></a>01325         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a> = 0; <a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a> &lt; <a class="code" href="equation_8cpp.html#a540f72cb9bcf86a19e3bbc259b9ec3e0">N</a>; <a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>++)
<a name="l01326"></a>01326         {
<a name="l01327"></a>01327           <a class="code" href="namespacetesting_1_1internal.html#a5ca8a348395a6145775c1a2334e21889">std::string</a> <a class="code" href="parse__mdl_8y.html#aecba4cab5e52994730d1e21424997b33">n</a> = createV (<a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>, volts, saveOPs);
<a name="l01328"></a>01328           <span class="keywordflow">if</span>(!n.empty())
<a name="l01329"></a>01329             {
<a name="l01330"></a>01330                 saveVariable (n, <a class="code" href="parse__mdl_8y.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>-&gt;get (<a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>), f);
<a name="l01331"></a>01331             }
<a name="l01332"></a>01332         }
<a name="l01333"></a>01333     }
<a name="l01334"></a>01334 
<a name="l01335"></a>01335     <span class="comment">// add branch current variables</span>
<a name="l01336"></a>01336     <span class="keywordflow">if</span> (!amps.empty())
<a name="l01337"></a>01337     {
<a name="l01338"></a>01338         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a> = 0; <a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a> &lt; <a class="code" href="evaluate_8cpp.html#a92592142cb41364b6fe6ef9cc1a16dbd">M</a>; <a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>++)
<a name="l01339"></a>01339         {
<a name="l01340"></a>01340           <a class="code" href="namespacetesting_1_1internal.html#a5ca8a348395a6145775c1a2334e21889">std::string</a> <a class="code" href="parse__mdl_8y.html#aecba4cab5e52994730d1e21424997b33">n</a> = createI (<a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>, amps, saveOPs);
<a name="l01341"></a>01341           <span class="keywordflow">if</span> (!n.empty())
<a name="l01342"></a>01342             {
<a name="l01343"></a>01343                 saveVariable (n, <a class="code" href="parse__mdl_8y.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>-&gt;get (<a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a> + N), f);
<a name="l01344"></a>01344             }
<a name="l01345"></a>01345         }
<a name="l01346"></a>01346     }
<a name="l01347"></a>01347 
<a name="l01348"></a>01348     <span class="comment">// add voltage probe data</span>
<a name="l01349"></a>01349     <span class="keywordflow">if</span> (!volts.empty())
<a name="l01350"></a>01350     {
<a name="l01351"></a>01351         <a class="code" href="classqucs_1_1circuit.html" title="base class for qucs circuit elements.">circuit</a> * root = subnet-&gt;getRoot ();
<a name="l01352"></a>01352         <span class="keywordflow">for</span> (<a class="code" href="classqucs_1_1circuit.html" title="base class for qucs circuit elements.">circuit</a> * <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a> = root; <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a> != NULL; <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a> = (<a class="code" href="classqucs_1_1circuit.html" title="base class for qucs circuit elements.">circuit</a> *) <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>-&gt;<a class="code" href="classqucs_1_1eqn_1_1node.html#ad2f8b4edb365f182a9c9eed4af7491fc">getNext</a> ())
<a name="l01353"></a>01353         {
<a name="l01354"></a>01354             <span class="keywordflow">if</span> (!<a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>-&gt;isProbe ()) <span class="keywordflow">continue</span>;
<a name="l01355"></a>01355             <span class="keywordflow">if</span> (!<a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>-&gt;getSubcircuit().empty() &amp;&amp; !(saveOPs &amp; <a class="code" href="analysis_8h.html#af16d225d729cd6e3183261ab324d814b">SAVE_ALL</a>)) <span class="keywordflow">continue</span>;
<a name="l01356"></a>01356             <span class="keywordflow">if</span> (volts != <span class="stringliteral">&quot;vn&quot;</span>)
<a name="l01357"></a>01357                 <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>-&gt;saveOperatingPoints ();          
<a name="l01358"></a>01358             <a class="code" href="namespacetesting_1_1internal.html#a5ca8a348395a6145775c1a2334e21889">std::string</a> <a class="code" href="parse__mdl_8y.html#aecba4cab5e52994730d1e21424997b33">n</a> = createOP (<a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>-&gt;getName (), volts);
<a name="l01359"></a>01359             saveVariable (n, <a class="code" href="complex_8h.html#a7ad1a12245ad87a9d81d6bcc18afacae">nr_complex_t</a> (<a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>-&gt;getOperatingPoint (<span class="stringliteral">&quot;Vr&quot;</span>),
<a name="l01360"></a>01360                                    <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>-&gt;getOperatingPoint (<span class="stringliteral">&quot;Vi&quot;</span>)), f);
<a name="l01361"></a>01361         }
<a name="l01362"></a>01362     }
<a name="l01363"></a>01363 
<a name="l01364"></a>01364     <span class="comment">// save operating points of non-linear circuits if requested</span>
<a name="l01365"></a>01365     <span class="keywordflow">if</span> (saveOPs &amp; <a class="code" href="analysis_8h.html#a136808d349e47fd30a0eb5e2984adeee">SAVE_OPS</a>)
<a name="l01366"></a>01366     {
<a name="l01367"></a>01367         <a class="code" href="classqucs_1_1circuit.html" title="base class for qucs circuit elements.">circuit</a> * root = subnet-&gt;getRoot ();
<a name="l01368"></a>01368         <span class="keywordflow">for</span> (<a class="code" href="classqucs_1_1circuit.html" title="base class for qucs circuit elements.">circuit</a> * <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a> = root; <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a> != NULL; <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a> = (<a class="code" href="classqucs_1_1circuit.html" title="base class for qucs circuit elements.">circuit</a> *) <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>-&gt;<a class="code" href="classqucs_1_1eqn_1_1node.html#ad2f8b4edb365f182a9c9eed4af7491fc">getNext</a> ())
<a name="l01369"></a>01369         {
<a name="l01370"></a>01370             <span class="keywordflow">if</span> (!<a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>-&gt;isNonLinear ()) <span class="keywordflow">continue</span>;
<a name="l01371"></a>01371             <span class="keywordflow">if</span> (!<a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>-&gt;getSubcircuit ().empty() &amp;&amp; !(saveOPs &amp; <a class="code" href="analysis_8h.html#af16d225d729cd6e3183261ab324d814b">SAVE_ALL</a>)) <span class="keywordflow">continue</span>;
<a name="l01372"></a>01372             <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>-&gt;calcOperatingPoints ();
<a name="l01373"></a>01373             <span class="keywordflow">for</span> (<span class="keyword">auto</span> ops: <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>-&gt;getOperatingPoints ())
<a name="l01374"></a>01374             {
<a name="l01375"></a>01375                 <a class="code" href="structqucs.html#a5cf184620dc537d2fa681cd8ef499c27">operatingpoint</a> &amp;p = ops.second;
<a name="l01376"></a>01376                 <a class="code" href="namespacetesting_1_1internal.html#a5ca8a348395a6145775c1a2334e21889">std::string</a> <a class="code" href="parse__mdl_8y.html#aecba4cab5e52994730d1e21424997b33">n</a> = createOP (<a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>-&gt;getName (), p.getName ());
<a name="l01377"></a>01377                 saveVariable (n, p.getValue (), f);
<a name="l01378"></a>01378             }
<a name="l01379"></a>01379         }
<a name="l01380"></a>01380     }
<a name="l01381"></a>01381 }
<a name="l01382"></a>01382 
<a name="l01383"></a>01383 <span class="comment">/* Create an appropriate variable name for operating points.  The</span>
<a name="l01384"></a>01384 <span class="comment">   caller is responsible to free() the returned string. */</span>
<a name="l01385"></a>01385 <span class="keyword">template</span> &lt;<span class="keyword">class</span> nr_type_t&gt;
<a name="l01386"></a><a class="code" href="classqucs_1_1nasolver.html#af04d0a96ec03713b976aacac341360a7">01386</a> <a class="code" href="namespacetesting_1_1internal.html#a5ca8a348395a6145775c1a2334e21889">std::string</a> <a class="code" href="classqucs_1_1nasolver.html">nasolver&lt;nr_type_t&gt;::createOP</a> (<span class="keyword">const</span> <a class="code" href="namespacetesting_1_1internal.html#a5ca8a348395a6145775c1a2334e21889">std::string</a> &amp;<a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>, <span class="keyword">const</span> <a class="code" href="namespacetesting_1_1internal.html#a5ca8a348395a6145775c1a2334e21889">std::string</a> &amp;<a class="code" href="parse__mdl_8y.html#aecba4cab5e52994730d1e21424997b33">n</a>)
<a name="l01387"></a>01387 {
<a name="l01388"></a>01388     <span class="keywordflow">return</span> c+<span class="stringliteral">&quot;.&quot;</span>+<a class="code" href="parse__mdl_8y.html#aecba4cab5e52994730d1e21424997b33">n</a>;
<a name="l01389"></a>01389 }
<a name="l01390"></a>01390 
<a name="l01391"></a>01391 <span class="comment">/* Creates an appropriate variable name for voltages.  The caller is</span>
<a name="l01392"></a>01392 <span class="comment">   responsible to free() the returned string. */</span>
<a name="l01393"></a>01393 <span class="keyword">template</span> &lt;<span class="keyword">class</span> nr_type_t&gt;
<a name="l01394"></a><a class="code" href="classqucs_1_1nasolver.html#a782d40d12f44ad9b66889f1659ee6bfe">01394</a> <a class="code" href="namespacetesting_1_1internal.html#a5ca8a348395a6145775c1a2334e21889">std::string</a> <a class="code" href="classqucs_1_1nasolver.html">nasolver&lt;nr_type_t&gt;::createV</a> (<span class="keywordtype">int</span> <a class="code" href="parse__mdl_8y.html#aecba4cab5e52994730d1e21424997b33">n</a>, <span class="keyword">const</span> <a class="code" href="namespacetesting_1_1internal.html#a5ca8a348395a6145775c1a2334e21889">std::string</a> &amp;volts, <span class="keywordtype">int</span> saveOPs)
<a name="l01395"></a>01395 {
<a name="l01396"></a>01396     <span class="keywordflow">if</span> (nlist-&gt;isInternal (n))
<a name="l01397"></a>01397       <span class="keywordflow">return</span> <a class="code" href="namespacetesting_1_1internal.html#a5ca8a348395a6145775c1a2334e21889">std::string</a>();
<a name="l01398"></a>01398     <a class="code" href="namespacetesting_1_1internal.html#a5ca8a348395a6145775c1a2334e21889">std::string</a> <a class="code" href="classqucs_1_1node.html">node</a> = nlist-&gt;get (n);
<a name="l01399"></a>01399     <span class="keywordflow">if</span>(node.find(<span class="charliteral">&#39;.&#39;</span>)!=std::string::npos &amp;&amp; !(saveOPs &amp; <a class="code" href="analysis_8h.html#af16d225d729cd6e3183261ab324d814b">SAVE_ALL</a>))
<a name="l01400"></a>01400       <span class="keywordflow">return</span> <a class="code" href="namespacetesting_1_1internal.html#a5ca8a348395a6145775c1a2334e21889">std::string</a>();
<a name="l01401"></a>01401     <a class="code" href="namespacetesting_1_1internal.html#a5ca8a348395a6145775c1a2334e21889">std::string</a> ret = node+<span class="stringliteral">&quot;.&quot;</span>+volts;
<a name="l01402"></a>01402     <span class="keywordflow">return</span> ret;
<a name="l01403"></a>01403 }
<a name="l01404"></a>01404 
<a name="l01405"></a>01405 <span class="comment">/* Create an appropriate variable name for currents.  The caller is</span>
<a name="l01406"></a>01406 <span class="comment">   responsible to free() the returned string. */</span>
<a name="l01407"></a>01407 <span class="keyword">template</span> &lt;<span class="keyword">class</span> nr_type_t&gt;
<a name="l01408"></a><a class="code" href="classqucs_1_1nasolver.html#a958a9fb65bb154b7e6f2881f3aefa22d">01408</a> <a class="code" href="namespacetesting_1_1internal.html#a5ca8a348395a6145775c1a2334e21889">std::string</a> <a class="code" href="classqucs_1_1nasolver.html">nasolver&lt;nr_type_t&gt;::createI</a> (<span class="keywordtype">int</span> <a class="code" href="parse__mdl_8y.html#aecba4cab5e52994730d1e21424997b33">n</a>, <span class="keyword">const</span> <a class="code" href="namespacetesting_1_1internal.html#a5ca8a348395a6145775c1a2334e21889">std::string</a> &amp;amps, <span class="keywordtype">int</span> saveOPs)
<a name="l01409"></a>01409 {
<a name="l01410"></a>01410     <a class="code" href="classqucs_1_1circuit.html" title="base class for qucs circuit elements.">circuit</a> * vs = findVoltageSource (n);
<a name="l01411"></a>01411 
<a name="l01412"></a>01412     <span class="comment">// don&#39;t output internal (helper) voltage sources</span>
<a name="l01413"></a>01413     <span class="keywordflow">if</span> (vs-&gt;<a class="code" href="classqucs_1_1circuit.html#a47571bb02f1a91f15d2f5113dc218394">isInternalVoltageSource</a> ())
<a name="l01414"></a>01414       <span class="keywordflow">return</span> <a class="code" href="namespacetesting_1_1internal.html#a5ca8a348395a6145775c1a2334e21889">std::string</a>();
<a name="l01415"></a>01415 
<a name="l01416"></a>01416     <span class="comment">/* save only current through real voltage sources and explicit</span>
<a name="l01417"></a>01417 <span class="comment">       current probes */</span>
<a name="l01418"></a>01418     <span class="keywordflow">if</span> (!vs-&gt;<a class="code" href="classqucs_1_1circuit.html#afeaa2dee98525fc02dd5969ec28cdb46">isVSource</a> () &amp;&amp; !(saveOPs &amp; <a class="code" href="analysis_8h.html#a136808d349e47fd30a0eb5e2984adeee">SAVE_OPS</a>))
<a name="l01419"></a>01419       <span class="keywordflow">return</span> <a class="code" href="namespacetesting_1_1internal.html#a5ca8a348395a6145775c1a2334e21889">std::string</a>();
<a name="l01420"></a>01420 
<a name="l01421"></a>01421     <span class="comment">// don&#39;t output subcircuit components if not requested</span>
<a name="l01422"></a>01422     <span class="keywordflow">if</span> (!vs-&gt;<a class="code" href="classqucs_1_1circuit.html#ab6465479d9cff61bcfe7869b678790b7">getSubcircuit</a> ().empty() &amp;&amp; !(saveOPs &amp; <a class="code" href="analysis_8h.html#af16d225d729cd6e3183261ab324d814b">SAVE_ALL</a>))
<a name="l01423"></a>01423       <span class="keywordflow">return</span> <a class="code" href="namespacetesting_1_1internal.html#a5ca8a348395a6145775c1a2334e21889">std::string</a>();
<a name="l01424"></a>01424 
<a name="l01425"></a>01425     <span class="comment">// create appropriate current name for single/multiple voltage sources</span>
<a name="l01426"></a>01426     <a class="code" href="namespacetesting_1_1internal.html#a5ca8a348395a6145775c1a2334e21889">std::string</a> <a class="code" href="parse__mdl_8y.html#a9936388dcd0f5b4388f9863ec29f17e4">name</a> = vs-&gt;<a class="code" href="classqucs_1_1object.html#a3134f6d4b6abda0fb40ac2a9fb4344cc" title="Get the name of the object.">getName</a> ();
<a name="l01427"></a>01427     <span class="keywordflow">if</span> (vs-&gt;<a class="code" href="classqucs_1_1circuit.html#a4665cb89cb115ad292275212a9e47144">getVoltageSources</a> () &gt; 1)
<a name="l01428"></a>01428       <span class="keywordflow">return</span> name+<span class="stringliteral">&quot;.&quot;</span>+amps+std::to_string(n - vs-&gt;<a class="code" href="classqucs_1_1circuit.html#a393ca06fd0735f88c9cd98e82a67a074">getVoltageSource</a> () + 1);
<a name="l01429"></a>01429     <span class="keywordflow">else</span>
<a name="l01430"></a>01430       <span class="keywordflow">return</span> name+<span class="stringliteral">&quot;.&quot;</span>+amps;
<a name="l01431"></a>01431 }
<a name="l01432"></a>01432 
<a name="l01433"></a>01433 
<a name="l01434"></a>01434 <span class="comment">/* Alternaive to countNodes () */</span>
<a name="l01435"></a>01435 <span class="keyword">template</span> &lt;<span class="keyword">class</span> nr_type_t&gt;
<a name="l01436"></a><a class="code" href="classqucs_1_1nasolver.html#a8c01253819b5eaf3b3ff58706658dfc5">01436</a> <span class="keywordtype">int</span> <a class="code" href="m__trsolver__interface__mex_8cpp.html#a40e919cf3a5c6bee776701ccfd36738fa74a8b90e50759dee5ac4b4543f4d992c">nasolver&lt;nr_type_t&gt;::getN</a>()
<a name="l01437"></a>01437 {
<a name="l01438"></a>01438     <span class="keywordflow">return</span> countNodes ();
<a name="l01439"></a>01439 }
<a name="l01440"></a>01440 
<a name="l01441"></a>01441 <span class="comment">/* Alternative to countVoltageSources () */</span>
<a name="l01442"></a>01442 <span class="keyword">template</span> &lt;<span class="keyword">class</span> nr_type_t&gt;
<a name="l01443"></a><a class="code" href="classqucs_1_1nasolver.html#a4bb228e8f23760447e52534bace637b9">01443</a> <span class="keywordtype">int</span> <a class="code" href="m__trsolver__interface__mex_8cpp.html#a40e919cf3a5c6bee776701ccfd36738fa720ed9916253f9c4a4580f2fe81ce2d1">nasolver&lt;nr_type_t&gt;::getM</a>()
<a name="l01444"></a>01444 {
<a name="l01445"></a>01445     <span class="keywordflow">return</span> countVoltageSources ();
<a name="l01446"></a>01446 }
<a name="l01447"></a>01447 
<a name="l01448"></a>01448 } <span class="comment">// namespace qucs</span>
</pre></div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Tue Jun 16 2015 20:07:28 for Qucs-core by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
