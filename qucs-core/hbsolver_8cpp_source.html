<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Qucs-core: hbsolver.cpp Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Qucs-core
   &#160;<span id="projectnumber">0.0.19</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">hbsolver.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<a href="hbsolver_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * hbsolver.cpp - harmonic balance solver class implementation</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> * Copyright (C) 2005, 2006, 2007, 2008 Stefan Jahn &lt;stefan@lkcc.org&gt;</span>
<a name="l00005"></a>00005 <span class="comment"> *</span>
<a name="l00006"></a>00006 <span class="comment"> * This is free software; you can redistribute it and/or modify</span>
<a name="l00007"></a>00007 <span class="comment"> * it under the terms of the GNU General Public License as published by</span>
<a name="l00008"></a>00008 <span class="comment"> * the Free Software Foundation; either version 2, or (at your option)</span>
<a name="l00009"></a>00009 <span class="comment"> * any later version.</span>
<a name="l00010"></a>00010 <span class="comment"> *</span>
<a name="l00011"></a>00011 <span class="comment"> * This software is distributed in the hope that it will be useful,</span>
<a name="l00012"></a>00012 <span class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00013"></a>00013 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00014"></a>00014 <span class="comment"> * GNU General Public License for more details.</span>
<a name="l00015"></a>00015 <span class="comment"> *</span>
<a name="l00016"></a>00016 <span class="comment"> * You should have received a copy of the GNU General Public License</span>
<a name="l00017"></a>00017 <span class="comment"> * along with this package; see the file COPYING.  If not, write to</span>
<a name="l00018"></a>00018 <span class="comment"> * the Free Software Foundation, Inc., 51 Franklin Street - Fifth Floor,</span>
<a name="l00019"></a>00019 <span class="comment"> * Boston, MA 02110-1301, USA.</span>
<a name="l00020"></a>00020 <span class="comment"> *</span>
<a name="l00021"></a>00021 <span class="comment"> * $Id$</span>
<a name="l00022"></a>00022 <span class="comment"> *</span>
<a name="l00023"></a>00023 <span class="comment"> */</span>
<a name="l00024"></a>00024 
<a name="l00025"></a>00025 <span class="preprocessor">#if HAVE_CONFIG_H</span>
<a name="l00026"></a>00026 <span class="preprocessor"></span><span class="preprocessor"># include &lt;<a class="code" href="config_8h.html">config.h</a>&gt;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#endif</span>
<a name="l00028"></a>00028 <span class="preprocessor"></span>
<a name="l00029"></a>00029 <span class="preprocessor">#include&lt;algorithm&gt;</span>
<a name="l00030"></a>00030 
<a name="l00031"></a>00031 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00032"></a>00032 
<a name="l00033"></a>00033 <span class="preprocessor">#include &quot;<a class="code" href="object_8h.html">object.h</a>&quot;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &quot;<a class="code" href="logging_8h.html">logging.h</a>&quot;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &quot;<a class="code" href="complex_8h.html">complex.h</a>&quot;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &quot;<a class="code" href="vector_8h.html">vector.h</a>&quot;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &quot;<a class="code" href="node_8h.html">node.h</a>&quot;</span>
<a name="l00038"></a>00038 <span class="preprocessor">#include &quot;<a class="code" href="circuit_8h.html" title="The circuit class header file.">circuit.h</a>&quot;</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &quot;<a class="code" href="component__id_8h.html">component_id.h</a>&quot;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#include &quot;<a class="code" href="net_8h.html">net.h</a>&quot;</span>
<a name="l00041"></a>00041 <span class="preprocessor">#include &quot;<a class="code" href="netdefs_8h.html">netdefs.h</a>&quot;</span>
<a name="l00042"></a>00042 <span class="preprocessor">#include &quot;<a class="code" href="strlist_8h.html">strlist.h</a>&quot;</span>
<a name="l00043"></a>00043 <span class="preprocessor">#include &quot;<a class="code" href="ptrlist_8h.html">ptrlist.h</a>&quot;</span>
<a name="l00044"></a>00044 <span class="preprocessor">#include &quot;<a class="code" href="tvector_8h.html">tvector.h</a>&quot;</span>
<a name="l00045"></a>00045 <span class="preprocessor">#include &quot;<a class="code" href="tmatrix_8h.html">tmatrix.h</a>&quot;</span>
<a name="l00046"></a>00046 <span class="preprocessor">#include &quot;<a class="code" href="eqnsys_8h.html">eqnsys.h</a>&quot;</span>
<a name="l00047"></a>00047 <span class="preprocessor">#include &quot;<a class="code" href="analysis_8h.html" title="The analysis class header file.">analysis.h</a>&quot;</span>
<a name="l00048"></a>00048 <span class="preprocessor">#include &quot;<a class="code" href="dataset_8h.html">dataset.h</a>&quot;</span>
<a name="l00049"></a>00049 <span class="preprocessor">#include &quot;<a class="code" href="fourier_8h.html">fourier.h</a>&quot;</span>
<a name="l00050"></a>00050 <span class="preprocessor">#include &quot;<a class="code" href="hbsolver_8h.html">hbsolver.h</a>&quot;</span>
<a name="l00051"></a>00051 
<a name="l00052"></a><a class="code" href="hbsolver_8cpp.html#a53b13b9a0384144dc019b2713b3dde73">00052</a> <span class="preprocessor">#define HB_DEBUG 0</span>
<a name="l00053"></a>00053 <span class="preprocessor"></span>
<a name="l00054"></a>00054 <span class="keyword">namespace </span><a class="code" href="structqucs.html">qucs</a> {
<a name="l00055"></a>00055 
<a name="l00056"></a>00056 <span class="keyword">using namespace </span>fourier;
<a name="l00057"></a>00057 
<a name="l00058"></a>00058 <span class="comment">// Constructor creates an unnamed instance of the hbsolver class.</span>
<a name="l00059"></a>00059 hbsolver::hbsolver () : analysis () {
<a name="l00060"></a>00060   <a class="code" href="parse__vcd_8y.html#ae0bd5e8ec17b2aad3338041991eb1056">type</a> = <a class="code" href="structqucs.html#add82670b369206f02d6378e495b91639a5d0c55eba8575b62c61762074abb1613">ANALYSIS_HBALANCE</a>;
<a name="l00061"></a>00061   frequency = 0;
<a name="l00062"></a>00062   nlnodes = lnnodes = banodes = nanodes = NULL;
<a name="l00063"></a>00063   Y = Z = <a class="code" href="eqndefined_8cpp.html#a70993d52766e31cb0157958a18aa499a">A</a> = NULL;
<a name="l00064"></a>00064   NA = YV = JQ = JG = JF = NULL;
<a name="l00065"></a>00065   OM = IR = QR = RH = IG = FQ = VS = VP = FV = IL = IN = IC = IS = NULL;
<a name="l00066"></a>00066   vs = <a class="code" href="parse__mdl_8y.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a> = NULL;
<a name="l00067"></a>00067   runs = 0;
<a name="l00068"></a>00068   ndfreqs = NULL;
<a name="l00069"></a>00069 }
<a name="l00070"></a>00070 
<a name="l00071"></a>00071 <span class="comment">// Constructor creates a named instance of the hbsolver class.</span>
<a name="l00072"></a><a class="code" href="structqucs_1_1hbsolver.html#a3a98a4c2c11954ac6d925e1ad9e0d0d2">00072</a> hbsolver::hbsolver (<span class="keywordtype">char</span> * <a class="code" href="parse__mdl_8y.html#aecba4cab5e52994730d1e21424997b33">n</a>) : analysis (n) {
<a name="l00073"></a>00073   <a class="code" href="parse__vcd_8y.html#ae0bd5e8ec17b2aad3338041991eb1056">type</a> = <a class="code" href="structqucs.html#add82670b369206f02d6378e495b91639a5d0c55eba8575b62c61762074abb1613">ANALYSIS_HBALANCE</a>;
<a name="l00074"></a>00074   <a class="code" href="structqucs_1_1hbsolver.html#a681f2cecfae53cb08ea15526d4ed5690">frequency</a> = 0;
<a name="l00075"></a>00075   <a class="code" href="structqucs_1_1hbsolver.html#a51aa849b5267050431300369bcfaf049">nlnodes</a> = <a class="code" href="structqucs_1_1hbsolver.html#a17124478f8fb6e6ba96079c54c678757">lnnodes</a> = <a class="code" href="structqucs_1_1hbsolver.html#a5973009c4dfafbeff4697162f88f4f34">banodes</a> = <a class="code" href="structqucs_1_1hbsolver.html#a99a9672b22fa8192e88bd9d42f33df2c">nanodes</a> = NULL;
<a name="l00076"></a>00076   <a class="code" href="structqucs_1_1hbsolver.html#a69e75cb505492894cfde2d5208303737">Y</a> = <a class="code" href="structqucs_1_1hbsolver.html#a91da5a9141b3bb040768f223e5a21151">Z</a> = <a class="code" href="eqndefined_8cpp.html#a70993d52766e31cb0157958a18aa499a">A</a> = NULL;
<a name="l00077"></a>00077   <a class="code" href="structqucs_1_1hbsolver.html#abc06a9b3b9937f57930d76ea08525f5a">NA</a> = <a class="code" href="structqucs_1_1hbsolver.html#ac238599ebe8e430f869caf31ed111948">YV</a> = <a class="code" href="structqucs_1_1hbsolver.html#a8f78a0d0d32862a3888a6843b3f2966b">JQ</a> = <a class="code" href="structqucs_1_1hbsolver.html#a5698ad8a45b509d7ddeb462c79db5f21">JG</a> = <a class="code" href="structqucs_1_1hbsolver.html#a711d89e16cf79e1cd0e57345df41ae07">JF</a> = NULL;
<a name="l00078"></a>00078   <a class="code" href="structqucs_1_1hbsolver.html#ad87d01959fe7d3ec88b7604f1aacf179">OM</a> = <a class="code" href="structqucs_1_1hbsolver.html#afce4c3bfa46a6686a08b6a3305f9a170">IR</a> = <a class="code" href="structqucs_1_1hbsolver.html#a09adefa8c3b70d3fe73d6af70dbe215e">QR</a> = <a class="code" href="structqucs_1_1hbsolver.html#a71e9ccead167a567568dfac8d8689458">RH</a> = <a class="code" href="structqucs_1_1hbsolver.html#ab0bcc268e9fbab39e9c6d32153123197">IG</a> = <a class="code" href="structqucs_1_1hbsolver.html#a0b80871809fdb9f6f567c6a2584de842">FQ</a> = <a class="code" href="structqucs_1_1hbsolver.html#a231f8c98cdebd4b573e6d709c69580b3">VS</a> = <a class="code" href="structqucs_1_1hbsolver.html#af9e7cfab20be6281aa6eb9628ed52d02">VP</a> = <a class="code" href="structqucs_1_1hbsolver.html#a10badce5dc94f030ac1f6575cf7ba406">FV</a> = <a class="code" href="structqucs_1_1hbsolver.html#addd48c2575d812527ff71b1471daca5c">IL</a> = <a class="code" href="structqucs_1_1hbsolver.html#ad986985a830c78b403d3d3c044d4d9ad">IN</a> = <a class="code" href="structqucs_1_1hbsolver.html#a2a2aa6c1327066794e59e61d426a7512">IC</a> = <a class="code" href="structqucs_1_1hbsolver.html#adc94b6d554c13874148da3b7f31a55f2">IS</a> = NULL;
<a name="l00079"></a>00079   <a class="code" href="structqucs_1_1hbsolver.html#ad5737f26614db9a9d3913c91d82ef932">vs</a> = <a class="code" href="parse__mdl_8y.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a> = NULL;
<a name="l00080"></a>00080   <a class="code" href="structqucs_1_1hbsolver.html#a99a99b6522d53ff5b639963993bb0318">runs</a> = 0;
<a name="l00081"></a>00081   <a class="code" href="structqucs_1_1hbsolver.html#a90566c59fc2e5886760661e66ff46032">ndfreqs</a> = NULL;
<a name="l00082"></a>00082 }
<a name="l00083"></a>00083 
<a name="l00084"></a>00084 <span class="comment">// Destructor deletes the hbsolver class object.</span>
<a name="l00085"></a><a class="code" href="structqucs_1_1hbsolver.html#a1971804d7dea0056d274363ad6cdad06">00085</a> hbsolver::~hbsolver () {
<a name="l00086"></a>00086   <span class="comment">// delete nodelists</span>
<a name="l00087"></a>00087   <span class="keywordflow">if</span> (nlnodes) <span class="keyword">delete</span> nlnodes;
<a name="l00088"></a>00088   <span class="keywordflow">if</span> (lnnodes) <span class="keyword">delete</span> lnnodes;
<a name="l00089"></a>00089   <span class="keywordflow">if</span> (banodes) <span class="keyword">delete</span> banodes;
<a name="l00090"></a>00090   <span class="keywordflow">if</span> (nanodes) <span class="keyword">delete</span> nanodes;
<a name="l00091"></a>00091 
<a name="l00092"></a>00092   <span class="comment">// delete temporary matrices</span>
<a name="l00093"></a>00093   <span class="keywordflow">if</span> (<a class="code" href="eqndefined_8cpp.html#a70993d52766e31cb0157958a18aa499a">A</a>) <span class="keyword">delete</span> <a class="code" href="eqndefined_8cpp.html#a70993d52766e31cb0157958a18aa499a">A</a>;
<a name="l00094"></a>00094   <span class="keywordflow">if</span> (Z) <span class="keyword">delete</span> Z;
<a name="l00095"></a>00095   <span class="keywordflow">if</span> (Y) <span class="keyword">delete</span> Y;
<a name="l00096"></a>00096 
<a name="l00097"></a>00097   <span class="comment">// delete matrices</span>
<a name="l00098"></a>00098   <span class="keywordflow">if</span> (NA) <span class="keyword">delete</span> NA;
<a name="l00099"></a>00099   <span class="keywordflow">if</span> (YV) <span class="keyword">delete</span> YV;
<a name="l00100"></a>00100   <span class="keywordflow">if</span> (JQ) <span class="keyword">delete</span> JQ;
<a name="l00101"></a>00101   <span class="keywordflow">if</span> (JG) <span class="keyword">delete</span> JG;
<a name="l00102"></a>00102   <span class="keywordflow">if</span> (JF) <span class="keyword">delete</span> JF;
<a name="l00103"></a>00103 
<a name="l00104"></a>00104   <span class="comment">// delete vectors</span>
<a name="l00105"></a>00105   <span class="keywordflow">if</span> (IC) <span class="keyword">delete</span> IC;
<a name="l00106"></a>00106   <span class="keywordflow">if</span> (IS) <span class="keyword">delete</span> IS;
<a name="l00107"></a>00107   <span class="keywordflow">if</span> (FV) <span class="keyword">delete</span> FV;
<a name="l00108"></a>00108   <span class="keywordflow">if</span> (IL) <span class="keyword">delete</span> IL;
<a name="l00109"></a>00109   <span class="keywordflow">if</span> (IN) <span class="keyword">delete</span> IN;
<a name="l00110"></a>00110   <span class="keywordflow">if</span> (IG) <span class="keyword">delete</span> IG;
<a name="l00111"></a>00111   <span class="keywordflow">if</span> (FQ) <span class="keyword">delete</span> FQ;
<a name="l00112"></a>00112   <span class="keywordflow">if</span> (VS) <span class="keyword">delete</span> VS;
<a name="l00113"></a>00113   <span class="keywordflow">if</span> (VP) <span class="keyword">delete</span> VP;
<a name="l00114"></a>00114   <span class="keywordflow">if</span> (vs) <span class="keyword">delete</span> vs;
<a name="l00115"></a>00115   <span class="keywordflow">if</span> (OM) <span class="keyword">delete</span> OM;
<a name="l00116"></a>00116   <span class="keywordflow">if</span> (IR) <span class="keyword">delete</span> IR;
<a name="l00117"></a>00117   <span class="keywordflow">if</span> (QR) <span class="keyword">delete</span> QR;
<a name="l00118"></a>00118   <span class="keywordflow">if</span> (RH) <span class="keyword">delete</span> RH;
<a name="l00119"></a>00119 
<a name="l00120"></a>00120   <span class="keywordflow">if</span> (<a class="code" href="parse__mdl_8y.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>) <span class="keyword">delete</span> <a class="code" href="parse__mdl_8y.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>;
<a name="l00121"></a>00121   <span class="keywordflow">if</span> (ndfreqs) <span class="keyword">delete</span>[] ndfreqs;
<a name="l00122"></a>00122 }
<a name="l00123"></a>00123 
<a name="l00124"></a>00124 <span class="comment">/* The copy constructor creates a new instance of the hbsolver class</span>
<a name="l00125"></a>00125 <span class="comment">   based on the given hbsolver object. */</span>
<a name="l00126"></a><a class="code" href="structqucs_1_1hbsolver.html#a5021e9286da150c5b360dc649b0b9089">00126</a> hbsolver::hbsolver (<a class="code" href="structqucs_1_1hbsolver.html">hbsolver</a> &amp; o) : analysis (o) {
<a name="l00127"></a>00127   <a class="code" href="structqucs_1_1hbsolver.html#a681f2cecfae53cb08ea15526d4ed5690">frequency</a> = o.<a class="code" href="structqucs_1_1hbsolver.html#a681f2cecfae53cb08ea15526d4ed5690">frequency</a>;
<a name="l00128"></a>00128   <a class="code" href="structqucs_1_1hbsolver.html#a66daf404a4556d7c2009b5bd82d13a09">negfreqs</a> = o.<a class="code" href="structqucs_1_1hbsolver.html#a66daf404a4556d7c2009b5bd82d13a09">negfreqs</a>;
<a name="l00129"></a>00129   <a class="code" href="structqucs_1_1hbsolver.html#ab64b50bb3fd689b1cb6c56f420f43da1">posfreqs</a> = o.<a class="code" href="structqucs_1_1hbsolver.html#ab64b50bb3fd689b1cb6c56f420f43da1">posfreqs</a>;
<a name="l00130"></a>00130   <a class="code" href="structqucs_1_1hbsolver.html#a51aa849b5267050431300369bcfaf049">nlnodes</a> = o.<a class="code" href="structqucs_1_1hbsolver.html#a51aa849b5267050431300369bcfaf049">nlnodes</a>;
<a name="l00131"></a>00131   <a class="code" href="structqucs_1_1hbsolver.html#a17124478f8fb6e6ba96079c54c678757">lnnodes</a> = o.<a class="code" href="structqucs_1_1hbsolver.html#a17124478f8fb6e6ba96079c54c678757">lnnodes</a>;
<a name="l00132"></a>00132   <a class="code" href="structqucs_1_1hbsolver.html#a5973009c4dfafbeff4697162f88f4f34">banodes</a> = o.<a class="code" href="structqucs_1_1hbsolver.html#a5973009c4dfafbeff4697162f88f4f34">banodes</a>;
<a name="l00133"></a>00133   <a class="code" href="structqucs_1_1hbsolver.html#a99a9672b22fa8192e88bd9d42f33df2c">nanodes</a> = o.<a class="code" href="structqucs_1_1hbsolver.html#a99a9672b22fa8192e88bd9d42f33df2c">nanodes</a>;
<a name="l00134"></a>00134   <a class="code" href="structqucs_1_1hbsolver.html#a69e75cb505492894cfde2d5208303737">Y</a> = <a class="code" href="structqucs_1_1hbsolver.html#a91da5a9141b3bb040768f223e5a21151">Z</a> = <a class="code" href="eqndefined_8cpp.html#a70993d52766e31cb0157958a18aa499a">A</a> = NULL;
<a name="l00135"></a>00135   <a class="code" href="structqucs_1_1hbsolver.html#abc06a9b3b9937f57930d76ea08525f5a">NA</a> = <a class="code" href="structqucs_1_1hbsolver.html#ac238599ebe8e430f869caf31ed111948">YV</a> = <a class="code" href="structqucs_1_1hbsolver.html#a8f78a0d0d32862a3888a6843b3f2966b">JQ</a> = <a class="code" href="structqucs_1_1hbsolver.html#a5698ad8a45b509d7ddeb462c79db5f21">JG</a> = <a class="code" href="structqucs_1_1hbsolver.html#a711d89e16cf79e1cd0e57345df41ae07">JF</a> = NULL;
<a name="l00136"></a>00136   <a class="code" href="structqucs_1_1hbsolver.html#ad87d01959fe7d3ec88b7604f1aacf179">OM</a> = <a class="code" href="structqucs_1_1hbsolver.html#afce4c3bfa46a6686a08b6a3305f9a170">IR</a> = <a class="code" href="structqucs_1_1hbsolver.html#a09adefa8c3b70d3fe73d6af70dbe215e">QR</a> = <a class="code" href="structqucs_1_1hbsolver.html#a71e9ccead167a567568dfac8d8689458">RH</a> = <a class="code" href="structqucs_1_1hbsolver.html#ab0bcc268e9fbab39e9c6d32153123197">IG</a> = <a class="code" href="structqucs_1_1hbsolver.html#a0b80871809fdb9f6f567c6a2584de842">FQ</a> = <a class="code" href="structqucs_1_1hbsolver.html#a231f8c98cdebd4b573e6d709c69580b3">VS</a> = <a class="code" href="structqucs_1_1hbsolver.html#af9e7cfab20be6281aa6eb9628ed52d02">VP</a> = <a class="code" href="structqucs_1_1hbsolver.html#a10badce5dc94f030ac1f6575cf7ba406">FV</a> = <a class="code" href="structqucs_1_1hbsolver.html#addd48c2575d812527ff71b1471daca5c">IL</a> = <a class="code" href="structqucs_1_1hbsolver.html#ad986985a830c78b403d3d3c044d4d9ad">IN</a> = <a class="code" href="structqucs_1_1hbsolver.html#a2a2aa6c1327066794e59e61d426a7512">IC</a> = <a class="code" href="structqucs_1_1hbsolver.html#adc94b6d554c13874148da3b7f31a55f2">IS</a> = NULL;
<a name="l00137"></a>00137   <a class="code" href="structqucs_1_1hbsolver.html#ad5737f26614db9a9d3913c91d82ef932">vs</a> = <a class="code" href="parse__mdl_8y.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a> = NULL;
<a name="l00138"></a>00138   <a class="code" href="structqucs_1_1hbsolver.html#a99a99b6522d53ff5b639963993bb0318">runs</a> = o.<a class="code" href="structqucs_1_1hbsolver.html#a99a99b6522d53ff5b639963993bb0318">runs</a>;
<a name="l00139"></a>00139   <a class="code" href="structqucs_1_1hbsolver.html#a90566c59fc2e5886760661e66ff46032">ndfreqs</a> = NULL;
<a name="l00140"></a>00140 }
<a name="l00141"></a>00141 
<a name="l00142"></a><a class="code" href="hbsolver_8cpp.html#a5375803daa109cf192e7fa011fc51358">00142</a> <span class="preprocessor">#define VS_(r) (*VS) (r)</span>
<a name="l00143"></a><a class="code" href="hbsolver_8cpp.html#aae67df46a02b4df8bf6f0222eef8e58a">00143</a> <span class="preprocessor"></span><span class="preprocessor">#define OM_(r) (*OM) (r)</span>
<a name="l00144"></a>00144 <span class="preprocessor"></span>
<a name="l00145"></a>00145 <span class="comment">/* This is the HB netlist solver.  It prepares the circuit list and</span>
<a name="l00146"></a>00146 <span class="comment">   solves it then. */</span>
<a name="l00147"></a><a class="code" href="structqucs_1_1hbsolver.html#af22f561bcc2c8efe8be6a6c736efbd3d">00147</a> <span class="keywordtype">int</span> hbsolver::solve (<span class="keywordtype">void</span>) {
<a name="l00148"></a>00148 
<a name="l00149"></a>00149   <span class="keywordtype">int</span> iterations = 0, done = 0;
<a name="l00150"></a>00150   <span class="keywordtype">int</span> MaxIterations = getPropertyInteger (<span class="stringliteral">&quot;MaxIter&quot;</span>);
<a name="l00151"></a>00151 
<a name="l00152"></a>00152   <span class="comment">// collect different parts of the circuit</span>
<a name="l00153"></a>00153   splitCircuits ();
<a name="l00154"></a>00154 
<a name="l00155"></a>00155   <span class="comment">// create frequency array</span>
<a name="l00156"></a>00156   collectFrequencies ();
<a name="l00157"></a>00157 
<a name="l00158"></a>00158   <span class="comment">// find interconnects between the linear and non-linear subcircuit</span>
<a name="l00159"></a>00159   getNodeLists ();
<a name="l00160"></a>00160 
<a name="l00161"></a>00161   <span class="comment">// prepares the linear part --&gt; 0 = IC + [YV] * VS</span>
<a name="l00162"></a>00162   prepareLinear ();
<a name="l00163"></a>00163 
<a name="l00164"></a>00164   runs++;
<a name="l00165"></a>00165   <a class="code" href="logging_8c.html#abe06a8732a47a291606edcfac5e5146e">logprint</a> (<a class="code" href="logging_8h.html#a9b52156aa5746cc612e2e3edea6d5dbd">LOG_STATUS</a>, <span class="stringliteral">&quot;NOTIFY: %s: solving for %d frequencies\n&quot;</span>,
<a name="l00166"></a>00166             getName (), lnfreqs);
<a name="l00167"></a>00167 
<a name="l00168"></a>00168   <span class="keywordflow">if</span> (nbanodes &gt; 0) {
<a name="l00169"></a>00169 
<a name="l00170"></a>00170     <span class="comment">// start balancing</span>
<a name="l00171"></a>00171     <a class="code" href="logging_8c.html#abe06a8732a47a291606edcfac5e5146e">logprint</a> (<a class="code" href="logging_8h.html#a9b52156aa5746cc612e2e3edea6d5dbd">LOG_STATUS</a>, <span class="stringliteral">&quot;NOTIFY: %s: balancing at %d nodes\n&quot;</span>, getName (),
<a name="l00172"></a>00172               nbanodes);
<a name="l00173"></a>00173 
<a name="l00174"></a>00174     <span class="comment">// prepares the non-linear part</span>
<a name="l00175"></a>00175     prepareNonLinear ();
<a name="l00176"></a>00176 
<a name="l00177"></a>00177 <span class="preprocessor">#if HB_DEBUG</span>
<a name="l00178"></a>00178 <span class="preprocessor"></span>      fprintf (stderr, <span class="stringliteral">&quot;YV -- transY in f:\n&quot;</span>); YV-&gt;print ();
<a name="l00179"></a>00179       fprintf (stderr, <span class="stringliteral">&quot;IC -- constant current in f:\n&quot;</span>); IC-&gt;print ();
<a name="l00180"></a>00180 <span class="preprocessor">#endif</span>
<a name="l00181"></a>00181 <span class="preprocessor"></span>
<a name="l00182"></a>00182     <span class="comment">// start iteration</span>
<a name="l00183"></a>00183     <span class="keywordflow">do</span> {
<a name="l00184"></a>00184       iterations++;
<a name="l00185"></a>00185 
<a name="l00186"></a>00186 <span class="preprocessor">#if HB_DEBUG</span>
<a name="l00187"></a>00187 <span class="preprocessor"></span>      fprintf (stderr, <span class="stringliteral">&quot;\n   -- iteration step: %d\n&quot;</span>, iterations);
<a name="l00188"></a>00188       fprintf (stderr, <span class="stringliteral">&quot;vs -- voltage in t:\n&quot;</span>); vs-&gt;print ();
<a name="l00189"></a>00189 <span class="preprocessor">#endif</span>
<a name="l00190"></a>00190 <span class="preprocessor"></span>
<a name="l00191"></a>00191       <span class="comment">// evaluate component functionality and fill matrices and vectors</span>
<a name="l00192"></a>00192       loadMatrices ();
<a name="l00193"></a>00193 
<a name="l00194"></a>00194 <span class="preprocessor">#if HB_DEBUG</span>
<a name="l00195"></a>00195 <span class="preprocessor"></span>      fprintf (stderr, <span class="stringliteral">&quot;FQ -- charge in t:\n&quot;</span>); FQ-&gt;print ();
<a name="l00196"></a>00196       fprintf (stderr, <span class="stringliteral">&quot;IG -- current in t:\n&quot;</span>); IG-&gt;print ();
<a name="l00197"></a>00197 <span class="preprocessor">#endif</span>
<a name="l00198"></a>00198 <span class="preprocessor"></span>
<a name="l00199"></a>00199       <span class="comment">// currents into frequency domain</span>
<a name="l00200"></a>00200       VectorFFT (IG);
<a name="l00201"></a>00201 
<a name="l00202"></a>00202       <span class="comment">// charges into frequency domain</span>
<a name="l00203"></a>00203       VectorFFT (FQ);
<a name="l00204"></a>00204 
<a name="l00205"></a>00205       <span class="comment">// right hand side currents and charges into the frequency domain</span>
<a name="l00206"></a>00206       VectorFFT (IR);
<a name="l00207"></a>00207       VectorFFT (QR);
<a name="l00208"></a>00208 
<a name="l00209"></a>00209 <span class="preprocessor">#if HB_DEBUG</span>
<a name="l00210"></a>00210 <span class="preprocessor"></span>      fprintf (stderr, <span class="stringliteral">&quot;VS -- voltage in f:\n&quot;</span>); VS-&gt;print ();
<a name="l00211"></a>00211       fprintf (stderr, <span class="stringliteral">&quot;FQ -- charge in f:\n&quot;</span>); FQ-&gt;print ();
<a name="l00212"></a>00212       fprintf (stderr, <span class="stringliteral">&quot;IG -- current in f:\n&quot;</span>); IG-&gt;print ();
<a name="l00213"></a>00213       fprintf (stderr, <span class="stringliteral">&quot;IR -- corrected Jacobi current in f:\n&quot;</span>); IR-&gt;print ();
<a name="l00214"></a>00214 <span class="preprocessor">#endif</span>
<a name="l00215"></a>00215 <span class="preprocessor"></span>
<a name="l00216"></a>00216       <span class="comment">// solve HB equation --&gt; FV = IC + [YV] * VS + j[O] * FQ + IG</span>
<a name="l00217"></a>00217       solveHB ();
<a name="l00218"></a>00218 
<a name="l00219"></a>00219 <span class="preprocessor">#if HB_DEBUG</span>
<a name="l00220"></a>00220 <span class="preprocessor"></span>      fprintf (stderr, <span class="stringliteral">&quot;FV -- error vector F(V) in f:\n&quot;</span>); FV-&gt;print ();
<a name="l00221"></a>00221       fprintf (stderr, <span class="stringliteral">&quot;IL -- linear currents in f:\n&quot;</span>); IL-&gt;print ();
<a name="l00222"></a>00222       fprintf (stderr, <span class="stringliteral">&quot;IN -- non-linear currents in f:\n&quot;</span>); IN-&gt;print ();
<a name="l00223"></a>00223       fprintf (stderr, <span class="stringliteral">&quot;RH -- right-hand side currents in f:\n&quot;</span>); RH-&gt;print ();
<a name="l00224"></a>00224 <span class="preprocessor">#endif</span>
<a name="l00225"></a>00225 <span class="preprocessor"></span>
<a name="l00226"></a>00226       <span class="comment">// termination criteria met</span>
<a name="l00227"></a>00227       <span class="keywordflow">if</span> (iterations &gt; 1 &amp;&amp; checkBalance ()) {
<a name="l00228"></a>00228         done = 1;
<a name="l00229"></a>00229         <span class="keywordflow">break</span>;
<a name="l00230"></a>00230       }
<a name="l00231"></a>00231 
<a name="l00232"></a>00232 <span class="preprocessor">#if HB_DEBUG</span>
<a name="l00233"></a>00233 <span class="preprocessor"></span>      fprintf (stderr, <span class="stringliteral">&quot;JG -- G-Jacobian in t:\n&quot;</span>); JG-&gt;print ();
<a name="l00234"></a>00234       fprintf (stderr, <span class="stringliteral">&quot;JQ -- C-Jacobian in t:\n&quot;</span>); JQ-&gt;print ();
<a name="l00235"></a>00235 <span class="preprocessor">#endif</span>
<a name="l00236"></a>00236 <span class="preprocessor"></span>
<a name="l00237"></a>00237       <span class="comment">// G-Jacobian into frequency domain</span>
<a name="l00238"></a>00238       MatrixFFT (JG);
<a name="l00239"></a>00239 
<a name="l00240"></a>00240       <span class="comment">// C-Jacobian into frequency domain</span>
<a name="l00241"></a>00241       MatrixFFT (JQ);
<a name="l00242"></a>00242 
<a name="l00243"></a>00243 <span class="preprocessor">#if HB_DEBUG</span>
<a name="l00244"></a>00244 <span class="preprocessor"></span>      fprintf (stderr, <span class="stringliteral">&quot;JQ -- dQ/dV C-Jacobian in f:\n&quot;</span>); JQ-&gt;print ();
<a name="l00245"></a>00245       fprintf (stderr, <span class="stringliteral">&quot;JG -- dI/dV G-Jacobian in f:\n&quot;</span>); JG-&gt;print ();
<a name="l00246"></a>00246 <span class="preprocessor">#endif</span>
<a name="l00247"></a>00247 <span class="preprocessor"></span>
<a name="l00248"></a>00248       <span class="comment">// calculate Jacobian --&gt; JF = [YV] + j[O] * JQ + JG</span>
<a name="l00249"></a>00249       calcJacobian ();
<a name="l00250"></a>00250 
<a name="l00251"></a>00251 <span class="preprocessor">#if HB_DEBUG</span>
<a name="l00252"></a>00252 <span class="preprocessor"></span>      fprintf (stderr, <span class="stringliteral">&quot;JF -- full Jacobian in f:\n&quot;</span>); JF-&gt;print ();
<a name="l00253"></a>00253 <span class="preprocessor">#endif</span>
<a name="l00254"></a>00254 <span class="preprocessor"></span>
<a name="l00255"></a>00255       <span class="comment">// solve equation system --&gt; JF * VS(n+1) = JF * VS(n) - FV</span>
<a name="l00256"></a>00256       solveVoltages ();
<a name="l00257"></a>00257 
<a name="l00258"></a>00258 <span class="preprocessor">#if HB_DEBUG</span>
<a name="l00259"></a>00259 <span class="preprocessor"></span>      fprintf (stderr, <span class="stringliteral">&quot;VS -- next voltage in f:\n&quot;</span>); VS-&gt;print ();
<a name="l00260"></a>00260 <span class="preprocessor">#endif</span>
<a name="l00261"></a>00261 <span class="preprocessor"></span>
<a name="l00262"></a>00262       <span class="comment">// inverse FFT of frequency domain voltage vector VS(n+1)</span>
<a name="l00263"></a>00263       VectorIFFT (vs);
<a name="l00264"></a>00264     }
<a name="l00265"></a>00265     <span class="comment">// check termination criteria (balanced frequency domain currents)</span>
<a name="l00266"></a>00266     <span class="keywordflow">while</span> (!done &amp;&amp; iterations &lt; MaxIterations);
<a name="l00267"></a>00267 
<a name="l00268"></a>00268     <span class="keywordflow">if</span> (iterations &gt;= MaxIterations) {
<a name="l00269"></a>00269       qucs::exception * <a class="code" href="group__qucsMathConstants.html#gae162651ba6f0c9b150cf9bd8c41113c8" title="Euler&#39;s constant ( )">e</a> = <span class="keyword">new</span> qucs::exception (<a class="code" href="structqucs.html#ac060e999cf6725990fdd6c65600a62e5a28c96ff10d13b86706a9375af2dd7fe0">EXCEPTION_NO_CONVERGENCE</a>);
<a name="l00270"></a>00270       e-&gt;setText (<span class="stringliteral">&quot;no convergence in %s analysis after %d iterations&quot;</span>,
<a name="l00271"></a>00271                   getName (), iterations);
<a name="l00272"></a>00272       <a class="code" href="exceptionstack_8h.html#a8da005873bb805e4071f4b7cd9da6cdb">throw_exception</a> (e);
<a name="l00273"></a>00273       <a class="code" href="logging_8c.html#abe06a8732a47a291606edcfac5e5146e">logprint</a> (<a class="code" href="logging_8h.html#aced66975c154ea0e2a8ec3bc818b4e08">LOG_ERROR</a>, <span class="stringliteral">&quot;%s: no convergence after %d iterations\n&quot;</span>,
<a name="l00274"></a>00274                 getName (), iterations);
<a name="l00275"></a>00275     }
<a name="l00276"></a>00276     <span class="keywordflow">else</span> {
<a name="l00277"></a>00277       <a class="code" href="logging_8c.html#abe06a8732a47a291606edcfac5e5146e">logprint</a> (<a class="code" href="logging_8h.html#a9b52156aa5746cc612e2e3edea6d5dbd">LOG_STATUS</a>, <span class="stringliteral">&quot;%s: convergence reached after %d iterations\n&quot;</span>,
<a name="l00278"></a>00278                 getName (), iterations);
<a name="l00279"></a>00279     }
<a name="l00280"></a>00280   }
<a name="l00281"></a>00281   <span class="keywordflow">else</span> {
<a name="l00282"></a>00282     <span class="comment">// no balancing necessary</span>
<a name="l00283"></a>00283     <a class="code" href="logging_8c.html#abe06a8732a47a291606edcfac5e5146e">logprint</a> (<a class="code" href="logging_8h.html#a9b52156aa5746cc612e2e3edea6d5dbd">LOG_STATUS</a>, <span class="stringliteral">&quot;NOTIFY: %s: no balancing necessary\n&quot;</span>, getName ());
<a name="l00284"></a>00284   }
<a name="l00285"></a>00285 
<a name="l00286"></a>00286   <span class="comment">// print exception stack</span>
<a name="l00287"></a>00287   <a class="code" href="structqucs.html#a99a68a2452092cafcd735a48a064a8bf">estack</a>.<a class="code" href="classqucs_1_1exceptionstack.html#a486af86b492f662998c8d7ced9ecd64f">print</a> ();
<a name="l00288"></a>00288 
<a name="l00289"></a>00289   <span class="comment">// apply AC analysis to the complete network in order to obtain the</span>
<a name="l00290"></a>00290   <span class="comment">// final results</span>
<a name="l00291"></a>00291   finalSolution ();
<a name="l00292"></a>00292 
<a name="l00293"></a>00293   <span class="comment">// save results into dataset</span>
<a name="l00294"></a>00294   saveResults ();
<a name="l00295"></a>00295   <span class="keywordflow">return</span> 0;
<a name="l00296"></a>00296 }
<a name="l00297"></a>00297 
<a name="l00298"></a>00298 <span class="comment">/* Goes through the list of circuit objects and runs its calcHB()</span>
<a name="l00299"></a>00299 <span class="comment">   function. */</span>
<a name="l00300"></a><a class="code" href="structqucs_1_1hbsolver.html#ae20f948d7a0ba8ad5812c1440c25f9c2">00300</a> <span class="keywordtype">void</span> hbsolver::calc (<a class="code" href="structqucs_1_1hbsolver.html">hbsolver</a> * <span class="keyword">self</span>) {
<a name="l00301"></a>00301   <a class="code" href="classqucs_1_1circuit.html" title="base class for qucs circuit elements.">circuit</a> * root = <span class="keyword">self</span>-&gt;<a class="code" href="classqucs_1_1circuit.html#a1fd37ca5a3d4dc9c490ec6e091782cfb">getNet</a>()-&gt;<a class="code" href="classqucs_1_1net.html#a455b0f56b9d0e0415a820880475e0eb8">getRoot</a> ();
<a name="l00302"></a>00302   <span class="keywordflow">for</span> (<a class="code" href="classqucs_1_1circuit.html" title="base class for qucs circuit elements.">circuit</a> * <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a> = root; <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a> != NULL; <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a> = (<a class="code" href="classqucs_1_1circuit.html" title="base class for qucs circuit elements.">circuit</a> *) <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>-&gt;<a class="code" href="classqucs_1_1eqn_1_1node.html#ad2f8b4edb365f182a9c9eed4af7491fc">getNext</a> ()) {
<a name="l00303"></a>00303     <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>-&gt;calcHB (self-&gt;frequency);
<a name="l00304"></a>00304   }
<a name="l00305"></a>00305 }
<a name="l00306"></a>00306 
<a name="l00307"></a>00307 <span class="comment">/* Goes through the list of circuit objects and runs its initHB()</span>
<a name="l00308"></a>00308 <span class="comment">   function. */</span>
<a name="l00309"></a><a class="code" href="structqucs_1_1hbsolver.html#af9f8bc9670f2934abba03abd8862844b">00309</a> <span class="keywordtype">void</span> hbsolver::initHB (<span class="keywordtype">void</span>) {
<a name="l00310"></a>00310   <a class="code" href="classqucs_1_1circuit.html" title="base class for qucs circuit elements.">circuit</a> * root = subnet-&gt;getRoot ();
<a name="l00311"></a>00311   <span class="keywordflow">for</span> (<a class="code" href="classqucs_1_1circuit.html" title="base class for qucs circuit elements.">circuit</a> * <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a> = root; <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a> != NULL; <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a> = (<a class="code" href="classqucs_1_1circuit.html" title="base class for qucs circuit elements.">circuit</a> *) <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>-&gt;<a class="code" href="classqucs_1_1eqn_1_1node.html#ad2f8b4edb365f182a9c9eed4af7491fc">getNext</a> ()) {
<a name="l00312"></a>00312     <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>-&gt;initHB ();
<a name="l00313"></a>00313   }
<a name="l00314"></a>00314 }
<a name="l00315"></a>00315 
<a name="l00316"></a>00316 <span class="comment">/* Goes through the list of circuit objects and runs its initDC()</span>
<a name="l00317"></a>00317 <span class="comment">   function. */</span>
<a name="l00318"></a><a class="code" href="structqucs_1_1hbsolver.html#a458a008ff87db6970d27fc6673f2f25c">00318</a> <span class="keywordtype">void</span> hbsolver::initDC (<span class="keywordtype">void</span>) {
<a name="l00319"></a>00319   <a class="code" href="classqucs_1_1circuit.html" title="base class for qucs circuit elements.">circuit</a> * root = subnet-&gt;getRoot ();
<a name="l00320"></a>00320   <span class="keywordflow">for</span> (<a class="code" href="classqucs_1_1circuit.html" title="base class for qucs circuit elements.">circuit</a> * <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a> = root; <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a> != NULL; <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a> = (<a class="code" href="classqucs_1_1circuit.html" title="base class for qucs circuit elements.">circuit</a> *) <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>-&gt;<a class="code" href="classqucs_1_1eqn_1_1node.html#ad2f8b4edb365f182a9c9eed4af7491fc">getNext</a> ()) {
<a name="l00321"></a>00321     <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>-&gt;initDC ();
<a name="l00322"></a>00322   }
<a name="l00323"></a>00323 }
<a name="l00324"></a>00324 
<a name="l00325"></a>00325 <span class="comment">// Returns true if circuit is a HB source.</span>
<a name="l00326"></a><a class="code" href="structqucs_1_1hbsolver.html#ad21f26e67800ef9f4b6000ddfc35f3e7">00326</a> <span class="keywordtype">bool</span> hbsolver::isExcitation (<a class="code" href="classqucs_1_1circuit.html" title="base class for qucs circuit elements.">circuit</a> * <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>) {
<a name="l00327"></a>00327   <span class="keywordtype">int</span> <a class="code" href="parse__vcd_8y.html#ae0bd5e8ec17b2aad3338041991eb1056">type</a> = c-&gt;<a class="code" href="classqucs_1_1circuit.html#af673350ac328ff2084492c7c5b38197b">getType</a> ();
<a name="l00328"></a>00328   <span class="keywordflow">if</span> (type == <a class="code" href="structqucs.html#abde5863a0f1b48885189b3a2cf77cfcaa6ce8600408d8babe0359e1d50b729670">CIR_PAC</a> || type == <a class="code" href="structqucs.html#abde5863a0f1b48885189b3a2cf77cfcaa8482dad3d6a4defe47a9f0b459cb0f64">CIR_VAC</a> || type == <a class="code" href="structqucs.html#abde5863a0f1b48885189b3a2cf77cfcaaa5404d6bdb6183d2824ce63f748eaf55">CIR_VDC</a>)
<a name="l00329"></a>00329     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00330"></a>00330   <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00331"></a>00331 }
<a name="l00332"></a>00332 
<a name="l00333"></a>00333 <span class="comment">// Expands the frequency array using the given frequency and the order.</span>
<a name="l00334"></a><a class="code" href="structqucs_1_1hbsolver.html#acb93fc080b9f47206206efaf54185441">00334</a> <span class="keywordtype">void</span> hbsolver::expandFrequencies (<a class="code" href="config_8h.html#a014aadc409afb297b8247c13f8ca89be">nr_double_t</a> f, <span class="keywordtype">int</span> <a class="code" href="parse__mdl_8y.html#aecba4cab5e52994730d1e21424997b33">n</a>) {
<a name="l00335"></a>00335   <span class="keyword">auto</span> nfreqs = negfreqs;
<a name="l00336"></a>00336   <span class="keyword">auto</span> pfreqs = posfreqs;
<a name="l00337"></a>00337   <span class="keywordtype">int</span> <a class="code" href="parse__mdl_8y.html#a7e98b8a17c0aad30ba64d47b74e2a6c1">i</a>, k, len = nfreqs.size ();
<a name="l00338"></a>00338   negfreqs.clear ();
<a name="l00339"></a>00339   posfreqs.clear ();
<a name="l00340"></a>00340   <span class="keywordflow">if</span> (len &gt; 0) {
<a name="l00341"></a>00341     <span class="comment">// frequency expansion for full frequency sets</span>
<a name="l00342"></a>00342     <span class="keywordflow">for</span> (i = 0; i &lt;= n + 1; i++) {
<a name="l00343"></a>00343       <span class="keywordflow">for</span> (k = 0; k &lt; len; k++) {
<a name="l00344"></a>00344         negfreqs.push_back (i * f + nfreqs[k]);
<a name="l00345"></a>00345       }
<a name="l00346"></a>00346     }
<a name="l00347"></a>00347     <span class="keywordflow">for</span> (i = -n; i &lt; 0; i++) {
<a name="l00348"></a>00348       <span class="keywordflow">for</span> (k = 0; k &lt; len; k++) {
<a name="l00349"></a>00349         negfreqs.push_back (i * f + nfreqs[k]);
<a name="l00350"></a>00350       }
<a name="l00351"></a>00351     }
<a name="l00352"></a>00352     <span class="keywordflow">for</span> (i = 0; i &lt;= 2 * n + 1; i++) {
<a name="l00353"></a>00353       <span class="keywordflow">for</span> (k = 0; k &lt; len; k++) {
<a name="l00354"></a>00354         posfreqs.push_back (i * f + pfreqs[k]);
<a name="l00355"></a>00355       }
<a name="l00356"></a>00356     }
<a name="l00357"></a>00357   }
<a name="l00358"></a>00358   <span class="keywordflow">else</span> {
<a name="l00359"></a>00359     <span class="comment">// first frequency</span>
<a name="l00360"></a>00360     <span class="keywordflow">for</span> (i = 0; i &lt;= n + 1; i++) negfreqs.push_back (i * f);
<a name="l00361"></a>00361     <span class="keywordflow">for</span> (i = -n; i &lt; 0; i++) negfreqs.push_back (i * f);
<a name="l00362"></a>00362     <span class="keywordflow">for</span> (i = 0; i &lt;= 2 * n + 1; i++) posfreqs.push_back (i * f);
<a name="l00363"></a>00363   }
<a name="l00364"></a>00364 }
<a name="l00365"></a>00365 
<a name="l00366"></a>00366 <span class="comment">// Calculates an order fulfilling the &quot;power of two&quot; requirement.</span>
<a name="l00367"></a><a class="code" href="structqucs_1_1hbsolver.html#a28f4053307c538bc506e08c06ef1ff33">00367</a> <span class="keywordtype">int</span> hbsolver::calcOrder (<span class="keywordtype">int</span> <a class="code" href="parse__mdl_8y.html#aecba4cab5e52994730d1e21424997b33">n</a>) {
<a name="l00368"></a>00368   <span class="keywordtype">int</span> o, order = n * 2;             <span class="comment">// current order + DC + negative freqencies</span>
<a name="l00369"></a>00369   <span class="keywordflow">for</span> (o = 1; o &lt; order; o &lt;&lt;= 1) ; <span class="comment">// a power of 2</span>
<a name="l00370"></a>00370   <span class="keywordflow">return</span> o / 2 - 1;
<a name="l00371"></a>00371 }
<a name="l00372"></a>00372 
<a name="l00373"></a>00373 <span class="comment">/* The function computes the harmonic frequencies excited in the</span>
<a name="l00374"></a>00374 <span class="comment">   circuit list depending on the maximum number of harmonics per</span>
<a name="l00375"></a>00375 <span class="comment">   exitation and saves its results into the &#39;negfreqs&#39; vector. */</span>
<a name="l00376"></a><a class="code" href="structqucs_1_1hbsolver.html#a279c25476ee74edb366413060b6edad2">00376</a> <span class="keywordtype">void</span> hbsolver::collectFrequencies (<span class="keywordtype">void</span>) {
<a name="l00377"></a>00377 
<a name="l00378"></a>00378   <span class="comment">// initialization</span>
<a name="l00379"></a>00379   negfreqs.clear ();
<a name="l00380"></a>00380   posfreqs.clear ();
<a name="l00381"></a>00381   rfreqs.clear ();
<a name="l00382"></a>00382   dfreqs.clear ();
<a name="l00383"></a>00383   <span class="keywordflow">if</span> (ndfreqs) <span class="keyword">delete</span>[] ndfreqs;
<a name="l00384"></a>00384 
<a name="l00385"></a>00385   <span class="comment">// obtain order</span>
<a name="l00386"></a>00386   <span class="keywordtype">int</span> <a class="code" href="parse__mdl_8y.html#a7e98b8a17c0aad30ba64d47b74e2a6c1">i</a>, <a class="code" href="parse__mdl_8y.html#aecba4cab5e52994730d1e21424997b33">n</a> = calcOrder (getPropertyInteger (<span class="stringliteral">&quot;n&quot;</span>));
<a name="l00387"></a>00387 
<a name="l00388"></a>00388   <span class="comment">// expand frequencies for each exitation</span>
<a name="l00389"></a>00389   <a class="code" href="config_8h.html#a014aadc409afb297b8247c13f8ca89be">nr_double_t</a> f;
<a name="l00390"></a>00390   <span class="keywordflow">for</span> (<span class="keyword">auto</span> * <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a> : excitations) {
<a name="l00391"></a>00391     <span class="keywordflow">if</span> (<a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>-&gt;<a class="code" href="classqucs_1_1eqn_1_1node.html#a217190c8424776caabc203b7cec07467">getType</a> () != <a class="code" href="structqucs.html#abde5863a0f1b48885189b3a2cf77cfcaaa5404d6bdb6183d2824ce63f748eaf55">CIR_VDC</a>) { <span class="comment">// no extra DC sources</span>
<a name="l00392"></a>00392       <span class="keywordflow">if</span> ((f = <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>-&gt;getPropertyDouble (<span class="stringliteral">&quot;f&quot;</span>)) != 0.0) {
<a name="l00393"></a>00393         <span class="keyword">const</span> <span class="keyword">auto</span> epsilon = std::numeric_limits&lt;nr_double_t&gt;::epsilon();
<a name="l00394"></a>00394         <span class="keyword">auto</span> found =
<a name="l00395"></a>00395           std::find_if(dfreqs.cbegin(),dfreqs.cend(),
<a name="l00396"></a>00396                        [f,epsilon](decltype(*dfreqs.cbegin()) <a class="code" href="parse__mdl_8y.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>) {
<a name="l00397"></a>00397                          <span class="keywordflow">return</span> (<a class="code" href="namespacequcs.html#ae19977dcd124dcf020fd21b46cf92e2f" title="Computes magnitude of each matrix element.">std::abs</a>(<a class="code" href="parse__mdl_8y.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>-f) &lt; epsilon);
<a name="l00398"></a>00398                        })
<a name="l00399"></a>00399           ;
<a name="l00400"></a>00400         <span class="keywordflow">if</span> (found == dfreqs.cend()) { <span class="comment">// no double frequencies</span>
<a name="l00401"></a>00401           dfreqs.push_back (f);
<a name="l00402"></a>00402           expandFrequencies (f, n);
<a name="l00403"></a>00403         }
<a name="l00404"></a>00404       }
<a name="l00405"></a>00405     }
<a name="l00406"></a>00406   }
<a name="l00407"></a>00407 
<a name="l00408"></a>00408   <span class="comment">// no excitations</span>
<a name="l00409"></a>00409   <span class="keywordflow">if</span> (negfreqs.size () == 0) {
<a name="l00410"></a>00410     <span class="comment">// use specified frequency</span>
<a name="l00411"></a>00411     f = getPropertyDouble (<span class="stringliteral">&quot;f&quot;</span>);
<a name="l00412"></a>00412     dfreqs.push_back (f);
<a name="l00413"></a>00413     expandFrequencies (f, n);
<a name="l00414"></a>00414   }
<a name="l00415"></a>00415 
<a name="l00416"></a>00416   <span class="comment">// build frequency dimension lengths</span>
<a name="l00417"></a>00417   ndfreqs = <span class="keyword">new</span> <span class="keywordtype">int</span>[dfreqs.size ()];
<a name="l00418"></a>00418   <span class="keywordflow">for</span> (i = 0; i &lt; dfreqs.size (); i++) {
<a name="l00419"></a>00419     ndfreqs[<a class="code" href="parse__mdl_8y.html#a7e98b8a17c0aad30ba64d47b74e2a6c1">i</a>] = (n + 1) * 2;
<a name="l00420"></a>00420   }
<a name="l00421"></a>00421 
<a name="l00422"></a>00422 <span class="preprocessor">#if HB_DEBUG</span>
<a name="l00423"></a>00423 <span class="preprocessor"></span>  fprintf (stderr, <span class="stringliteral">&quot;%d frequencies: [ &quot;</span>, negfreqs.getSize ());
<a name="l00424"></a>00424   <span class="keywordflow">for</span> (i = 0; i &lt; negfreqs.getSize (); i++) {
<a name="l00425"></a>00425     fprintf (stderr, <span class="stringliteral">&quot;%g &quot;</span>, (<span class="keywordtype">double</span>) <a class="code" href="namespacequcs.html#a0cc73c27d7d13b2200f2fddbb064dce6" title="Real part matrix.">real</a> (negfreqs.get (i)));
<a name="l00426"></a>00426   }
<a name="l00427"></a>00427   fprintf (stderr, <span class="stringliteral">&quot;]\n&quot;</span>);
<a name="l00428"></a>00428 <span class="preprocessor">#endif </span><span class="comment">/* HB_DEBUG */</span>
<a name="l00429"></a>00429 
<a name="l00430"></a>00430   <span class="comment">// build list of positive frequencies including DC</span>
<a name="l00431"></a>00431   <span class="keywordflow">for</span> (n = 0; n &lt; negfreqs.size (); n++) {
<a name="l00432"></a>00432     <span class="keywordflow">if</span> ((f = negfreqs[n]) &lt; 0.0) <span class="keywordflow">continue</span>;
<a name="l00433"></a>00433     rfreqs.push_back (f);
<a name="l00434"></a>00434   }
<a name="l00435"></a>00435   lnfreqs = rfreqs.size ();
<a name="l00436"></a>00436   nlfreqs = negfreqs.size ();
<a name="l00437"></a>00437 
<a name="l00438"></a>00438   <span class="comment">// pre-calculate the j[O] vector</span>
<a name="l00439"></a>00439   OM = <span class="keyword">new</span> <a class="code" href="classqucs_1_1tvector.html">tvector&lt;nr_complex_t&gt;</a> (nlfreqs);
<a name="l00440"></a>00440   <span class="keywordflow">for</span> (n = i = 0; n &lt; nlfreqs; n++, i++)
<a name="l00441"></a>00441     <a class="code" href="hbsolver_8cpp.html#aae67df46a02b4df8bf6f0222eef8e58a">OM_</a>(n) = <a class="code" href="complex_8h.html#a7ad1a12245ad87a9d81d6bcc18afacae">nr_complex_t</a> (0, 2 * M_PI * negfreqs[i]);
<a name="l00442"></a>00442 }
<a name="l00443"></a>00443 
<a name="l00444"></a>00444 <span class="comment">// Split netlist into excitation, linear and non-linear part.</span>
<a name="l00445"></a><a class="code" href="structqucs_1_1hbsolver.html#a0dc5ddd070641dbd8c1f97836b09959a">00445</a> <span class="keywordtype">void</span> hbsolver::splitCircuits (<span class="keywordtype">void</span>) {
<a name="l00446"></a>00446   <a class="code" href="classqucs_1_1circuit.html" title="base class for qucs circuit elements.">circuit</a> * root = subnet-&gt;getRoot ();
<a name="l00447"></a>00447   <span class="keywordflow">for</span> (<a class="code" href="classqucs_1_1circuit.html" title="base class for qucs circuit elements.">circuit</a> * <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a> = root; <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a> != NULL; <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a> = (<a class="code" href="classqucs_1_1circuit.html" title="base class for qucs circuit elements.">circuit</a> *) <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>-&gt;<a class="code" href="classqucs_1_1eqn_1_1node.html#ad2f8b4edb365f182a9c9eed4af7491fc">getNext</a> ()) {
<a name="l00448"></a>00448     <span class="keywordflow">if</span> (<a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>-&gt;isNonLinear ()) {
<a name="l00449"></a>00449       <span class="comment">// non-linear part</span>
<a name="l00450"></a>00450       nolcircuits.push_front(<a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>);
<a name="l00451"></a>00451     }
<a name="l00452"></a>00452     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isExcitation (<a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>)) {
<a name="l00453"></a>00453       <span class="comment">// get sinusoidal sources</span>
<a name="l00454"></a>00454       excitations.push_front(<a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>);
<a name="l00455"></a>00455     }
<a name="l00456"></a>00456     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>-&gt;<a class="code" href="classqucs_1_1eqn_1_1node.html#a217190c8424776caabc203b7cec07467">getType</a> () != <a class="code" href="structqucs.html#abde5863a0f1b48885189b3a2cf77cfcaa9eee639389a8ea2182708c360c9411ac">CIR_GROUND</a>) {
<a name="l00457"></a>00457       <span class="comment">// linear part</span>
<a name="l00458"></a>00458       lincircuits.push_front (<a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>);
<a name="l00459"></a>00459     }
<a name="l00460"></a>00460   }
<a name="l00461"></a>00461 }
<a name="l00462"></a>00462 
<a name="l00463"></a>00463 <span class="comment">// Creates a nodelist for the given circuit list.</span>
<a name="l00464"></a><a class="code" href="structqucs_1_1hbsolver.html#ab70d8f4b6804a682e03075080b80788c">00464</a> <a class="code" href="classqucs_1_1strlist.html">strlist</a> * hbsolver::circuitNodes (ptrlist&lt;circuit&gt; circuits) {
<a name="l00465"></a>00465   <a class="code" href="classqucs_1_1strlist.html">strlist</a> * <a class="code" href="parse__netlist_8y.html#a6da5270e48c8b5c2f0dbaa008af4df76">nodes</a> = <span class="keyword">new</span> <a class="code" href="classqucs_1_1strlist.html">strlist</a> ();
<a name="l00466"></a>00466   <span class="keywordflow">for</span> (<span class="keyword">auto</span> * <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a> : circuits) {
<a name="l00467"></a>00467     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code" href="parse__mdl_8y.html#a7e98b8a17c0aad30ba64d47b74e2a6c1">i</a> = 0; <a class="code" href="parse__mdl_8y.html#a7e98b8a17c0aad30ba64d47b74e2a6c1">i</a> &lt; <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>-&gt;getSize (); <a class="code" href="parse__mdl_8y.html#a7e98b8a17c0aad30ba64d47b74e2a6c1">i</a>++) {
<a name="l00468"></a>00468       <span class="keyword">const</span> <span class="keywordtype">char</span> * <a class="code" href="parse__mdl_8y.html#aecba4cab5e52994730d1e21424997b33">n</a> = <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>-&gt;getNode(<a class="code" href="parse__mdl_8y.html#a7e98b8a17c0aad30ba64d47b74e2a6c1">i</a>)-&gt;getName ();
<a name="l00469"></a>00469       <span class="keywordflow">if</span> (strcmp (n, <span class="stringliteral">&quot;gnd&quot;</span>)) {
<a name="l00470"></a>00470         <span class="keywordflow">if</span> (!nodes-&gt;<a class="code" href="classqucs_1_1strlist.html#a8e657e494a9b9dd2b9d61133b341c615">contains</a> (n)) nodes-&gt;<a class="code" href="classqucs_1_1strlist.html#a5ea39ba0cea73ced0ac612832b159c39">add</a> (n);
<a name="l00471"></a>00471       }
<a name="l00472"></a>00472     }
<a name="l00473"></a>00473   }
<a name="l00474"></a>00474   <span class="keywordflow">return</span> <a class="code" href="parse__netlist_8y.html#a6da5270e48c8b5c2f0dbaa008af4df76">nodes</a>;
<a name="l00475"></a>00475 }
<a name="l00476"></a>00476 
<a name="l00477"></a>00477 <span class="comment">// Obtain node lists for linear and non-linear part.</span>
<a name="l00478"></a><a class="code" href="structqucs_1_1hbsolver.html#af8816dac64896317ba0ba9c20643ea76">00478</a> <span class="keywordtype">void</span> hbsolver::getNodeLists (<span class="keywordtype">void</span>) {
<a name="l00479"></a>00479   <span class="comment">// non-linear nodes</span>
<a name="l00480"></a>00480   nlnodes = circuitNodes (nolcircuits);
<a name="l00481"></a>00481   <span class="comment">// linear nodes</span>
<a name="l00482"></a>00482   lnnodes = circuitNodes (lincircuits);
<a name="l00483"></a>00483   <span class="comment">// excitation nodes</span>
<a name="l00484"></a>00484   exnodes = circuitNodes (excitations);
<a name="l00485"></a>00485 
<a name="l00486"></a>00486 <span class="preprocessor">#if DEBUG &amp;&amp; 0</span>
<a name="l00487"></a>00487 <span class="preprocessor"></span>  fprintf (stderr, <span class="stringliteral">&quot;nonlinear nodes: [ %s ]\n&quot;</span>, nlnodes-&gt;toString ());
<a name="l00488"></a>00488   fprintf (stderr, <span class="stringliteral">&quot;   linear nodes: [ %s ]\n&quot;</span>, lnnodes-&gt;toString ());
<a name="l00489"></a>00489 <span class="preprocessor">#endif</span>
<a name="l00490"></a>00490 <span class="preprocessor"></span>
<a name="l00491"></a>00491   <span class="comment">// organization of the nodes for the MNA:</span>
<a name="l00492"></a>00492   <span class="comment">// --------------------------------------</span>
<a name="l00493"></a>00493   <span class="comment">// 1.)  balanced nodes: all connected to at least one non-linear device</span>
<a name="l00494"></a>00494   <span class="comment">// 2.a) the excitation nodes</span>
<a name="l00495"></a>00495   <span class="comment">// 2.b) all linear nodes not contained in 1. and 2.a</span>
<a name="l00496"></a>00496   <span class="comment">// 2.c) additional gyrators of linear nodes (built-in voltage sources)</span>
<a name="l00497"></a>00497   <span class="comment">// please note: excitation nodes also in 2.b; 1. and 2.a are &#39;ports&#39;</span>
<a name="l00498"></a>00498 
<a name="l00499"></a>00499   nanodes = <span class="keyword">new</span> <a class="code" href="classqucs_1_1strlist.html">strlist</a> (*nlnodes); <span class="comment">// list 1.</span>
<a name="l00500"></a>00500   <a class="code" href="classqucs_1_1strlistiterator.html">strlistiterator</a> it;
<a name="l00501"></a>00501   <span class="comment">// add excitation nodes; list 2.a</span>
<a name="l00502"></a>00502   <span class="keywordflow">for</span> (it = <a class="code" href="classqucs_1_1strlistiterator.html">strlistiterator</a> (exnodes); *it; ++it)
<a name="l00503"></a>00503     nanodes-&gt;append (*it);
<a name="l00504"></a>00504   <span class="comment">// add linear nodes; list 2.b</span>
<a name="l00505"></a>00505   <span class="keywordflow">for</span> (it = <a class="code" href="classqucs_1_1strlistiterator.html">strlistiterator</a> (lnnodes); *it; ++it) {
<a name="l00506"></a>00506     <span class="keywordflow">if</span> (!nanodes-&gt;contains (*it))
<a name="l00507"></a>00507       nanodes-&gt;append (*it);
<a name="l00508"></a>00508   }
<a name="l00509"></a>00509 
<a name="l00510"></a>00510   banodes = <span class="keyword">new</span> <a class="code" href="classqucs_1_1strlist.html">strlist</a> (*nlnodes);
<a name="l00511"></a>00511 <span class="preprocessor">#if DEBUG &amp;&amp; 0</span>
<a name="l00512"></a>00512 <span class="preprocessor"></span>  fprintf (stderr, <span class="stringliteral">&quot; balanced nodes: [ %s ]\n&quot;</span>, banodes-&gt;toString ());
<a name="l00513"></a>00513   fprintf (stderr, <span class="stringliteral">&quot;  exnodes nodes: [ %s ]\n&quot;</span>, exnodes-&gt;toString ());
<a name="l00514"></a>00514   fprintf (stderr, <span class="stringliteral">&quot;  nanodes nodes: [ %s ]\n&quot;</span>, nanodes-&gt;toString ());
<a name="l00515"></a>00515 <span class="preprocessor">#endif</span>
<a name="l00516"></a>00516 <span class="preprocessor"></span>}
<a name="l00517"></a>00517 
<a name="l00518"></a>00518 <span class="comment">/* The function applies unique voltage source identifiers to each</span>
<a name="l00519"></a>00519 <span class="comment">   built in internal voltage source in the list of circuits. */</span>
<a name="l00520"></a><a class="code" href="structqucs_1_1hbsolver.html#a8d5396b62f06b27837e45271050b84ea">00520</a> <span class="keywordtype">int</span> hbsolver::assignVoltageSources (ptrlist&lt;circuit&gt; circuits) {
<a name="l00521"></a>00521   <span class="keywordtype">int</span> sources = 0;
<a name="l00522"></a>00522   <span class="keywordflow">for</span> (<span class="keyword">auto</span> *<a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>: circuits) {
<a name="l00523"></a>00523     <span class="keywordflow">if</span> (<a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>-&gt;getVoltageSources () &gt; 0) {
<a name="l00524"></a>00524       <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>-&gt;setVoltageSource (sources);
<a name="l00525"></a>00525       sources += <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>-&gt;getVoltageSources ();
<a name="l00526"></a>00526     }
<a name="l00527"></a>00527   }
<a name="l00528"></a>00528   <span class="keywordflow">return</span> sources;
<a name="l00529"></a>00529 }
<a name="l00530"></a>00530 
<a name="l00531"></a>00531 <span class="comment">/* The function assigns unique node identifiers to each circuit node. */</span>
<a name="l00532"></a><a class="code" href="structqucs_1_1hbsolver.html#ad4c74504312e90ab65a1a498f21adf83">00532</a> <span class="keywordtype">int</span> hbsolver::assignNodes (ptrlist&lt;circuit&gt; circuits, <a class="code" href="classqucs_1_1strlist.html">strlist</a> * <a class="code" href="parse__netlist_8y.html#a6da5270e48c8b5c2f0dbaa008af4df76">nodes</a>,
<a name="l00533"></a>00533                            <span class="keywordtype">int</span> offset) {
<a name="l00534"></a>00534   <span class="comment">// through all collected nodes</span>
<a name="l00535"></a>00535   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> nr = 0; nr &lt; nodes-&gt;<a class="code" href="classqucs_1_1strlist.html#a87eb9a784855e4df9ab4a0ed04cc229a">length</a> (); nr++) {
<a name="l00536"></a>00536     <span class="keywordtype">char</span> * nn = nodes-&gt;<a class="code" href="classqucs_1_1strlist.html#a488271b72be411939770fd41b4447844">get</a> (nr);
<a name="l00537"></a>00537     <span class="comment">// through all circuits</span>
<a name="l00538"></a>00538     <span class="keywordflow">for</span> (<span class="keyword">auto</span> *<a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a> : circuits) {
<a name="l00539"></a>00539       <span class="comment">// assign current identifier if any of the circuit nodes equals</span>
<a name="l00540"></a>00540       <span class="comment">// the current one</span>
<a name="l00541"></a>00541       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code" href="parse__mdl_8y.html#a7e98b8a17c0aad30ba64d47b74e2a6c1">i</a> = 0; <a class="code" href="parse__mdl_8y.html#a7e98b8a17c0aad30ba64d47b74e2a6c1">i</a> &lt; <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>-&gt;getSize (); <a class="code" href="parse__mdl_8y.html#a7e98b8a17c0aad30ba64d47b74e2a6c1">i</a>++) {
<a name="l00542"></a>00542         <a class="code" href="classqucs_1_1node.html">node</a> * <a class="code" href="parse__mdl_8y.html#aecba4cab5e52994730d1e21424997b33">n</a> = <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>-&gt;getNode (<a class="code" href="parse__mdl_8y.html#a7e98b8a17c0aad30ba64d47b74e2a6c1">i</a>);
<a name="l00543"></a>00543         <span class="keywordflow">if</span> (!strcmp (n-&gt;<a class="code" href="classqucs_1_1object.html#a3134f6d4b6abda0fb40ac2a9fb4344cc" title="Get the name of the object.">getName</a> (), nn)) n-&gt;<a class="code" href="classqucs_1_1node.html#a3a0f0d2024c0766d5187ae09415ba4b2" title="Sets the unique number of this node.">setNode</a> (offset + nr + 1);
<a name="l00544"></a>00544       }
<a name="l00545"></a>00545     }
<a name="l00546"></a>00546   }
<a name="l00547"></a>00547   <span class="keywordflow">return</span> nodes-&gt;<a class="code" href="classqucs_1_1strlist.html#a87eb9a784855e4df9ab4a0ed04cc229a">length</a> ();
<a name="l00548"></a>00548 }
<a name="l00549"></a>00549 
<a name="l00550"></a>00550 <span class="comment">// Prepares the linear operations.</span>
<a name="l00551"></a><a class="code" href="structqucs_1_1hbsolver.html#aa5c4f3343a7703269626874378b77721">00551</a> <span class="keywordtype">void</span> hbsolver::prepareLinear (<span class="keywordtype">void</span>) {
<a name="l00552"></a>00552   <span class="keywordflow">for</span> (<span class="keyword">auto</span> *lc : lincircuits)
<a name="l00553"></a>00553     lc-&gt;initHB ();
<a name="l00554"></a>00554   nlnvsrcs = assignVoltageSources (lincircuits);
<a name="l00555"></a>00555   nnlvsrcs = excitations.size ();
<a name="l00556"></a>00556   nnanodes = nanodes-&gt;length ();
<a name="l00557"></a>00557   nexnodes = exnodes-&gt;length ();
<a name="l00558"></a>00558   nbanodes = banodes-&gt;length ();
<a name="l00559"></a>00559   assignNodes (lincircuits, nanodes);
<a name="l00560"></a>00560   assignNodes (excitations, nanodes);
<a name="l00561"></a>00561   createMatrixLinearA ();
<a name="l00562"></a>00562   createMatrixLinearY ();
<a name="l00563"></a>00563   calcConstantCurrent ();
<a name="l00564"></a>00564 }
<a name="l00565"></a>00565 
<a name="l00566"></a>00566 <span class="comment">/* The function creates the complex linear network MNA matrix.  It</span>
<a name="l00567"></a>00567 <span class="comment">   contains the MNA entries for all linear components for each</span>
<a name="l00568"></a>00568 <span class="comment">   requested frequency. */</span>
<a name="l00569"></a><a class="code" href="structqucs_1_1hbsolver.html#a8b2ec0517eaa1feacd41c83db51b47b6">00569</a> <span class="keywordtype">void</span> hbsolver::createMatrixLinearA (<span class="keywordtype">void</span>) {
<a name="l00570"></a>00570   <span class="keywordtype">int</span> <a class="code" href="evaluate_8cpp.html#a92592142cb41364b6fe6ef9cc1a16dbd">M</a> = nlnvsrcs;
<a name="l00571"></a>00571   <span class="keywordtype">int</span> <a class="code" href="equation_8cpp.html#a540f72cb9bcf86a19e3bbc259b9ec3e0">N</a> = nnanodes;
<a name="l00572"></a>00572   <span class="keywordtype">int</span> f = 0;
<a name="l00573"></a>00573   <a class="code" href="config_8h.html#a014aadc409afb297b8247c13f8ca89be">nr_double_t</a> freq;
<a name="l00574"></a>00574 
<a name="l00575"></a>00575   <span class="comment">// create new MNA matrix</span>
<a name="l00576"></a>00576   <a class="code" href="eqndefined_8cpp.html#a70993d52766e31cb0157958a18aa499a">A</a> = <span class="keyword">new</span> <a class="code" href="classqucs_1_1tmatrix.html">tmatrix&lt;nr_complex_t&gt;</a> ((N + <a class="code" href="evaluate_8cpp.html#a92592142cb41364b6fe6ef9cc1a16dbd">M</a>) * lnfreqs);
<a name="l00577"></a>00577 
<a name="l00578"></a>00578   <span class="comment">// through each frequency</span>
<a name="l00579"></a>00579   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code" href="parse__mdl_8y.html#a7e98b8a17c0aad30ba64d47b74e2a6c1">i</a> = 0; <a class="code" href="parse__mdl_8y.html#a7e98b8a17c0aad30ba64d47b74e2a6c1">i</a> &lt; rfreqs.size (); <a class="code" href="parse__mdl_8y.html#a7e98b8a17c0aad30ba64d47b74e2a6c1">i</a>++) {
<a name="l00580"></a>00580     freq = rfreqs[<a class="code" href="parse__mdl_8y.html#a7e98b8a17c0aad30ba64d47b74e2a6c1">i</a>];
<a name="l00581"></a>00581     <span class="comment">// calculate components&#39; MNA matrix for the given frequency</span>
<a name="l00582"></a>00582     <span class="keywordflow">for</span> (<span class="keyword">auto</span> *lc : lincircuits)
<a name="l00583"></a>00583       lc-&gt;calcHB (freq);
<a name="l00584"></a>00584     <span class="comment">// fill in all matrix entries for the given frequency</span>
<a name="l00585"></a>00585     fillMatrixLinearA (<a class="code" href="eqndefined_8cpp.html#a70993d52766e31cb0157958a18aa499a">A</a>, f++);
<a name="l00586"></a>00586   }
<a name="l00587"></a>00587 
<a name="l00588"></a>00588   <span class="comment">// save a copy of the original MNA matrix</span>
<a name="l00589"></a>00589   NA = <span class="keyword">new</span> <a class="code" href="classqucs_1_1tmatrix.html">tmatrix&lt;nr_complex_t&gt;</a> (*A);
<a name="l00590"></a>00590 }
<a name="l00591"></a>00591 
<a name="l00592"></a>00592 <span class="comment">// some definitions for the linear matrix filler</span>
<a name="l00593"></a>00593 <span class="preprocessor">#undef  A_</span>
<a name="l00594"></a>00594 <span class="preprocessor"></span><span class="preprocessor">#undef  B_</span>
<a name="l00595"></a>00595 <span class="preprocessor"></span><span class="preprocessor">#define A_(r,c) (*A) ((r)*lnfreqs+f,(c)*lnfreqs+f)</span>
<a name="l00596"></a>00596 <span class="preprocessor"></span><span class="preprocessor">#define G_(r,c) A_(r,c)</span>
<a name="l00597"></a><a class="code" href="hbsolver_8cpp.html#a887200bfca5cd774e648565ca467f099">00597</a> <span class="preprocessor"></span><span class="preprocessor">#define B_(r,c) A_(r,c+N)</span>
<a name="l00598"></a>00598 <span class="preprocessor"></span><span class="preprocessor">#define C_(r,c) A_(r+N,c)</span>
<a name="l00599"></a><a class="code" href="hbsolver_8cpp.html#a00055f39672d0642f14b2309ee4606ee">00599</a> <span class="preprocessor"></span><span class="preprocessor">#define D_(r,c) A_(r+N,c+N)</span>
<a name="l00600"></a>00600 <span class="preprocessor"></span>
<a name="l00601"></a>00601 <span class="comment">/* This function fills in the MNA matrix entries into the A matrix for</span>
<a name="l00602"></a>00602 <span class="comment">   a given frequency index. */</span>
<a name="l00603"></a><a class="code" href="structqucs_1_1hbsolver.html#afac3c639a9a833d7239fc522a1962ca0">00603</a> <span class="keywordtype">void</span> hbsolver::fillMatrixLinearA (<a class="code" href="classqucs_1_1tmatrix.html">tmatrix&lt;nr_complex_t&gt;</a> * <a class="code" href="eqndefined_8cpp.html#a70993d52766e31cb0157958a18aa499a">A</a>, <span class="keywordtype">int</span> f) {
<a name="l00604"></a>00604   <span class="keywordtype">int</span> <a class="code" href="equation_8cpp.html#a540f72cb9bcf86a19e3bbc259b9ec3e0">N</a> = nnanodes;
<a name="l00605"></a>00605 
<a name="l00606"></a>00606   <span class="comment">// through each linear circuit</span>
<a name="l00607"></a>00607   <span class="keywordflow">for</span> (<span class="keyword">auto</span> *cir : lincircuits) {
<a name="l00608"></a>00608     <span class="keywordtype">int</span> s = cir-&gt;getSize ();
<a name="l00609"></a>00609     <span class="keywordtype">int</span> nr, nc, <a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>, <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>, <a class="code" href="parse__zvr_8y.html#ac4055e3a20b6b3af3d10590ea446ef6c">v</a>;
<a name="l00610"></a>00610 
<a name="l00611"></a>00611     <span class="comment">// apply G-matrix entries</span>
<a name="l00612"></a>00612     <span class="keywordflow">for</span> (r = 0; r &lt; s; r++) {
<a name="l00613"></a>00613       <span class="keywordflow">if</span> ((nr = cir-&gt;getNode(r)-&gt;getNode () - 1) &lt; 0) <span class="keywordflow">continue</span>;
<a name="l00614"></a>00614       <span class="keywordflow">for</span> (c = 0; c &lt; s; c++) {
<a name="l00615"></a>00615         <span class="keywordflow">if</span> ((nc = cir-&gt;getNode(c)-&gt;getNode () - 1) &lt; 0) <span class="keywordflow">continue</span>;
<a name="l00616"></a>00616         <a class="code" href="hbsolver_8cpp.html#a3c4c06c9bd84e38cea8343ca6e2f8e9c">G_</a>(nr, nc) += cir-&gt;getY (r, c);
<a name="l00617"></a>00617       }
<a name="l00618"></a>00618     }
<a name="l00619"></a>00619 
<a name="l00620"></a>00620     <span class="comment">// augmented part -- built in voltage sources</span>
<a name="l00621"></a>00621     <span class="keywordflow">if</span> ((v = cir-&gt;getVoltageSources ()) &gt; 0) {
<a name="l00622"></a>00622 
<a name="l00623"></a>00623       <span class="comment">// apply B-matrix entries</span>
<a name="l00624"></a>00624       <span class="keywordflow">for</span> (r = 0; r &lt; s; r++) {
<a name="l00625"></a>00625         <span class="keywordflow">if</span> ((nr = cir-&gt;getNode(r)-&gt;getNode () - 1) &lt; 0) <span class="keywordflow">continue</span>;
<a name="l00626"></a>00626         <span class="keywordflow">for</span> (c = 0; c &lt; <a class="code" href="parse__zvr_8y.html#ac4055e3a20b6b3af3d10590ea446ef6c">v</a>; c++) {
<a name="l00627"></a>00627           nc = cir-&gt;getVoltageSource () + <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>;
<a name="l00628"></a>00628           <a class="code" href="hbsolver_8cpp.html#a887200bfca5cd774e648565ca467f099">B_</a>(nr, nc) += cir-&gt;getB (r, nc);
<a name="l00629"></a>00629         }
<a name="l00630"></a>00630       }
<a name="l00631"></a>00631 
<a name="l00632"></a>00632       <span class="comment">// apply C-matrix entries</span>
<a name="l00633"></a>00633       <span class="keywordflow">for</span> (r = 0; r &lt; <a class="code" href="parse__zvr_8y.html#ac4055e3a20b6b3af3d10590ea446ef6c">v</a>; r++) {
<a name="l00634"></a>00634         nr = cir-&gt;getVoltageSource () + <a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>;
<a name="l00635"></a>00635         <span class="keywordflow">for</span> (c = 0; c &lt; s; c++) {
<a name="l00636"></a>00636           <span class="keywordflow">if</span> ((nc = cir-&gt;getNode(c)-&gt;getNode () - 1) &lt; 0) <span class="keywordflow">continue</span>;
<a name="l00637"></a>00637           <a class="code" href="hbsolver_8cpp.html#af8a6b6e3c0906dcdc18344f774469985">C_</a>(nr, nc) += cir-&gt;getC (nr, c);
<a name="l00638"></a>00638         }
<a name="l00639"></a>00639       }
<a name="l00640"></a>00640 
<a name="l00641"></a>00641       <span class="comment">// apply D-matrix entries</span>
<a name="l00642"></a>00642       <span class="keywordflow">for</span> (r = 0; r &lt; <a class="code" href="parse__zvr_8y.html#ac4055e3a20b6b3af3d10590ea446ef6c">v</a>; r++) {
<a name="l00643"></a>00643         nr = cir-&gt;getVoltageSource () + <a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>;
<a name="l00644"></a>00644         <span class="keywordflow">for</span> (c = 0; c &lt; <a class="code" href="parse__zvr_8y.html#ac4055e3a20b6b3af3d10590ea446ef6c">v</a>; c++) {
<a name="l00645"></a>00645           nc = cir-&gt;getVoltageSource () + <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>;
<a name="l00646"></a>00646           <a class="code" href="hbsolver_8cpp.html#a00055f39672d0642f14b2309ee4606ee">D_</a>(nr, nc) += cir-&gt;getD (nr, nc);
<a name="l00647"></a>00647         }
<a name="l00648"></a>00648       }
<a name="l00649"></a>00649     }
<a name="l00650"></a>00650   }
<a name="l00651"></a>00651 }
<a name="l00652"></a>00652 
<a name="l00653"></a>00653 <span class="comment">// The function inverts the given matrix A into the matrix H.</span>
<a name="l00654"></a><a class="code" href="structqucs_1_1hbsolver.html#a440def15fc8ad04f643b97425ea0377f">00654</a> <span class="keywordtype">void</span> hbsolver::invertMatrix (<a class="code" href="classqucs_1_1tmatrix.html">tmatrix&lt;nr_complex_t&gt;</a> * <a class="code" href="eqndefined_8cpp.html#a70993d52766e31cb0157958a18aa499a">A</a>,
<a name="l00655"></a>00655                              <a class="code" href="classqucs_1_1tmatrix.html">tmatrix&lt;nr_complex_t&gt;</a> * H) {
<a name="l00656"></a>00656   <a class="code" href="classqucs_1_1eqnsys.html">eqnsys&lt;nr_complex_t&gt;</a> <a class="code" href="parse__netlist_8y.html#aad664ad10957bf531dcce47612c7677a">eqns</a>;
<a name="l00657"></a>00657   <span class="keywordtype">int</span> <a class="code" href="equation_8cpp.html#a540f72cb9bcf86a19e3bbc259b9ec3e0">N</a> = A-&gt;<a class="code" href="classqucs_1_1tmatrix.html#a0a547e71f1d404f7bfe84e59f8a68002">getCols</a> ();
<a name="l00658"></a>00658   <a class="code" href="classqucs_1_1tvector.html">tvector&lt;nr_complex_t&gt;</a> * <a class="code" href="parse__mdl_8y.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a> = <span class="keyword">new</span> <a class="code" href="classqucs_1_1tvector.html">tvector&lt;nr_complex_t&gt;</a> (<a class="code" href="equation_8cpp.html#a540f72cb9bcf86a19e3bbc259b9ec3e0">N</a>);
<a name="l00659"></a>00659   <a class="code" href="classqucs_1_1tvector.html">tvector&lt;nr_complex_t&gt;</a> * z = <span class="keyword">new</span> <a class="code" href="classqucs_1_1tvector.html">tvector&lt;nr_complex_t&gt;</a> (<a class="code" href="equation_8cpp.html#a540f72cb9bcf86a19e3bbc259b9ec3e0">N</a>);
<a name="l00660"></a>00660 
<a name="l00661"></a>00661   <a class="code" href="exceptionstack_8h.html#a5123cac5cf3369997ae7bc31d5f1e1ce">try_running</a> () {
<a name="l00662"></a>00662     <span class="comment">// create LU decomposition of the A matrix</span>
<a name="l00663"></a>00663     eqns.<a class="code" href="classqucs_1_1eqnsys.html#a8f296af94985c93e84febc130bcd8901">setAlgo</a> (<a class="code" href="eqnsys_8h.html#a92b72228de8e945a7cbdf109a4e3c14fa29319b0957f7edc882b81af6a33df823">ALGO_LU_FACTORIZATION_CROUT</a>);
<a name="l00664"></a>00664     eqns.<a class="code" href="classqucs_1_1eqnsys.html#aa6b55148a64ff0e9b3afb8a7e76afae9">passEquationSys</a> (A, x, z);
<a name="l00665"></a>00665     eqns.<a class="code" href="classqucs_1_1eqnsys.html#a8c2dfc7e3116a729c92ec356bca70ad6">solve</a> ();
<a name="l00666"></a>00666   }
<a name="l00667"></a>00667   <span class="comment">// appropriate exception handling</span>
<a name="l00668"></a>00668   <a class="code" href="exceptionstack_8h.html#a1bcd5362715dd5fbe069fdf9f9b96399">catch_exception</a> () {
<a name="l00669"></a>00669   <span class="keywordflow">case</span> <a class="code" href="structqucs.html#ac060e999cf6725990fdd6c65600a62e5a732ab89ae14ddf9050b060b500c84177">EXCEPTION_PIVOT</a>:
<a name="l00670"></a>00670   <span class="keywordflow">default</span>:
<a name="l00671"></a>00671     <a class="code" href="logging_8c.html#abe06a8732a47a291606edcfac5e5146e">logprint</a> (<a class="code" href="logging_8h.html#aced66975c154ea0e2a8ec3bc818b4e08">LOG_ERROR</a>, <span class="stringliteral">&quot;WARNING: %s: during TI inversion\n&quot;</span>, getName ());
<a name="l00672"></a>00672     <a class="code" href="structqucs.html#a99a68a2452092cafcd735a48a064a8bf">estack</a>.<a class="code" href="classqucs_1_1exceptionstack.html#a486af86b492f662998c8d7ced9ecd64f">print</a> ();
<a name="l00673"></a>00673   }
<a name="l00674"></a>00674 
<a name="l00675"></a>00675   <span class="comment">// use the LU decomposition to obtain the inverse H</span>
<a name="l00676"></a>00676   eqns.<a class="code" href="classqucs_1_1eqnsys.html#a8f296af94985c93e84febc130bcd8901">setAlgo</a> (<a class="code" href="eqnsys_8h.html#a92b72228de8e945a7cbdf109a4e3c14fabbe28e4a870859123c42888212546ef9">ALGO_LU_SUBSTITUTION_CROUT</a>);
<a name="l00677"></a>00677   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a> = 0; <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a> &lt; <a class="code" href="equation_8cpp.html#a540f72cb9bcf86a19e3bbc259b9ec3e0">N</a>; <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>++) {
<a name="l00678"></a>00678     z-&gt;<a class="code" href="classqucs_1_1tvector.html#a0e3bc3de4b28ad95b779c6e054bf4c88">set</a> (0.0);
<a name="l00679"></a>00679     z-&gt;<a class="code" href="classqucs_1_1tvector.html#a0e3bc3de4b28ad95b779c6e054bf4c88">set</a> (<a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>, 1.0);
<a name="l00680"></a>00680     eqns.<a class="code" href="classqucs_1_1eqnsys.html#aa6b55148a64ff0e9b3afb8a7e76afae9">passEquationSys</a> (A, x, z);
<a name="l00681"></a>00681     eqns.<a class="code" href="classqucs_1_1eqnsys.html#a8c2dfc7e3116a729c92ec356bca70ad6">solve</a> ();
<a name="l00682"></a>00682     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a> = 0; <a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a> &lt; <a class="code" href="equation_8cpp.html#a540f72cb9bcf86a19e3bbc259b9ec3e0">N</a>; <a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>++) H-&gt;<a class="code" href="classqucs_1_1tmatrix.html#a7080db9380664dad648e86b6c4bda6c5">set</a> (<a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>, <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>, x-&gt;<a class="code" href="classqucs_1_1tvector.html#af20ce43427a811ccfd2e8b5e3b2378ba">get</a> (<a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>));
<a name="l00683"></a>00683   }
<a name="l00684"></a>00684   <span class="keyword">delete</span> <a class="code" href="parse__mdl_8y.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>;
<a name="l00685"></a>00685   <span class="keyword">delete</span> z;
<a name="l00686"></a>00686 }
<a name="l00687"></a>00687 
<a name="l00688"></a>00688 <span class="comment">// Some defines for matrix element access.</span>
<a name="l00689"></a><a class="code" href="hbsolver_8cpp.html#a1d582ab0a74305d73a8d52218c35d12e">00689</a> <span class="preprocessor">#define V_(r) (*V) (r)</span>
<a name="l00690"></a><a class="code" href="hbsolver_8cpp.html#acf616472cca1fa9706b90b01fcc36a7c">00690</a> <span class="preprocessor"></span><span class="preprocessor">#define I_(r) (*I) (r)</span>
<a name="l00691"></a>00691 <span class="preprocessor"></span><span class="preprocessor">#undef  A_</span>
<a name="l00692"></a><a class="code" href="hbsolver_8cpp.html#a48294a643811783458adca7c1ff45d26">00692</a> <span class="preprocessor"></span><span class="preprocessor">#define A_(r,c) (*A) (r,c)</span>
<a name="l00693"></a>00693 <span class="preprocessor"></span>
<a name="l00694"></a><a class="code" href="hbsolver_8cpp.html#abd9e8d821d0d9ded51f0a6d088b3fb05">00694</a> <span class="preprocessor">#define Z_(r,c) (*Z) (r,c)</span>
<a name="l00695"></a><a class="code" href="hbsolver_8cpp.html#a65b540c60db9fbef992309300a3007f3">00695</a> <span class="preprocessor"></span><span class="preprocessor">#define Y_(r,c) (*Y) (r,c)</span>
<a name="l00696"></a>00696 <span class="preprocessor"></span>
<a name="l00697"></a><a class="code" href="hbsolver_8cpp.html#a825371064298d564bf87021743bc81f0">00697</a> <span class="preprocessor">#define ZVU_(r,c) Z_(r,c)</span>
<a name="l00698"></a><a class="code" href="hbsolver_8cpp.html#a3c4daf2be1a136dd1297039a88912827">00698</a> <span class="preprocessor"></span><span class="preprocessor">#define ZVL_(r,c) Z_((r)*lnfreqs+f+sn,c)</span>
<a name="l00699"></a><a class="code" href="hbsolver_8cpp.html#acdba1b78d874e6aebe49a84ed8362afc">00699</a> <span class="preprocessor"></span><span class="preprocessor">#define ZCU_(r,c) Z_(r,(c)*lnfreqs+f+sn)</span>
<a name="l00700"></a><a class="code" href="hbsolver_8cpp.html#abc9c70f3ad5f66337a8231699cd5fb35">00700</a> <span class="preprocessor"></span><span class="preprocessor">#define ZCL_(r,c) Z_((r)*lnfreqs+f+sn,(c)*lnfreqs+f+sn)</span>
<a name="l00701"></a>00701 <span class="preprocessor"></span>
<a name="l00702"></a><a class="code" href="hbsolver_8cpp.html#ae2fd71cd95de6ab6fe18e211906882de">00702</a> <span class="preprocessor">#define YV_(r,c) (*YV) (r,c)</span>
<a name="l00703"></a><a class="code" href="hbsolver_8cpp.html#ad54c4b869aff6d7a44b4964aca70141b">00703</a> <span class="preprocessor"></span><span class="preprocessor">#define NA_(r,c) (*NA) (r,c)</span>
<a name="l00704"></a><a class="code" href="hbsolver_8cpp.html#a4354f165383797a1cea1b8e3f369f3c8">00704</a> <span class="preprocessor"></span><span class="preprocessor">#define JF_(r,c) (*JF) (r,c)</span>
<a name="l00705"></a>00705 <span class="preprocessor"></span>
<a name="l00706"></a>00706 <span class="comment">/* The following function performs the following steps:</span>
<a name="l00707"></a>00707 <span class="comment">   1. form the MNA matrix A including all nodes (linear, non-linear and</span>
<a name="l00708"></a>00708 <span class="comment">      excitations)</span>
<a name="l00709"></a>00709 <span class="comment">   2. compute the variable transimpedance matrix entries for the nodes</span>
<a name="l00710"></a>00710 <span class="comment">      to be balanced</span>
<a name="l00711"></a>00711 <span class="comment">   3. compute the constant transimpedance matrix entries for the constant</span>
<a name="l00712"></a>00712 <span class="comment">      current vector caused by the excitations</span>
<a name="l00713"></a>00713 <span class="comment">   4. invert this overall transimpedance matrix</span>
<a name="l00714"></a>00714 <span class="comment">   5. extract the variable transadmittance matrix entries</span>
<a name="l00715"></a>00715 <span class="comment">*/</span>
<a name="l00716"></a><a class="code" href="structqucs_1_1hbsolver.html#a4250ff5473d48b9d3ac3942c1e06a665">00716</a> <span class="keywordtype">void</span> hbsolver::createMatrixLinearY (<span class="keywordtype">void</span>) {
<a name="l00717"></a>00717   <span class="keywordtype">int</span> <a class="code" href="evaluate_8cpp.html#a92592142cb41364b6fe6ef9cc1a16dbd">M</a> = nlnvsrcs;
<a name="l00718"></a>00718   <span class="keywordtype">int</span> <a class="code" href="equation_8cpp.html#a540f72cb9bcf86a19e3bbc259b9ec3e0">N</a> = nnanodes;
<a name="l00719"></a>00719   <span class="keywordtype">int</span> <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>, <a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>, f;
<a name="l00720"></a>00720 
<a name="l00721"></a>00721   <span class="comment">// size of overall MNA matrix</span>
<a name="l00722"></a>00722   <span class="keywordtype">int</span> sa = (N + <a class="code" href="evaluate_8cpp.html#a92592142cb41364b6fe6ef9cc1a16dbd">M</a>) * lnfreqs;
<a name="l00723"></a>00723   <span class="keywordtype">int</span> sv = nbanodes;
<a name="l00724"></a>00724   <span class="keywordtype">int</span> se = nnlvsrcs;
<a name="l00725"></a>00725   <span class="keywordtype">int</span> sy = sv + se;
<a name="l00726"></a>00726 
<a name="l00727"></a>00727   <span class="comment">// allocate new transimpedance matrix</span>
<a name="l00728"></a>00728   Z = <span class="keyword">new</span> <a class="code" href="classqucs_1_1tmatrix.html">tmatrix&lt;nr_complex_t&gt;</a> (sy * lnfreqs);
<a name="l00729"></a>00729 
<a name="l00730"></a>00730   <span class="comment">// prepare equation system</span>
<a name="l00731"></a>00731   <a class="code" href="classqucs_1_1eqnsys.html">eqnsys&lt;nr_complex_t&gt;</a> <a class="code" href="parse__netlist_8y.html#aad664ad10957bf531dcce47612c7677a">eqns</a>;
<a name="l00732"></a>00732   <a class="code" href="classqucs_1_1tvector.html">tvector&lt;nr_complex_t&gt;</a> * <a class="code" href="evaluate_8cpp.html#a1bba8cd8d1268d1be05f381ef916bae0">V</a>;
<a name="l00733"></a>00733   <a class="code" href="classqucs_1_1tvector.html">tvector&lt;nr_complex_t&gt;</a> * I;
<a name="l00734"></a>00734 
<a name="l00735"></a>00735   <span class="comment">// 1. create variable transimpedance matrix entries relating</span>
<a name="l00736"></a>00736   <span class="comment">// voltages at the balanced nodes to the currents through these</span>
<a name="l00737"></a>00737   <span class="comment">// nodes into the non-linear part</span>
<a name="l00738"></a>00738   <span class="keywordtype">int</span> sn = sv * lnfreqs;
<a name="l00739"></a>00739   V = <span class="keyword">new</span> <a class="code" href="classqucs_1_1tvector.html">tvector&lt;nr_complex_t&gt;</a> (sa);
<a name="l00740"></a>00740   I = <span class="keyword">new</span> <a class="code" href="classqucs_1_1tvector.html">tvector&lt;nr_complex_t&gt;</a> (sa);
<a name="l00741"></a>00741 
<a name="l00742"></a>00742   <span class="comment">// connect a 100 Ohm resistor (to ground) to balanced node in the MNA matrix</span>
<a name="l00743"></a>00743   <span class="keywordflow">for</span> (c = 0; c &lt; sv * lnfreqs; c++) <a class="code" href="eqnsys_8cpp.html#a71700f5633db3f99b43c798b09c60bd2">A_</a>(c, c) += 0.01;
<a name="l00744"></a>00744 
<a name="l00745"></a>00745   <span class="comment">// connect a 100 Ohm resistor (in parallel) to each excitation</span>
<a name="l00746"></a>00746   <span class="keywordflow">for</span> (<span class="keyword">auto</span> *vs : excitations) {
<a name="l00747"></a>00747     <span class="comment">// get positive and negative node</span>
<a name="l00748"></a>00748     <span class="keywordtype">int</span> pnode = vs-&gt;getNode(<a class="code" href="circuit_8h.html#a4f0d36c5244b59c0f92e7704ac05647f">NODE_1</a>)-&gt;getNode ();
<a name="l00749"></a>00749     <span class="keywordtype">int</span> nnode = vs-&gt;getNode(<a class="code" href="circuit_8h.html#a6685ff6eaa6d17e48acf55cc8434eaed">NODE_2</a>)-&gt;getNode ();
<a name="l00750"></a>00750     <span class="keywordflow">for</span> (f = 0; f &lt; lnfreqs; f++) { <span class="comment">// for each frequency</span>
<a name="l00751"></a>00751       <span class="keywordtype">int</span> pn = (pnode - 1) * lnfreqs + f;
<a name="l00752"></a>00752       <span class="keywordtype">int</span> nn = (nnode - 1) * lnfreqs + f;
<a name="l00753"></a>00753       <span class="keywordflow">if</span> (pnode) <a class="code" href="eqnsys_8cpp.html#a71700f5633db3f99b43c798b09c60bd2">A_</a>(pn, pn) += 0.01;
<a name="l00754"></a>00754       <span class="keywordflow">if</span> (nnode) <a class="code" href="eqnsys_8cpp.html#a71700f5633db3f99b43c798b09c60bd2">A_</a>(nn, nn) += 0.01;
<a name="l00755"></a>00755       <span class="keywordflow">if</span> (pnode &amp;&amp; nnode) {
<a name="l00756"></a>00756         <a class="code" href="eqnsys_8cpp.html#a71700f5633db3f99b43c798b09c60bd2">A_</a>(pn, nn) -= 0.01;
<a name="l00757"></a>00757         <a class="code" href="eqnsys_8cpp.html#a71700f5633db3f99b43c798b09c60bd2">A_</a>(nn, pn) -= 0.01;
<a name="l00758"></a>00758       }
<a name="l00759"></a>00759     }
<a name="l00760"></a>00760   }
<a name="l00761"></a>00761 
<a name="l00762"></a>00762   <span class="comment">// LU decompose the MNA matrix</span>
<a name="l00763"></a>00763   <a class="code" href="exceptionstack_8h.html#a5123cac5cf3369997ae7bc31d5f1e1ce">try_running</a> () {
<a name="l00764"></a>00764     eqns.setAlgo (<a class="code" href="eqnsys_8h.html#a92b72228de8e945a7cbdf109a4e3c14fa29319b0957f7edc882b81af6a33df823">ALGO_LU_FACTORIZATION_CROUT</a>);
<a name="l00765"></a>00765     eqns.passEquationSys (<a class="code" href="eqndefined_8cpp.html#a70993d52766e31cb0157958a18aa499a">A</a>, V, I);
<a name="l00766"></a>00766     eqns.solve ();
<a name="l00767"></a>00767   }
<a name="l00768"></a>00768   <span class="comment">// appropriate exception handling</span>
<a name="l00769"></a>00769   <a class="code" href="exceptionstack_8h.html#a1bcd5362715dd5fbe069fdf9f9b96399">catch_exception</a> () {
<a name="l00770"></a>00770   <span class="keywordflow">case</span> <a class="code" href="structqucs.html#ac060e999cf6725990fdd6c65600a62e5a732ab89ae14ddf9050b060b500c84177">EXCEPTION_PIVOT</a>:
<a name="l00771"></a>00771   <span class="keywordflow">default</span>:
<a name="l00772"></a>00772     <a class="code" href="logging_8c.html#abe06a8732a47a291606edcfac5e5146e">logprint</a> (<a class="code" href="logging_8h.html#aced66975c154ea0e2a8ec3bc818b4e08">LOG_ERROR</a>, <span class="stringliteral">&quot;WARNING: %s: during A factorization\n&quot;</span>, getName ());
<a name="l00773"></a>00773     <a class="code" href="structqucs.html#a99a68a2452092cafcd735a48a064a8bf">estack</a>.<a class="code" href="classqucs_1_1exceptionstack.html#a486af86b492f662998c8d7ced9ecd64f">print</a> ();
<a name="l00774"></a>00774   }
<a name="l00775"></a>00775 
<a name="l00776"></a>00776   <span class="comment">// aquire variable transimpedance matrix entries</span>
<a name="l00777"></a>00777   eqns.setAlgo (<a class="code" href="eqnsys_8h.html#a92b72228de8e945a7cbdf109a4e3c14fabbe28e4a870859123c42888212546ef9">ALGO_LU_SUBSTITUTION_CROUT</a>);
<a name="l00778"></a>00778   <span class="keywordflow">for</span> (c = 0; c &lt; sn; c++) {
<a name="l00779"></a>00779     I-&gt;<a class="code" href="classqucs_1_1tvector.html#a0e3bc3de4b28ad95b779c6e054bf4c88">set</a> (0.0);
<a name="l00780"></a>00780     <a class="code" href="hbsolver_8cpp.html#acf616472cca1fa9706b90b01fcc36a7c">I_</a>(c) = 1.0;
<a name="l00781"></a>00781     eqns.passEquationSys (<a class="code" href="eqndefined_8cpp.html#a70993d52766e31cb0157958a18aa499a">A</a>, V, I);
<a name="l00782"></a>00782     eqns.solve ();
<a name="l00783"></a>00783     <span class="comment">// ZV | ..</span>
<a name="l00784"></a>00784     <span class="comment">// ---+---</span>
<a name="l00785"></a>00785     <span class="comment">// .. | ..</span>
<a name="l00786"></a>00786     <span class="keywordflow">for</span> (r = 0; r &lt; sn; r++) <a class="code" href="hbsolver_8cpp.html#a825371064298d564bf87021743bc81f0">ZVU_</a>(r, c) = <a class="code" href="hbsolver_8cpp.html#a1d582ab0a74305d73a8d52218c35d12e">V_</a>(r);
<a name="l00787"></a>00787     <span class="comment">// .. | ..</span>
<a name="l00788"></a>00788     <span class="comment">// ---+---</span>
<a name="l00789"></a>00789     <span class="comment">// ZV | ..</span>
<a name="l00790"></a>00790     r = 0;
<a name="l00791"></a>00791     <span class="keywordflow">for</span> (<span class="keyword">auto</span> *<a class="code" href="group__qucsMathConstants.html#gae162651ba6f0c9b150cf9bd8c41113c8" title="Euler&#39;s constant ( )">e</a> : excitations) {
<a name="l00792"></a>00792       <span class="comment">// lower part entries</span>
<a name="l00793"></a>00793       <span class="keywordflow">for</span> (f = 0; f &lt; lnfreqs; f++) {
<a name="l00794"></a>00794         <a class="code" href="hbsolver_8cpp.html#a3c4daf2be1a136dd1297039a88912827">ZVL_</a>(r, c) = excitationZ (V, <a class="code" href="group__qucsMathConstants.html#gae162651ba6f0c9b150cf9bd8c41113c8" title="Euler&#39;s constant ( )">e</a>, f);
<a name="l00795"></a>00795       }
<a name="l00796"></a>00796     }
<a name="l00797"></a>00797   }
<a name="l00798"></a>00798 
<a name="l00799"></a>00799   <span class="comment">// create constant transimpedance matrix entries relating the</span>
<a name="l00800"></a>00800   <span class="comment">// source voltages to the interconnection currents</span>
<a name="l00801"></a>00801   <span class="keywordtype">int</span> vsrc = 0;
<a name="l00802"></a>00802   <span class="comment">// aquire constant transadmittance matrix entries</span>
<a name="l00803"></a>00803   <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = excitations.begin(); it != excitations.end(); ++it, vsrc++) {
<a name="l00804"></a>00804     <a class="code" href="classqucs_1_1circuit.html" title="base class for qucs circuit elements.">circuit</a> * vs = *it;
<a name="l00805"></a>00805     <span class="comment">// get positive and negative node</span>
<a name="l00806"></a>00806     <span class="keywordtype">int</span> pnode = vs-&gt;<a class="code" href="classqucs_1_1circuit.html#a43a149197fa55e7ad1bd8e6b89f7e9d7">getNode</a>(<a class="code" href="circuit_8h.html#a4f0d36c5244b59c0f92e7704ac05647f">NODE_1</a>)-&gt;getNode ();
<a name="l00807"></a>00807     <span class="keywordtype">int</span> nnode = vs-&gt;<a class="code" href="classqucs_1_1circuit.html#a43a149197fa55e7ad1bd8e6b89f7e9d7">getNode</a>(<a class="code" href="circuit_8h.html#a6685ff6eaa6d17e48acf55cc8434eaed">NODE_2</a>)-&gt;getNode ();
<a name="l00808"></a>00808     <span class="keywordflow">for</span> (f = 0; f &lt; lnfreqs; f++) { <span class="comment">// for each frequency</span>
<a name="l00809"></a>00809       <span class="keywordtype">int</span> pn = (pnode - 1) * lnfreqs + f;
<a name="l00810"></a>00810       <span class="keywordtype">int</span> nn = (nnode - 1) * lnfreqs + f;
<a name="l00811"></a>00811       I-&gt;<a class="code" href="classqucs_1_1tvector.html#a0e3bc3de4b28ad95b779c6e054bf4c88">set</a> (0.0);
<a name="l00812"></a>00812       <span class="keywordflow">if</span> (pnode) <a class="code" href="hbsolver_8cpp.html#acf616472cca1fa9706b90b01fcc36a7c">I_</a>(pn) = +1.0;
<a name="l00813"></a>00813       <span class="keywordflow">if</span> (nnode) <a class="code" href="hbsolver_8cpp.html#acf616472cca1fa9706b90b01fcc36a7c">I_</a>(nn) = -1.0;
<a name="l00814"></a>00814       eqns.passEquationSys (<a class="code" href="eqndefined_8cpp.html#a70993d52766e31cb0157958a18aa499a">A</a>, V, I);
<a name="l00815"></a>00815       eqns.solve ();
<a name="l00816"></a>00816       <span class="comment">// .. | ZC</span>
<a name="l00817"></a>00817       <span class="comment">// ---+---</span>
<a name="l00818"></a>00818       <span class="comment">// .. | ..</span>
<a name="l00819"></a>00819       <span class="keywordflow">for</span> (r = 0; r &lt; sn; r++) {
<a name="l00820"></a>00820         <span class="comment">// upper part of the entries</span>
<a name="l00821"></a>00821         <a class="code" href="hbsolver_8cpp.html#acdba1b78d874e6aebe49a84ed8362afc">ZCU_</a>(r, vsrc) = <a class="code" href="hbsolver_8cpp.html#a1d582ab0a74305d73a8d52218c35d12e">V_</a>(r);
<a name="l00822"></a>00822       }
<a name="l00823"></a>00823       <span class="comment">// .. | ..</span>
<a name="l00824"></a>00824       <span class="comment">// ---+---</span>
<a name="l00825"></a>00825       <span class="comment">// .. | ZC</span>
<a name="l00826"></a>00826       r = 0;
<a name="l00827"></a>00827       <span class="keywordflow">for</span> (<span class="keyword">auto</span> ite = excitations.begin(); ite != excitations.end(); ++ite, r++) {
<a name="l00828"></a>00828         <span class="comment">// lower part entries</span>
<a name="l00829"></a>00829         <a class="code" href="hbsolver_8cpp.html#abc9c70f3ad5f66337a8231699cd5fb35">ZCL_</a>(r, vsrc) = excitationZ (V, *ite, f);
<a name="l00830"></a>00830       }
<a name="l00831"></a>00831     }
<a name="l00832"></a>00832   }
<a name="l00833"></a>00833   <span class="keyword">delete</span> I;
<a name="l00834"></a>00834   <span class="keyword">delete</span> <a class="code" href="evaluate_8cpp.html#a1bba8cd8d1268d1be05f381ef916bae0">V</a>;
<a name="l00835"></a>00835 
<a name="l00836"></a>00836   <span class="comment">// allocate new transadmittance matrix</span>
<a name="l00837"></a>00837   Y = <span class="keyword">new</span> <a class="code" href="classqucs_1_1tmatrix.html">tmatrix&lt;nr_complex_t&gt;</a> (sy * lnfreqs);
<a name="l00838"></a>00838 
<a name="l00839"></a>00839   <span class="comment">// invert the Z matrix to a Y matrix</span>
<a name="l00840"></a>00840   invertMatrix (Z, Y);
<a name="l00841"></a>00841 
<a name="l00842"></a>00842   <span class="comment">// substract the 100 Ohm resistor</span>
<a name="l00843"></a>00843   <span class="keywordflow">for</span> (c = 0; c &lt; sy * lnfreqs; c++) <a class="code" href="hbsolver_8cpp.html#a65b540c60db9fbef992309300a3007f3">Y_</a>(c, c) -= 0.01;
<a name="l00844"></a>00844 
<a name="l00845"></a>00845   <span class="comment">// extract the variable transadmittance matrix</span>
<a name="l00846"></a>00846   YV = <span class="keyword">new</span> <a class="code" href="classqucs_1_1tmatrix.html">tmatrix&lt;nr_complex_t&gt;</a> (sv * nlfreqs);
<a name="l00847"></a>00847 
<a name="l00848"></a>00848   <span class="comment">// variable transadmittance matrix must be continued conjugately</span>
<a name="l00849"></a>00849   *YV = expandMatrix (*Y, sv);
<a name="l00850"></a>00850 
<a name="l00851"></a>00851   <span class="comment">// delete overall temporary MNA matrix</span>
<a name="l00852"></a>00852   <span class="keyword">delete</span> <a class="code" href="eqndefined_8cpp.html#a70993d52766e31cb0157958a18aa499a">A</a>; <a class="code" href="eqndefined_8cpp.html#a70993d52766e31cb0157958a18aa499a">A</a> = NULL;
<a name="l00853"></a>00853   <span class="comment">// delete transimpedance matrix</span>
<a name="l00854"></a>00854   <span class="keyword">delete</span> Z; Z = NULL;
<a name="l00855"></a>00855 }
<a name="l00856"></a>00856 
<a name="l00857"></a>00857 <span class="comment">/* Little helper function obtaining a transimpedance value for the</span>
<a name="l00858"></a>00858 <span class="comment">   given voltage source (excitation) and for a given frequency</span>
<a name="l00859"></a>00859 <span class="comment">   index. */</span>
<a name="l00860"></a><a class="code" href="structqucs_1_1hbsolver.html#a9997413119b461565c9ccd8090539825">00860</a> <a class="code" href="complex_8h.html#a7ad1a12245ad87a9d81d6bcc18afacae">nr_complex_t</a> hbsolver::excitationZ (<a class="code" href="classqucs_1_1tvector.html">tvector&lt;nr_complex_t&gt;</a> * <a class="code" href="evaluate_8cpp.html#a1bba8cd8d1268d1be05f381ef916bae0">V</a>, <a class="code" href="classqucs_1_1circuit.html" title="base class for qucs circuit elements.">circuit</a> * vs,
<a name="l00861"></a>00861                                     <span class="keywordtype">int</span> f) {
<a name="l00862"></a>00862   <span class="comment">// get positive and negative node</span>
<a name="l00863"></a>00863   <span class="keywordtype">int</span> pnode = vs-&gt;<a class="code" href="classqucs_1_1circuit.html#a43a149197fa55e7ad1bd8e6b89f7e9d7">getNode</a>(<a class="code" href="circuit_8h.html#a4f0d36c5244b59c0f92e7704ac05647f">NODE_1</a>)-&gt;getNode ();
<a name="l00864"></a>00864   <span class="keywordtype">int</span> nnode = vs-&gt;<a class="code" href="classqucs_1_1circuit.html#a43a149197fa55e7ad1bd8e6b89f7e9d7">getNode</a>(<a class="code" href="circuit_8h.html#a6685ff6eaa6d17e48acf55cc8434eaed">NODE_2</a>)-&gt;getNode ();
<a name="l00865"></a>00865   <a class="code" href="complex_8h.html#a7ad1a12245ad87a9d81d6bcc18afacae">nr_complex_t</a> z = 0.0;
<a name="l00866"></a>00866   <span class="keywordflow">if</span> (pnode) z += <a class="code" href="hbsolver_8cpp.html#a1d582ab0a74305d73a8d52218c35d12e">V_</a>((pnode - 1) * lnfreqs + f);
<a name="l00867"></a>00867   <span class="keywordflow">if</span> (nnode) z -= <a class="code" href="hbsolver_8cpp.html#a1d582ab0a74305d73a8d52218c35d12e">V_</a>((nnode - 1) * lnfreqs + f);
<a name="l00868"></a>00868   <span class="keywordflow">return</span> z;
<a name="l00869"></a>00869 }
<a name="l00870"></a>00870 
<a name="l00871"></a>00871 <span class="comment">/* This function computes the constant current vectors using the</span>
<a name="l00872"></a>00872 <span class="comment">   voltage of the excitations and the transadmittance matrix</span>
<a name="l00873"></a>00873 <span class="comment">   entries. */</span>
<a name="l00874"></a><a class="code" href="structqucs_1_1hbsolver.html#af4021cb397d14986526ee4db99cbb020">00874</a> <span class="keywordtype">void</span> hbsolver::calcConstantCurrent (<span class="keywordtype">void</span>) {
<a name="l00875"></a>00875   <span class="keywordtype">int</span> se = nnlvsrcs * lnfreqs;
<a name="l00876"></a>00876   <span class="keywordtype">int</span> sn = nbanodes * lnfreqs;
<a name="l00877"></a>00877   <span class="keywordtype">int</span> <a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>, <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>, vsrc = 0;
<a name="l00878"></a>00878 
<a name="l00879"></a>00879   <span class="comment">// collect excitation voltages</span>
<a name="l00880"></a>00880   <a class="code" href="classqucs_1_1tvector.html">tvector&lt;nr_complex_t&gt;</a> VC (se);
<a name="l00881"></a>00881   <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = excitations.begin(); it != excitations.end(); ++it, vsrc++) {
<a name="l00882"></a>00882     <a class="code" href="classqucs_1_1circuit.html" title="base class for qucs circuit elements.">circuit</a> * vs = *it;
<a name="l00883"></a>00883     vs-&gt;<a class="code" href="classqucs_1_1circuit.html#a077cee08be342a784c9052f97f67b3b6">initHB</a> ();
<a name="l00884"></a>00884     vs-&gt;<a class="code" href="classqucs_1_1circuit.html#a4f5f480b4595914038440075a8927669">setVoltageSource</a> (0);
<a name="l00885"></a>00885     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> f = 0; f &lt; rfreqs.size (); f++) { <span class="comment">// for each frequency</span>
<a name="l00886"></a>00886       <a class="code" href="config_8h.html#a014aadc409afb297b8247c13f8ca89be">nr_double_t</a> freq = rfreqs[f];
<a name="l00887"></a>00887       vs-&gt;<a class="code" href="classqucs_1_1circuit.html#aa9a3082dbe1905f4bd0b9284a2cf80b3">calcHB</a> (freq);
<a name="l00888"></a>00888       VC (vsrc * lnfreqs + f) = vs-&gt;<a class="code" href="classqucs_1_1circuit.html#a502a0288b7cdae7d24853590eb3eb8cd">getE</a> (<a class="code" href="circuit_8h.html#ace17100f8a8b6ff4abc3f9d5d1bd38b8">VSRC_1</a>);
<a name="l00889"></a>00889     }
<a name="l00890"></a>00890   }
<a name="l00891"></a>00891 
<a name="l00892"></a>00892   <span class="comment">// compute constant current vector for balanced nodes</span>
<a name="l00893"></a>00893   IC = <span class="keyword">new</span> <a class="code" href="classqucs_1_1tvector.html">tvector&lt;nr_complex_t&gt;</a> (sn);
<a name="l00894"></a>00894   <span class="comment">// .. | YC * VC</span>
<a name="l00895"></a>00895   <span class="comment">// ---+---</span>
<a name="l00896"></a>00896   <span class="comment">// .. | ..</span>
<a name="l00897"></a>00897   <span class="keywordflow">for</span> (r = 0; r &lt; sn; r++) {
<a name="l00898"></a>00898     <a class="code" href="complex_8h.html#a7ad1a12245ad87a9d81d6bcc18afacae">nr_complex_t</a> <a class="code" href="parse__mdl_8y.html#a7e98b8a17c0aad30ba64d47b74e2a6c1">i</a> = 0.0;
<a name="l00899"></a>00899     <span class="keywordflow">for</span> (c = 0; c &lt; se; c++) {
<a name="l00900"></a>00900       i += <a class="code" href="hbsolver_8cpp.html#a65b540c60db9fbef992309300a3007f3">Y_</a>(r, c + sn) * VC (c);
<a name="l00901"></a>00901     }
<a name="l00902"></a>00902     <span class="keywordtype">int</span> f = r % lnfreqs;
<a name="l00903"></a>00903     <span class="keywordflow">if</span> (f != 0 &amp;&amp; f != lnfreqs - 1) i /= 2;
<a name="l00904"></a>00904     IC-&gt;set (r, i);
<a name="l00905"></a>00905   }
<a name="l00906"></a>00906   <span class="comment">// expand the constant current conjugate</span>
<a name="l00907"></a>00907   *IC = expandVector (*IC, nbanodes);
<a name="l00908"></a>00908 
<a name="l00909"></a>00909   <span class="comment">// compute constant current vector for sources itself</span>
<a name="l00910"></a>00910   IS = <span class="keyword">new</span> <a class="code" href="classqucs_1_1tvector.html">tvector&lt;nr_complex_t&gt;</a> (se);
<a name="l00911"></a>00911   <span class="comment">// .. | ..</span>
<a name="l00912"></a>00912   <span class="comment">// ---+---</span>
<a name="l00913"></a>00913   <span class="comment">// .. | YC * VC</span>
<a name="l00914"></a>00914   <span class="keywordflow">for</span> (r = 0; r &lt; se; r++) {
<a name="l00915"></a>00915     <a class="code" href="complex_8h.html#a7ad1a12245ad87a9d81d6bcc18afacae">nr_complex_t</a> <a class="code" href="parse__mdl_8y.html#a7e98b8a17c0aad30ba64d47b74e2a6c1">i</a> = 0.0;
<a name="l00916"></a>00916     <span class="keywordflow">for</span> (c = 0; c &lt; se; c++) {
<a name="l00917"></a>00917       i += <a class="code" href="hbsolver_8cpp.html#a65b540c60db9fbef992309300a3007f3">Y_</a>(r + sn, c + sn) * VC (c);
<a name="l00918"></a>00918     }
<a name="l00919"></a>00919     IS-&gt;set (r, i);
<a name="l00920"></a>00920   }
<a name="l00921"></a>00921 
<a name="l00922"></a>00922   <span class="comment">// delete overall transadmittance matrix</span>
<a name="l00923"></a>00923   <span class="keyword">delete</span> Y; Y = NULL;
<a name="l00924"></a>00924 }
<a name="l00925"></a>00925 
<a name="l00926"></a>00926 <span class="comment">/* Checks whether currents through the interconnects of the linear and</span>
<a name="l00927"></a>00927 <span class="comment">   non-linear subcircuit (in the frequency domain) are equal. */</span>
<a name="l00928"></a><a class="code" href="structqucs_1_1hbsolver.html#a96344ebd267130623bd70776d738865c">00928</a> <span class="keywordtype">int</span> hbsolver::checkBalance (<span class="keywordtype">void</span>) {
<a name="l00929"></a>00929   <a class="code" href="config_8h.html#a014aadc409afb297b8247c13f8ca89be">nr_double_t</a> iabstol = getPropertyDouble (<span class="stringliteral">&quot;iabstol&quot;</span>);
<a name="l00930"></a>00930   <a class="code" href="config_8h.html#a014aadc409afb297b8247c13f8ca89be">nr_double_t</a> vabstol = getPropertyDouble (<span class="stringliteral">&quot;vabstol&quot;</span>);
<a name="l00931"></a>00931   <a class="code" href="config_8h.html#a014aadc409afb297b8247c13f8ca89be">nr_double_t</a> reltol = getPropertyDouble (<span class="stringliteral">&quot;reltol&quot;</span>);
<a name="l00932"></a>00932   <span class="keywordtype">int</span> <a class="code" href="parse__mdl_8y.html#aecba4cab5e52994730d1e21424997b33">n</a>, len = FV-&gt;size ();
<a name="l00933"></a>00933   <span class="keywordflow">for</span> (n = 0; n &lt; len; n++) {
<a name="l00934"></a>00934     <span class="comment">// check iteration voltages</span>
<a name="l00935"></a>00935     <a class="code" href="config_8h.html#a014aadc409afb297b8247c13f8ca89be">nr_double_t</a> v_abs = <a class="code" href="namespacequcs.html#ae19977dcd124dcf020fd21b46cf92e2f" title="Computes magnitude of each matrix element.">abs</a> (VS-&gt;get (n) - VP-&gt;get (n));
<a name="l00936"></a>00936     <a class="code" href="config_8h.html#a014aadc409afb297b8247c13f8ca89be">nr_double_t</a> v_rel = <a class="code" href="namespacequcs.html#ae19977dcd124dcf020fd21b46cf92e2f" title="Computes magnitude of each matrix element.">abs</a> (VS-&gt;get (n));
<a name="l00937"></a>00937     <span class="keywordflow">if</span> (v_abs &gt;= vabstol + reltol * v_rel) <span class="keywordflow">return</span> 0;
<a name="l00938"></a>00938     <span class="comment">// check balanced currents</span>
<a name="l00939"></a>00939     <a class="code" href="complex_8h.html#a7ad1a12245ad87a9d81d6bcc18afacae">nr_complex_t</a> il = IL-&gt;get (n);
<a name="l00940"></a>00940     <a class="code" href="complex_8h.html#a7ad1a12245ad87a9d81d6bcc18afacae">nr_complex_t</a> in = IN-&gt;get (n);
<a name="l00941"></a>00941     <span class="keywordflow">if</span> (il != in) {
<a name="l00942"></a>00942       <a class="code" href="config_8h.html#a014aadc409afb297b8247c13f8ca89be">nr_double_t</a> i_abs = <a class="code" href="namespacequcs.html#ae19977dcd124dcf020fd21b46cf92e2f" title="Computes magnitude of each matrix element.">abs</a> (il + in);
<a name="l00943"></a>00943       <a class="code" href="config_8h.html#a014aadc409afb297b8247c13f8ca89be">nr_double_t</a> i_rel = <a class="code" href="namespacequcs.html#ae19977dcd124dcf020fd21b46cf92e2f" title="Computes magnitude of each matrix element.">abs</a> ((il + in) / (il - in));
<a name="l00944"></a>00944       <span class="keywordflow">if</span> (i_abs &gt;= iabstol &amp;&amp; 2.0 * i_rel &gt;= reltol) <span class="keywordflow">return</span> 0;
<a name="l00945"></a>00945     }
<a name="l00946"></a>00946   }
<a name="l00947"></a>00947   <span class="keywordflow">return</span> 1;
<a name="l00948"></a>00948 }
<a name="l00949"></a>00949 
<a name="l00950"></a>00950 <span class="comment">// some definitions for the non-linear matrix filler</span>
<a name="l00951"></a>00951 <span class="preprocessor">#undef  G_</span>
<a name="l00952"></a>00952 <span class="preprocessor"></span><span class="preprocessor">#undef  C_</span>
<a name="l00953"></a><a class="code" href="hbsolver_8cpp.html#a3c4c06c9bd84e38cea8343ca6e2f8e9c">00953</a> <span class="preprocessor"></span><span class="preprocessor">#define G_(r,c) (*jg) ((r)*nlfreqs+f,(c)*nlfreqs+f)</span>
<a name="l00954"></a><a class="code" href="hbsolver_8cpp.html#af8a6b6e3c0906dcdc18344f774469985">00954</a> <span class="preprocessor"></span><span class="preprocessor">#define C_(r,c) (*jq) ((r)*nlfreqs+f,(c)*nlfreqs+f)</span>
<a name="l00955"></a>00955 <span class="preprocessor"></span><span class="preprocessor">#undef  FI_</span>
<a name="l00956"></a>00956 <span class="preprocessor"></span><span class="preprocessor">#undef  FQ_</span>
<a name="l00957"></a><a class="code" href="hbsolver_8cpp.html#a87fd6f836693ded8097a64e8ecde6cee">00957</a> <span class="preprocessor"></span><span class="preprocessor">#define FI_(r) (*ig) ((r)*nlfreqs+f)</span>
<a name="l00958"></a><a class="code" href="hbsolver_8cpp.html#a7122af8874a8ef79e4b750c2dd20ed77">00958</a> <span class="preprocessor"></span><span class="preprocessor">#define FQ_(r) (*fq) ((r)*nlfreqs+f)</span>
<a name="l00959"></a><a class="code" href="hbsolver_8cpp.html#ad9fe64e4271224d2af966272247cb4c9">00959</a> <span class="preprocessor"></span><span class="preprocessor">#define IR_(r) (*ir) ((r)*nlfreqs+f)</span>
<a name="l00960"></a><a class="code" href="hbsolver_8cpp.html#acf43fcfa7cbc4e905ebef3c32c738121">00960</a> <span class="preprocessor"></span><span class="preprocessor">#define QR_(r) (*qr) ((r)*nlfreqs+f)</span>
<a name="l00961"></a>00961 <span class="preprocessor"></span>
<a name="l00962"></a>00962 <span class="comment">/* This function fills in the matrix and vector entries for the</span>
<a name="l00963"></a>00963 <span class="comment">   non-linear HB equations for a given frequency index. */</span>
<a name="l00964"></a><a class="code" href="structqucs_1_1hbsolver.html#a6486946471f30483e55283fca9e92244">00964</a> <span class="keywordtype">void</span> hbsolver::fillMatrixNonLinear (<a class="code" href="classqucs_1_1tmatrix.html">tmatrix&lt;nr_complex_t&gt;</a> * jg,
<a name="l00965"></a>00965                                     <a class="code" href="classqucs_1_1tmatrix.html">tmatrix&lt;nr_complex_t&gt;</a> * jq,
<a name="l00966"></a>00966                                     <a class="code" href="classqucs_1_1tvector.html">tvector&lt;nr_complex_t&gt;</a> * ig,
<a name="l00967"></a>00967                                     <a class="code" href="classqucs_1_1tvector.html">tvector&lt;nr_complex_t&gt;</a> * fq,
<a name="l00968"></a>00968                                     <a class="code" href="classqucs_1_1tvector.html">tvector&lt;nr_complex_t&gt;</a> * ir,
<a name="l00969"></a>00969                                     <a class="code" href="classqucs_1_1tvector.html">tvector&lt;nr_complex_t&gt;</a> * qr,
<a name="l00970"></a>00970                                     <span class="keywordtype">int</span> f) {
<a name="l00971"></a>00971   <span class="comment">// through each linear circuit</span>
<a name="l00972"></a>00972   <span class="keywordflow">for</span> (<span class="keyword">auto</span> *cir: nolcircuits) {
<a name="l00973"></a>00973     <span class="keywordtype">int</span> s = cir-&gt;getSize ();
<a name="l00974"></a>00974     <span class="keywordtype">int</span> nr, nc, <a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>, <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>;
<a name="l00975"></a>00975 
<a name="l00976"></a>00976     <span class="keywordflow">for</span> (r = 0; r &lt; s; r++) {
<a name="l00977"></a>00977       <span class="keywordflow">if</span> ((nr = cir-&gt;getNode(r)-&gt;getNode () - 1) &lt; 0) <span class="keywordflow">continue</span>;
<a name="l00978"></a>00978       <span class="comment">// apply G- and C-matrix entries</span>
<a name="l00979"></a>00979       <span class="keywordflow">for</span> (c = 0; c &lt; s; c++) {
<a name="l00980"></a>00980         <span class="keywordflow">if</span> ((nc = cir-&gt;getNode(c)-&gt;getNode () - 1) &lt; 0) <span class="keywordflow">continue</span>;
<a name="l00981"></a>00981         <a class="code" href="hbsolver_8cpp.html#a3c4c06c9bd84e38cea8343ca6e2f8e9c">G_</a>(nr, nc) += cir-&gt;getY (r, c);
<a name="l00982"></a>00982         <a class="code" href="hbsolver_8cpp.html#af8a6b6e3c0906dcdc18344f774469985">C_</a>(nr, nc) += cir-&gt;getQV (r, c);
<a name="l00983"></a>00983       }
<a name="l00984"></a>00984       <span class="comment">// apply I- and Q-vector entries</span>
<a name="l00985"></a>00985       <a class="code" href="hbsolver_8cpp.html#a87fd6f836693ded8097a64e8ecde6cee">FI_</a>(nr) -= cir-&gt;getI (r);
<a name="l00986"></a>00986       <a class="code" href="hbsolver_8cpp.html#a7122af8874a8ef79e4b750c2dd20ed77">FQ_</a>(nr) -= cir-&gt;getQ (r);
<a name="l00987"></a>00987       <span class="comment">// ThinkME: positive or negative?</span>
<a name="l00988"></a>00988       <a class="code" href="hbsolver_8cpp.html#ad9fe64e4271224d2af966272247cb4c9">IR_</a>(nr) += cir-&gt;getGV (r) + cir-&gt;getI (r);
<a name="l00989"></a>00989       <a class="code" href="hbsolver_8cpp.html#acf43fcfa7cbc4e905ebef3c32c738121">QR_</a>(nr) += cir-&gt;getCV (r) + cir-&gt;getQ (r);
<a name="l00990"></a>00990     }
<a name="l00991"></a>00991   }
<a name="l00992"></a>00992 }
<a name="l00993"></a>00993 
<a name="l00994"></a>00994 <span class="comment">/* The function initializes the non-linear part of the HB. */</span>
<a name="l00995"></a><a class="code" href="structqucs_1_1hbsolver.html#ab71a99c6ec69173941ce176527fd24e3">00995</a> <span class="keywordtype">void</span> hbsolver::prepareNonLinear (<span class="keywordtype">void</span>) {
<a name="l00996"></a>00996   <span class="keywordtype">int</span> <a class="code" href="equation_8cpp.html#a540f72cb9bcf86a19e3bbc259b9ec3e0">N</a> = nbanodes;
<a name="l00997"></a>00997 
<a name="l00998"></a>00998   <span class="comment">// allocate matrices and vectors</span>
<a name="l00999"></a>00999   <span class="keywordflow">if</span> (FQ == NULL) {
<a name="l01000"></a>01000     FQ = <span class="keyword">new</span> <a class="code" href="classqucs_1_1tvector.html">tvector&lt;nr_complex_t&gt;</a> (N * nlfreqs);
<a name="l01001"></a>01001   }
<a name="l01002"></a>01002   <span class="keywordflow">if</span> (IG == NULL) {
<a name="l01003"></a>01003     IG = <span class="keyword">new</span> <a class="code" href="classqucs_1_1tvector.html">tvector&lt;nr_complex_t&gt;</a> (N * nlfreqs);
<a name="l01004"></a>01004   }
<a name="l01005"></a>01005   <span class="keywordflow">if</span> (IR == NULL) {
<a name="l01006"></a>01006     IR = <span class="keyword">new</span> <a class="code" href="classqucs_1_1tvector.html">tvector&lt;nr_complex_t&gt;</a> (N * nlfreqs);
<a name="l01007"></a>01007   }
<a name="l01008"></a>01008   <span class="keywordflow">if</span> (QR == NULL) {
<a name="l01009"></a>01009     QR = <span class="keyword">new</span> <a class="code" href="classqucs_1_1tvector.html">tvector&lt;nr_complex_t&gt;</a> (N * nlfreqs);
<a name="l01010"></a>01010   }
<a name="l01011"></a>01011   <span class="keywordflow">if</span> (JG == NULL) {
<a name="l01012"></a>01012     JG = <span class="keyword">new</span> <a class="code" href="classqucs_1_1tmatrix.html">tmatrix&lt;nr_complex_t&gt;</a> (N * nlfreqs);
<a name="l01013"></a>01013   }
<a name="l01014"></a>01014   <span class="keywordflow">if</span> (JQ == NULL) {
<a name="l01015"></a>01015     JQ = <span class="keyword">new</span> <a class="code" href="classqucs_1_1tmatrix.html">tmatrix&lt;nr_complex_t&gt;</a> (N * nlfreqs);
<a name="l01016"></a>01016   }
<a name="l01017"></a>01017   <span class="keywordflow">if</span> (JF == NULL) {
<a name="l01018"></a>01018     JF = <span class="keyword">new</span> <a class="code" href="classqucs_1_1tmatrix.html">tmatrix&lt;nr_complex_t&gt;</a> (N * nlfreqs);
<a name="l01019"></a>01019   }
<a name="l01020"></a>01020 
<a name="l01021"></a>01021   <span class="comment">// voltage vector in frequency and time domain</span>
<a name="l01022"></a>01022   <span class="keywordflow">if</span> (VS == NULL) {
<a name="l01023"></a>01023     VS = <span class="keyword">new</span> <a class="code" href="classqucs_1_1tvector.html">tvector&lt;nr_complex_t&gt;</a> (N * nlfreqs);
<a name="l01024"></a>01024   }
<a name="l01025"></a>01025   <span class="keywordflow">if</span> (vs == NULL) {
<a name="l01026"></a>01026     vs = <span class="keyword">new</span> <a class="code" href="classqucs_1_1tvector.html">tvector&lt;nr_complex_t&gt;</a> (N * nlfreqs);
<a name="l01027"></a>01027   }
<a name="l01028"></a>01028   <span class="keywordflow">if</span> (VP == NULL) {
<a name="l01029"></a>01029     VP = <span class="keyword">new</span> <a class="code" href="classqucs_1_1tvector.html">tvector&lt;nr_complex_t&gt;</a> (N * nlfreqs);
<a name="l01030"></a>01030   }
<a name="l01031"></a>01031 
<a name="l01032"></a>01032   <span class="comment">// error vector</span>
<a name="l01033"></a>01033   <span class="keywordflow">if</span> (FV == NULL) {
<a name="l01034"></a>01034     FV = <span class="keyword">new</span> <a class="code" href="classqucs_1_1tvector.html">tvector&lt;nr_complex_t&gt;</a> (N * nlfreqs);
<a name="l01035"></a>01035   }
<a name="l01036"></a>01036   <span class="comment">// right hand side vector</span>
<a name="l01037"></a>01037   <span class="keywordflow">if</span> (RH == NULL) {
<a name="l01038"></a>01038     RH = <span class="keyword">new</span> <a class="code" href="classqucs_1_1tvector.html">tvector&lt;nr_complex_t&gt;</a> (N * nlfreqs);
<a name="l01039"></a>01039   }
<a name="l01040"></a>01040 
<a name="l01041"></a>01041   <span class="comment">// linear and non-linear current vector</span>
<a name="l01042"></a>01042   <span class="keywordflow">if</span> (IL == NULL) {
<a name="l01043"></a>01043     IL = <span class="keyword">new</span> <a class="code" href="classqucs_1_1tvector.html">tvector&lt;nr_complex_t&gt;</a> (N * nlfreqs);
<a name="l01044"></a>01044   }
<a name="l01045"></a>01045   <span class="keywordflow">if</span> (IN == NULL) {
<a name="l01046"></a>01046     IN = <span class="keyword">new</span> <a class="code" href="classqucs_1_1tvector.html">tvector&lt;nr_complex_t&gt;</a> (N * nlfreqs);
<a name="l01047"></a>01047   }
<a name="l01048"></a>01048 
<a name="l01049"></a>01049   <span class="comment">// assign nodes</span>
<a name="l01050"></a>01050   assignNodes (nolcircuits, nanodes);
<a name="l01051"></a>01051 
<a name="l01052"></a>01052   <span class="comment">// initialize circuits</span>
<a name="l01053"></a>01053   <span class="keywordflow">for</span> (<span class="keyword">auto</span> *cir : nolcircuits) {
<a name="l01054"></a>01054     cir-&gt;initHB (nlfreqs);
<a name="l01055"></a>01055   }
<a name="l01056"></a>01056 }
<a name="l01057"></a>01057 
<a name="l01058"></a>01058 <span class="comment">/* Saves the node voltages of the given circuit and for the given</span>
<a name="l01059"></a>01059 <span class="comment">   frequency entry into the circuit voltage vector. */</span>
<a name="l01060"></a><a class="code" href="structqucs_1_1hbsolver.html#a44a01ec3d81ba5b107b3d14bba39aad2">01060</a> <span class="keywordtype">void</span> hbsolver::saveNodeVoltages (<a class="code" href="classqucs_1_1circuit.html" title="base class for qucs circuit elements.">circuit</a> * cir, <span class="keywordtype">int</span> f) {
<a name="l01061"></a>01061   <span class="keywordtype">int</span> <a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>, nr, s = cir-&gt;<a class="code" href="classqucs_1_1circuit.html#aed2de3b676324a1c1ded4e0f3c6025a4" title="Get the number of ports the circuit element has.">getSize</a> ();
<a name="l01062"></a>01062   <span class="keywordflow">for</span> (r = 0; r &lt; s; r++) {
<a name="l01063"></a>01063     <span class="keywordflow">if</span> ((nr = cir-&gt;<a class="code" href="classqucs_1_1circuit.html#a43a149197fa55e7ad1bd8e6b89f7e9d7">getNode</a>(r)-&gt;getNode () - 1) &lt; 0) <span class="keywordflow">continue</span>;
<a name="l01064"></a>01064     <span class="comment">// apply V-vector entries</span>
<a name="l01065"></a>01065     cir-&gt;<a class="code" href="classqucs_1_1circuit.html#a89c1f2e9419738da75012f45193322b4">setV</a> (r, <a class="code" href="namespacequcs.html#a0cc73c27d7d13b2200f2fddbb064dce6" title="Real part matrix.">real</a> (vs-&gt;get (nr * nlfreqs + f)));
<a name="l01066"></a>01066   }
<a name="l01067"></a>01067 }
<a name="l01068"></a>01068 
<a name="l01069"></a>01069 <span class="comment">/* The function saves voltages into non-linear circuits, runs each</span>
<a name="l01070"></a>01070 <span class="comment">   non-linear components&#39; HB calculator for each frequency and applies</span>
<a name="l01071"></a>01071 <span class="comment">   the matrix and vector entries appropriately. */</span>
<a name="l01072"></a><a class="code" href="structqucs_1_1hbsolver.html#a29243fb7050abd07294fee059ee31513">01072</a> <span class="keywordtype">void</span> hbsolver::loadMatrices (<span class="keywordtype">void</span>) {
<a name="l01073"></a>01073   <span class="comment">// clear matrices and vectors before</span>
<a name="l01074"></a>01074   IG-&gt;set (0.0);
<a name="l01075"></a>01075   FQ-&gt;set (0.0);
<a name="l01076"></a>01076   IR-&gt;set (0.0);
<a name="l01077"></a>01077   QR-&gt;set (0.0);
<a name="l01078"></a>01078   JG-&gt;set (0.0);
<a name="l01079"></a>01079   JQ-&gt;set (0.0);
<a name="l01080"></a>01080   <span class="comment">// through each frequency</span>
<a name="l01081"></a>01081   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> f = 0; f &lt; nlfreqs; f++) {
<a name="l01082"></a>01082     <span class="comment">// calculate components&#39; HB matrices and vector for the given frequency</span>
<a name="l01083"></a>01083     <span class="keywordflow">for</span> (<span class="keyword">auto</span> *cir : nolcircuits) {
<a name="l01084"></a>01084       saveNodeVoltages (cir, f); <span class="comment">// node voltages</span>
<a name="l01085"></a>01085       cir-&gt;calcHB (f);         <span class="comment">// HB calculator</span>
<a name="l01086"></a>01086     }
<a name="l01087"></a>01087     <span class="comment">// fill in all matrix entries for the given frequency</span>
<a name="l01088"></a>01088     fillMatrixNonLinear (JG, JQ, IG, FQ, IR, QR, f);
<a name="l01089"></a>01089   }
<a name="l01090"></a>01090 }
<a name="l01091"></a>01091 
<a name="l01092"></a>01092 <span class="comment">/* The following function transforms a vector using a Fast Fourier</span>
<a name="l01093"></a>01093 <span class="comment">   Transformation from the time domain to the frequency domain. </span>
<a name="l01094"></a>01094 <span class="comment">   \todo rewrite ugly sould die</span>
<a name="l01095"></a>01095 <span class="comment">*/</span>
<a name="l01096"></a><a class="code" href="structqucs_1_1hbsolver.html#a99422ac1552a33aae12bce075def3881">01096</a> <span class="keywordtype">void</span> hbsolver::VectorFFT (<a class="code" href="classqucs_1_1tvector.html">tvector&lt;nr_complex_t&gt;</a> * <a class="code" href="evaluate_8cpp.html#a1bba8cd8d1268d1be05f381ef916bae0">V</a>, <span class="keywordtype">int</span> isign) {
<a name="l01097"></a>01097   <span class="keywordtype">int</span> <a class="code" href="parse__mdl_8y.html#a7e98b8a17c0aad30ba64d47b74e2a6c1">i</a>, k, <a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>;
<a name="l01098"></a>01098   <span class="keywordtype">int</span> <a class="code" href="parse__mdl_8y.html#aecba4cab5e52994730d1e21424997b33">n</a> = nlfreqs;
<a name="l01099"></a>01099   <span class="keywordtype">int</span> nd = dfreqs.size ();
<a name="l01100"></a>01100   <span class="keywordtype">int</span> <a class="code" href="parse__netlist_8y.html#a6da5270e48c8b5c2f0dbaa008af4df76">nodes</a> = V-&gt;<a class="code" href="classqucs_1_1tvector.html#ae03df40384f23435effac662f7fee1ce">size</a> () / <a class="code" href="parse__mdl_8y.html#aecba4cab5e52994730d1e21424997b33">n</a>;
<a name="l01101"></a>01101   <a class="code" href="config_8h.html#a014aadc409afb297b8247c13f8ca89be">nr_double_t</a> * <a class="code" href="parse__spice_8y.html#a873684cefeb665f3d5e6b495de57fc0d">d</a> = (<span class="keywordtype">double</span> *)V-&gt;<a class="code" href="classqucs_1_1tvector.html#aaa2c0afc40b8279080b5822f5df0bcb6">getData</a> ();
<a name="l01102"></a>01102 
<a name="l01103"></a>01103   <span class="keywordflow">if</span> (nd == 1) {
<a name="l01104"></a>01104     <span class="comment">// for each node a single 1d-FFT</span>
<a name="l01105"></a>01105     <span class="keywordflow">for</span> (k = i = 0; i &lt; <a class="code" href="parse__netlist_8y.html#a6da5270e48c8b5c2f0dbaa008af4df76">nodes</a>; i++, k += 2 * <a class="code" href="parse__mdl_8y.html#aecba4cab5e52994730d1e21424997b33">n</a>) {
<a name="l01106"></a>01106       <a class="code" href="config_8h.html#a014aadc409afb297b8247c13f8ca89be">nr_double_t</a> * dst = &amp;d[k];
<a name="l01107"></a>01107       <a class="code" href="namespacequcs_1_1fourier.html#a8cabcf94833c3ca61dda72e382a34186">_fft_1d</a> (dst, n, isign);
<a name="l01108"></a>01108       <span class="keywordflow">if</span> (isign &gt; 0) <span class="keywordflow">for</span> (r = 0; r &lt; 2 * <a class="code" href="parse__mdl_8y.html#aecba4cab5e52994730d1e21424997b33">n</a>; r++) *dst++ /= n;
<a name="l01109"></a>01109     }
<a name="l01110"></a>01110   }
<a name="l01111"></a>01111   <span class="keywordflow">else</span> {
<a name="l01112"></a>01112     <span class="comment">// for each node a single nd-FFT</span>
<a name="l01113"></a>01113     <span class="keywordflow">for</span> (k = i = 0; i &lt; <a class="code" href="parse__netlist_8y.html#a6da5270e48c8b5c2f0dbaa008af4df76">nodes</a>; i++, k += 2 * <a class="code" href="parse__mdl_8y.html#aecba4cab5e52994730d1e21424997b33">n</a>) {
<a name="l01114"></a>01114       <a class="code" href="config_8h.html#a014aadc409afb297b8247c13f8ca89be">nr_double_t</a> * dst = &amp;d[k];
<a name="l01115"></a>01115       <a class="code" href="namespacequcs_1_1fourier.html#aa3f50d54eceb4cd1477b8a4cbda37e75">_fft_nd</a> (dst, ndfreqs, nd, isign);
<a name="l01116"></a>01116       <span class="keywordflow">if</span> (isign &gt; 0) <span class="keywordflow">for</span> (r = 0; r &lt; 2 * <a class="code" href="parse__mdl_8y.html#aecba4cab5e52994730d1e21424997b33">n</a>; r++) *dst++ /= ndfreqs[0];
<a name="l01117"></a>01117     }
<a name="l01118"></a>01118   }
<a name="l01119"></a>01119 }
<a name="l01120"></a>01120 
<a name="l01121"></a>01121 <span class="comment">/* The following function transforms a vector using an Inverse Fast</span>
<a name="l01122"></a>01122 <span class="comment">   Fourier Transformation from the frequency domain to the domain</span>
<a name="l01123"></a>01123 <span class="comment">   time. */</span>
<a name="l01124"></a><a class="code" href="structqucs_1_1hbsolver.html#ac6b19644e03fe83d65d0155687897871">01124</a> <span class="keywordtype">void</span> hbsolver::VectorIFFT (<a class="code" href="classqucs_1_1tvector.html">tvector&lt;nr_complex_t&gt;</a> * <a class="code" href="evaluate_8cpp.html#a1bba8cd8d1268d1be05f381ef916bae0">V</a>, <span class="keywordtype">int</span> isign) {
<a name="l01125"></a>01125   VectorFFT (V, -isign);
<a name="l01126"></a>01126 }
<a name="l01127"></a>01127 
<a name="l01128"></a>01128 <span class="comment">/* The following function transforms a matrix using a Fast Fourier</span>
<a name="l01129"></a>01129 <span class="comment">   Transformation from the time domain to the frequency domain. */</span>
<a name="l01130"></a><a class="code" href="structqucs_1_1hbsolver.html#a8faf2495c88106bb01f726602af15594">01130</a> <span class="keywordtype">void</span> hbsolver::MatrixFFT (<a class="code" href="classqucs_1_1tmatrix.html">tmatrix&lt;nr_complex_t&gt;</a> * <a class="code" href="evaluate_8cpp.html#a92592142cb41364b6fe6ef9cc1a16dbd">M</a>) {
<a name="l01131"></a>01131 
<a name="l01132"></a>01132 <span class="preprocessor">#if THE_SLO_ALGO</span>
<a name="l01133"></a>01133 <span class="preprocessor"></span>  <span class="comment">// each column FFT</span>
<a name="l01134"></a>01134   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a> = 0; <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a> &lt; M-&gt;<a class="code" href="classqucs_1_1tmatrix.html#a0a547e71f1d404f7bfe84e59f8a68002">getCols</a> (); <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>++) {
<a name="l01135"></a>01135     <a class="code" href="classqucs_1_1tvector.html">tvector&lt;nr_complex_t&gt;</a> <a class="code" href="evaluate_8cpp.html#a1bba8cd8d1268d1be05f381ef916bae0">V</a> = M-&gt;<a class="code" href="classqucs_1_1tmatrix.html#a5fb5ca50336a70922c25adcc4f2ec9fb">getCol</a> (<a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>);
<a name="l01136"></a>01136     VectorFFT (&amp;V);
<a name="l01137"></a>01137     M-&gt;<a class="code" href="classqucs_1_1tmatrix.html#a770a67de552b985260839deee986e38b">setCol</a> (<a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>, V);
<a name="l01138"></a>01138   }
<a name="l01139"></a>01139 
<a name="l01140"></a>01140   <span class="comment">// each row IFFT</span>
<a name="l01141"></a>01141   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a> = 0; <a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a> &lt; M-&gt;<a class="code" href="classqucs_1_1tmatrix.html#a385186b201f85b07f85a0e6b6380d7e2">getRows</a> (); <a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>++) {
<a name="l01142"></a>01142     <a class="code" href="classqucs_1_1tvector.html">tvector&lt;nr_complex_t&gt;</a> <a class="code" href="evaluate_8cpp.html#a1bba8cd8d1268d1be05f381ef916bae0">V</a> = M-&gt;<a class="code" href="classqucs_1_1tmatrix.html#a118a178dae672ab0e9ddfdbf44fa715e">getRow</a> (<a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>);
<a name="l01143"></a>01143     VectorIFFT (&amp;V);
<a name="l01144"></a>01144     M-&gt;<a class="code" href="classqucs_1_1tmatrix.html#a987d5875ac30f9bec5cc7502923424df">setRow</a> (<a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>, V);
<a name="l01145"></a>01145   }
<a name="l01146"></a>01146 <span class="preprocessor">#else</span>
<a name="l01147"></a>01147 <span class="preprocessor"></span>  <span class="keywordtype">int</span> <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>, <a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>, nc, nr;
<a name="l01148"></a>01148   <span class="comment">// for each non-linear node block</span>
<a name="l01149"></a>01149   <span class="keywordflow">for</span> (nc = c = 0; c &lt; nbanodes; c++, nc += nlfreqs) {
<a name="l01150"></a>01150     <span class="keywordflow">for</span> (nr = r = 0; r &lt; nbanodes; r++, nr += nlfreqs) {
<a name="l01151"></a>01151       <a class="code" href="classqucs_1_1tvector.html">tvector&lt;nr_complex_t&gt;</a> <a class="code" href="evaluate_8cpp.html#a1bba8cd8d1268d1be05f381ef916bae0">V</a> (nlfreqs);
<a name="l01152"></a>01152       <span class="keywordtype">int</span> fr, fc, fi;
<a name="l01153"></a>01153       <span class="comment">// transform the sub-diagonal only</span>
<a name="l01154"></a>01154       <span class="keywordflow">for</span> (fc = 0; fc &lt; nlfreqs; fc++) V (fc) = M-&gt;<a class="code" href="classqucs_1_1tmatrix.html#aa5a2dd2a9f6b9bc12706ea410f8fb6b8">get</a> (nr + fc, nc + fc);
<a name="l01155"></a>01155       VectorFFT (&amp;V);
<a name="l01156"></a>01156       <span class="comment">// fill in resulting sub-matrix for the node</span>
<a name="l01157"></a>01157       <span class="keywordflow">for</span> (fc = 0; fc &lt; nlfreqs; fc++) {
<a name="l01158"></a>01158         <span class="keywordflow">for</span> (fi = nlfreqs - 1 - fc, fr = 0; fr &lt; nlfreqs; fr++) {
<a name="l01159"></a>01159           <span class="keywordflow">if</span> (++fi &gt;= nlfreqs) fi = 0;
<a name="l01160"></a>01160           M-&gt;<a class="code" href="classqucs_1_1tmatrix.html#a7080db9380664dad648e86b6c4bda6c5">set</a> (nr + fr, nc + fc, V (fi));
<a name="l01161"></a>01161         }
<a name="l01162"></a>01162       }
<a name="l01163"></a>01163     }
<a name="l01164"></a>01164   }
<a name="l01165"></a>01165 <span class="preprocessor">#endif</span>
<a name="l01166"></a>01166 <span class="preprocessor"></span>}
<a name="l01167"></a>01167 
<a name="l01168"></a>01168 <span class="comment">/* This function solves the actual HB equation in the frequency domain.</span>
<a name="l01169"></a>01169 <span class="comment">   F(V) = IC + [YV] * VS + j[O] * FQ + IG -&gt; 0</span>
<a name="l01170"></a>01170 <span class="comment">   Care must be taken with indexing here: In the frequency domain only</span>
<a name="l01171"></a>01171 <span class="comment">   real positive frequencies are used and computed, but in the time</span>
<a name="l01172"></a>01172 <span class="comment">   domain we have more values because of the periodic continuation in</span>
<a name="l01173"></a>01173 <span class="comment">   the frequency domain.</span>
<a name="l01174"></a>01174 <span class="comment">   RHS = j[O] * CV + GV - (IC + j[O] * FQ + IG)</span>
<a name="l01175"></a>01175 <span class="comment">   Also the right hand side of the equation system for the new voltage</span>
<a name="l01176"></a>01176 <span class="comment">   vector is computed here. */</span>
<a name="l01177"></a><a class="code" href="structqucs_1_1hbsolver.html#aa00c05dd5b01aac462d4b66e3e26502a">01177</a> <span class="keywordtype">void</span> hbsolver::solveHB (<span class="keywordtype">void</span>) {
<a name="l01178"></a>01178   <span class="comment">// for each non-linear node</span>
<a name="l01179"></a>01179   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a> = 0; <a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a> &lt; nbanodes * nlfreqs; ) {
<a name="l01180"></a>01180     <span class="comment">// for each frequency</span>
<a name="l01181"></a>01181     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> f = 0; f &lt; nlfreqs; f++, <a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>++) {
<a name="l01182"></a>01182       <a class="code" href="complex_8h.html#a7ad1a12245ad87a9d81d6bcc18afacae">nr_complex_t</a> il = 0.0, in = 0.0, ir = 0.0;
<a name="l01183"></a>01183       <span class="comment">// constant current vector due to sources</span>
<a name="l01184"></a>01184       il += IC-&gt;get (<a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>);
<a name="l01185"></a>01185       <span class="comment">// part 1 of right hand side vector</span>
<a name="l01186"></a>01186       ir -= il;
<a name="l01187"></a>01187       <span class="comment">// transadmittance matrix multiplied by voltage vector</span>
<a name="l01188"></a>01188       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a> = 0; <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a> &lt; nbanodes * nlfreqs; <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>++) {
<a name="l01189"></a>01189         il += <a class="code" href="hbsolver_8cpp.html#ae2fd71cd95de6ab6fe18e211906882de">YV_</a>(<a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>, <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>) * <a class="code" href="hbsolver_8cpp.html#a5375803daa109cf192e7fa011fc51358">VS_</a>(<a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>);
<a name="l01190"></a>01190       }
<a name="l01191"></a>01191       <span class="comment">// charge vector</span>
<a name="l01192"></a>01192       in += <a class="code" href="hbsolver_8cpp.html#aae67df46a02b4df8bf6f0222eef8e58a">OM_</a>(f) * FQ-&gt;get (<a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>);
<a name="l01193"></a>01193       <span class="comment">// current vector</span>
<a name="l01194"></a>01194       in += IG-&gt;get (<a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>);
<a name="l01195"></a>01195       <span class="comment">// part 2, 3 and 4 of right hand side vector</span>
<a name="l01196"></a>01196       ir += IR-&gt;get (<a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>);
<a name="l01197"></a>01197       ir += <a class="code" href="hbsolver_8cpp.html#aae67df46a02b4df8bf6f0222eef8e58a">OM_</a>(f) * QR-&gt;get (<a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>);
<a name="l01198"></a>01198       <span class="comment">// put values into result vectors</span>
<a name="l01199"></a>01199       RH-&gt;set (<a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>, ir);
<a name="l01200"></a>01200       FV-&gt;set (<a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>, il + in);
<a name="l01201"></a>01201       IL-&gt;set (<a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>, il);
<a name="l01202"></a>01202       IN-&gt;set (<a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>, in);
<a name="l01203"></a>01203     }
<a name="l01204"></a>01204   }
<a name="l01205"></a>01205 }
<a name="l01206"></a>01206 
<a name="l01207"></a>01207 <span class="comment">/* The function calculates the full Jacobian JF = [YV] + j[O] * JQ + JG */</span>
<a name="l01208"></a><a class="code" href="structqucs_1_1hbsolver.html#a00144a970673c4741dca8b15caf2abe9">01208</a> <span class="keywordtype">void</span> hbsolver::calcJacobian (<span class="keywordtype">void</span>) {
<a name="l01209"></a>01209   <span class="keywordtype">int</span> <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>, <a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>, fc, fr, rt, ct;
<a name="l01210"></a>01210   <span class="comment">/* add admittances of capacitance matrix JQ and non-linear</span>
<a name="l01211"></a>01211 <span class="comment">     admittances matrix JG into complete Jacobian JF */</span>
<a name="l01212"></a>01212   <span class="keywordflow">for</span> (c = 0; c &lt; nbanodes; c++) {
<a name="l01213"></a>01213     ct = c * nlfreqs;
<a name="l01214"></a>01214     <span class="keywordflow">for</span> (fc = 0; fc &lt; nlfreqs; fc++, ct++) {
<a name="l01215"></a>01215       <span class="keywordflow">for</span> (r = 0; r &lt; nbanodes; r++) {
<a name="l01216"></a>01216         rt = r * nlfreqs;
<a name="l01217"></a>01217         <span class="keywordflow">for</span> (fr = 0; fr &lt; nlfreqs; fr++, rt++) {
<a name="l01218"></a>01218           <a class="code" href="hbsolver_8cpp.html#a4354f165383797a1cea1b8e3f369f3c8">JF_</a>(rt, ct) = JG-&gt;get (rt, ct) + JQ-&gt;get (rt, ct) * <a class="code" href="hbsolver_8cpp.html#aae67df46a02b4df8bf6f0222eef8e58a">OM_</a>(fr);
<a name="l01219"></a>01219         }
<a name="l01220"></a>01220       }
<a name="l01221"></a>01221     }
<a name="l01222"></a>01222   }
<a name="l01223"></a>01223   *JF += *YV; <span class="comment">// add linear admittance matrix</span>
<a name="l01224"></a>01224 }
<a name="l01225"></a>01225 
<a name="l01226"></a>01226 <span class="comment">/* The function expands the given vector in the frequency domain to</span>
<a name="l01227"></a>01227 <span class="comment">   make it a real valued signal in the time domain. */</span>
<a name="l01228"></a><a class="code" href="structqucs_1_1hbsolver.html#ae95a922e497060d55b42697777633b49">01228</a> <a class="code" href="classqucs_1_1tvector.html">tvector&lt;nr_complex_t&gt;</a> hbsolver::expandVector (<a class="code" href="classqucs_1_1tvector.html">tvector&lt;nr_complex_t&gt;</a> <a class="code" href="evaluate_8cpp.html#a1bba8cd8d1268d1be05f381ef916bae0">V</a>,
<a name="l01229"></a>01229                                               <span class="keywordtype">int</span> <a class="code" href="parse__netlist_8y.html#a6da5270e48c8b5c2f0dbaa008af4df76">nodes</a>) {
<a name="l01230"></a>01230   <a class="code" href="classqucs_1_1tvector.html">tvector&lt;nr_complex_t&gt;</a> res (nodes * nlfreqs);
<a name="l01231"></a>01231   <span class="keywordtype">int</span> <a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>, ff, rf, rt;
<a name="l01232"></a>01232   <span class="keywordflow">for</span> (r = 0; r &lt; <a class="code" href="parse__netlist_8y.html#a6da5270e48c8b5c2f0dbaa008af4df76">nodes</a>; r++) {
<a name="l01233"></a>01233     rt = r * nlfreqs;
<a name="l01234"></a>01234     rf = r * lnfreqs;
<a name="l01235"></a>01235     <span class="comment">// copy first part of vector</span>
<a name="l01236"></a>01236     <span class="keywordflow">for</span> (ff = 0; ff &lt; lnfreqs; ff++, rf++, rt++) {
<a name="l01237"></a>01237       res (rt) = <a class="code" href="evaluate_8cpp.html#a1bba8cd8d1268d1be05f381ef916bae0">V</a> (rf);
<a name="l01238"></a>01238     }
<a name="l01239"></a>01239     <span class="comment">// continue vector conjugated</span>
<a name="l01240"></a>01240     <span class="keywordflow">for</span> (rf -= 2; ff &lt; nlfreqs; ff++, rf--, rt++) {
<a name="l01241"></a>01241       res (rt) = <a class="code" href="namespacequcs.html#a691eba7985bd59b01aa1d5d5b845027b" title="Conjugate complex matrix.">conj</a> (V (rf));
<a name="l01242"></a>01242     }
<a name="l01243"></a>01243   }
<a name="l01244"></a>01244   <span class="keywordflow">return</span> res;
<a name="l01245"></a>01245 }
<a name="l01246"></a>01246 
<a name="l01247"></a>01247 <span class="comment">/* The function expands the given matrix in the frequency domain to</span>
<a name="l01248"></a>01248 <span class="comment">   make it a real valued signal in the time domain. */</span>
<a name="l01249"></a><a class="code" href="structqucs_1_1hbsolver.html#a23a3d276408ea6334fda272249cf01e9">01249</a> <a class="code" href="classqucs_1_1tmatrix.html">tmatrix&lt;nr_complex_t&gt;</a> hbsolver::expandMatrix (<a class="code" href="classqucs_1_1tmatrix.html">tmatrix&lt;nr_complex_t&gt;</a> <a class="code" href="evaluate_8cpp.html#a92592142cb41364b6fe6ef9cc1a16dbd">M</a>,
<a name="l01250"></a>01250                                               <span class="keywordtype">int</span> <a class="code" href="parse__netlist_8y.html#a6da5270e48c8b5c2f0dbaa008af4df76">nodes</a>) {
<a name="l01251"></a>01251   <a class="code" href="classqucs_1_1tmatrix.html">tmatrix&lt;nr_complex_t&gt;</a> res (nodes * nlfreqs);
<a name="l01252"></a>01252   <span class="keywordtype">int</span> <a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>, <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>, rf, rt, cf, ct, ff;
<a name="l01253"></a>01253   <span class="keywordflow">for</span> (r = 0; r &lt; <a class="code" href="parse__netlist_8y.html#a6da5270e48c8b5c2f0dbaa008af4df76">nodes</a>; r++) {
<a name="l01254"></a>01254     <span class="keywordflow">for</span> (c = 0; c &lt; <a class="code" href="parse__netlist_8y.html#a6da5270e48c8b5c2f0dbaa008af4df76">nodes</a>; c++) {
<a name="l01255"></a>01255       rf = r * lnfreqs;
<a name="l01256"></a>01256       rt = r * nlfreqs;
<a name="l01257"></a>01257       cf = c * lnfreqs;
<a name="l01258"></a>01258       ct = c * nlfreqs;
<a name="l01259"></a>01259       <span class="comment">// copy first part of diagonal</span>
<a name="l01260"></a>01260       <span class="keywordflow">for</span> (ff = 0; ff &lt; lnfreqs; ff++, cf++, ct++, rf++, rt++) {
<a name="l01261"></a>01261         res (rt, ct) = <a class="code" href="evaluate_8cpp.html#a92592142cb41364b6fe6ef9cc1a16dbd">M</a> (rf, cf);
<a name="l01262"></a>01262       }
<a name="l01263"></a>01263       <span class="comment">// continue diagonal conjugated</span>
<a name="l01264"></a>01264       <span class="keywordflow">for</span> (cf -= 2, rf -= 2; ff &lt; nlfreqs; ff++, cf--, ct++, rf--, rt++) {
<a name="l01265"></a>01265         res (rt, ct) = <a class="code" href="namespacequcs.html#a691eba7985bd59b01aa1d5d5b845027b" title="Conjugate complex matrix.">conj</a> (M (rf, cf));
<a name="l01266"></a>01266       }
<a name="l01267"></a>01267     }
<a name="l01268"></a>01268   }
<a name="l01269"></a>01269   <span class="keywordflow">return</span> res;
<a name="l01270"></a>01270 }
<a name="l01271"></a>01271 
<a name="l01272"></a>01272 <span class="comment">/* This function solves the equation system</span>
<a name="l01273"></a>01273 <span class="comment">   JF * VS(n+1) = JF * VS(n) - FV</span>
<a name="l01274"></a>01274 <span class="comment">   in order to obtains a new voltage vector in the frequency domain. */</span>
<a name="l01275"></a><a class="code" href="structqucs_1_1hbsolver.html#a142931743b8246128d613bf57ef0aa0f">01275</a> <span class="keywordtype">void</span> hbsolver::solveVoltages (<span class="keywordtype">void</span>) {
<a name="l01276"></a>01276   <span class="comment">// save previous iteration voltage</span>
<a name="l01277"></a>01277   *VP = *VS;
<a name="l01278"></a>01278 
<a name="l01279"></a>01279   <span class="comment">// setup equation system</span>
<a name="l01280"></a>01280   <a class="code" href="classqucs_1_1eqnsys.html">eqnsys&lt;nr_complex_t&gt;</a> <a class="code" href="parse__netlist_8y.html#aad664ad10957bf531dcce47612c7677a">eqns</a>;
<a name="l01281"></a>01281   <a class="code" href="exceptionstack_8h.html#a5123cac5cf3369997ae7bc31d5f1e1ce">try_running</a> () {
<a name="l01282"></a>01282     <span class="comment">// use LU decomposition for solving</span>
<a name="l01283"></a>01283     eqns.<a class="code" href="classqucs_1_1eqnsys.html#a8f296af94985c93e84febc130bcd8901">setAlgo</a> (<a class="code" href="eqnsys_8h.html#a92b72228de8e945a7cbdf109a4e3c14fa6cea149798988dc30e1b4186f8a3c8dd">ALGO_LU_DECOMPOSITION</a>);
<a name="l01284"></a>01284     eqns.<a class="code" href="classqucs_1_1eqnsys.html#aa6b55148a64ff0e9b3afb8a7e76afae9">passEquationSys</a> (JF, VS, RH);
<a name="l01285"></a>01285     eqns.<a class="code" href="classqucs_1_1eqnsys.html#a8c2dfc7e3116a729c92ec356bca70ad6">solve</a> ();
<a name="l01286"></a>01286   }
<a name="l01287"></a>01287   <span class="comment">// appropriate exception handling</span>
<a name="l01288"></a>01288   <a class="code" href="exceptionstack_8h.html#a1bcd5362715dd5fbe069fdf9f9b96399">catch_exception</a> () {
<a name="l01289"></a>01289   <span class="keywordflow">case</span> <a class="code" href="structqucs.html#ac060e999cf6725990fdd6c65600a62e5a732ab89ae14ddf9050b060b500c84177">EXCEPTION_PIVOT</a>:
<a name="l01290"></a>01290   <span class="keywordflow">default</span>:
<a name="l01291"></a>01291     <a class="code" href="logging_8c.html#abe06a8732a47a291606edcfac5e5146e">logprint</a> (<a class="code" href="logging_8h.html#aced66975c154ea0e2a8ec3bc818b4e08">LOG_ERROR</a>, <span class="stringliteral">&quot;WARNING: %s: during NR iteration\n&quot;</span>, getName ());
<a name="l01292"></a>01292     <a class="code" href="structqucs.html#a99a68a2452092cafcd735a48a064a8bf">estack</a>.<a class="code" href="classqucs_1_1exceptionstack.html#a486af86b492f662998c8d7ced9ecd64f">print</a> ();
<a name="l01293"></a>01293   }
<a name="l01294"></a>01294 
<a name="l01295"></a>01295   <span class="comment">// save new voltages in time domain vector</span>
<a name="l01296"></a>01296   *vs = *VS;
<a name="l01297"></a>01297 }
<a name="l01298"></a>01298 
<a name="l01299"></a>01299 <span class="comment">/* The following function extends the existing linear MNA matrix to</span>
<a name="l01300"></a>01300 <span class="comment">   contain the additional rows and columns for the excitation voltage</span>
<a name="l01301"></a>01301 <span class="comment">   sources. */</span>
<a name="l01302"></a><a class="code" href="structqucs_1_1hbsolver.html#ad06745b0d9e490248c2927567058c86b">01302</a> <a class="code" href="classqucs_1_1tmatrix.html">tmatrix&lt;nr_complex_t&gt;</a> hbsolver::extendMatrixLinear (<a class="code" href="classqucs_1_1tmatrix.html">tmatrix&lt;nr_complex_t&gt;</a> <a class="code" href="evaluate_8cpp.html#a92592142cb41364b6fe6ef9cc1a16dbd">M</a>,
<a name="l01303"></a>01303                                                     <span class="keywordtype">int</span> <a class="code" href="parse__netlist_8y.html#a6da5270e48c8b5c2f0dbaa008af4df76">nodes</a>) {
<a name="l01304"></a>01304   <span class="keywordtype">int</span> no = M.<a class="code" href="classqucs_1_1tmatrix.html#a0a547e71f1d404f7bfe84e59f8a68002">getCols</a> ();
<a name="l01305"></a>01305   <a class="code" href="classqucs_1_1tmatrix.html">tmatrix&lt;nr_complex_t&gt;</a> res (no + nodes * lnfreqs);
<a name="l01306"></a>01306   <span class="comment">// copy the existing part</span>
<a name="l01307"></a>01307   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a> = 0; <a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a> &lt; no; <a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>++) {
<a name="l01308"></a>01308     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a> = 0; <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a> &lt; no; <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>++) {
<a name="l01309"></a>01309       res (<a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>, <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>) = <a class="code" href="evaluate_8cpp.html#a92592142cb41364b6fe6ef9cc1a16dbd">M</a> (<a class="code" href="parse__mdl_8y.html#a514f1b439f404f86f77090fa9edc96ce">r</a>, <a class="code" href="parse__netlist_8y.html#a519cf159c27abd2374c9f649b9e9946d">c</a>);
<a name="l01310"></a>01310     }
<a name="l01311"></a>01311   }
<a name="l01312"></a>01312   <span class="keywordflow">return</span> res;
<a name="l01313"></a>01313 }
<a name="l01314"></a>01314 
<a name="l01315"></a>01315 <span class="comment">/* The function fills in the missing MNA entries for the excitation</span>
<a name="l01316"></a>01316 <span class="comment">   voltage sources into the extended rows and columns as well as the</span>
<a name="l01317"></a>01317 <span class="comment">   actual voltage values into the right hand side vector. */</span>
<a name="l01318"></a><a class="code" href="structqucs_1_1hbsolver.html#aa220817d9c72080fe0a287aa529d19de">01318</a> <span class="keywordtype">void</span> hbsolver::fillMatrixLinearExtended (<a class="code" href="classqucs_1_1tmatrix.html">tmatrix&lt;nr_complex_t&gt;</a> * Y,
<a name="l01319"></a>01319                                          <a class="code" href="classqucs_1_1tvector.html">tvector&lt;nr_complex_t&gt;</a> * I) {
<a name="l01320"></a>01320   <span class="comment">// through each excitation source</span>
<a name="l01321"></a>01321   <span class="keywordtype">int</span> of = lnfreqs * (nlnvsrcs + nnanodes);
<a name="l01322"></a>01322   <span class="keywordtype">int</span> sc = of;
<a name="l01323"></a>01323 
<a name="l01324"></a>01324   <span class="keywordflow">for</span> (<span class="keyword">auto</span> *vs : excitations) {
<a name="l01325"></a>01325     <span class="comment">// get positive and negative node</span>
<a name="l01326"></a>01326     <span class="keywordtype">int</span> pnode = vs-&gt;getNode(<a class="code" href="circuit_8h.html#a4f0d36c5244b59c0f92e7704ac05647f">NODE_1</a>)-&gt;getNode ();
<a name="l01327"></a>01327     <span class="keywordtype">int</span> nnode = vs-&gt;getNode(<a class="code" href="circuit_8h.html#a6685ff6eaa6d17e48acf55cc8434eaed">NODE_2</a>)-&gt;getNode ();
<a name="l01328"></a>01328     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> f = 0; f &lt; lnfreqs; f++, sc++) { <span class="comment">// for each frequency</span>
<a name="l01329"></a>01329       <span class="comment">// fill right hand side vector</span>
<a name="l01330"></a>01330       <a class="code" href="config_8h.html#a014aadc409afb297b8247c13f8ca89be">nr_double_t</a> freq = rfreqs[f];
<a name="l01331"></a>01331       vs-&gt;calcHB (freq);
<a name="l01332"></a>01332       <a class="code" href="hbsolver_8cpp.html#acf616472cca1fa9706b90b01fcc36a7c">I_</a>(sc) = vs-&gt;getE (<a class="code" href="circuit_8h.html#ace17100f8a8b6ff4abc3f9d5d1bd38b8">VSRC_1</a>);
<a name="l01333"></a>01333       <span class="comment">// fill MNA entries</span>
<a name="l01334"></a>01334       <span class="keywordtype">int</span> pn = (pnode - 1) * lnfreqs + f;
<a name="l01335"></a>01335       <span class="keywordtype">int</span> nn = (nnode - 1) * lnfreqs + f;
<a name="l01336"></a>01336       <span class="keywordflow">if</span> (pnode) {
<a name="l01337"></a>01337         <a class="code" href="hbsolver_8cpp.html#a65b540c60db9fbef992309300a3007f3">Y_</a>(pn, sc) = +1.0;
<a name="l01338"></a>01338         <a class="code" href="hbsolver_8cpp.html#a65b540c60db9fbef992309300a3007f3">Y_</a>(sc, pn) = +1.0;
<a name="l01339"></a>01339       }
<a name="l01340"></a>01340       <span class="keywordflow">if</span> (nnode) {
<a name="l01341"></a>01341         <a class="code" href="hbsolver_8cpp.html#a65b540c60db9fbef992309300a3007f3">Y_</a>(nn, sc) = -1.0;
<a name="l01342"></a>01342         <a class="code" href="hbsolver_8cpp.html#a65b540c60db9fbef992309300a3007f3">Y_</a>(sc, nn) = -1.0;
<a name="l01343"></a>01343       }
<a name="l01344"></a>01344     }
<a name="l01345"></a>01345   }
<a name="l01346"></a>01346 }
<a name="l01347"></a>01347 
<a name="l01348"></a>01348 <span class="comment">/* The function calculates and saves the final solution. */</span>
<a name="l01349"></a><a class="code" href="structqucs_1_1hbsolver.html#ae868549228ba62bf281a91bbc9ace16f">01349</a> <span class="keywordtype">void</span> hbsolver::finalSolution (<span class="keywordtype">void</span>) {
<a name="l01350"></a>01350 
<a name="l01351"></a>01351   <span class="comment">// extend the linear MNA matrix</span>
<a name="l01352"></a>01352   *NA = extendMatrixLinear (*NA, nnlvsrcs);
<a name="l01353"></a>01353 
<a name="l01354"></a>01354   <span class="keywordtype">int</span> <a class="code" href="property_8cpp.html#ab14b3c1e9fec18e9a3000b0b1a80ac77">S</a> = NA-&gt;getCols ();
<a name="l01355"></a>01355   <span class="keywordtype">int</span> <a class="code" href="equation_8cpp.html#a540f72cb9bcf86a19e3bbc259b9ec3e0">N</a> = nnanodes * lnfreqs;
<a name="l01356"></a>01356 
<a name="l01357"></a>01357   <span class="comment">// right hand side vector</span>
<a name="l01358"></a>01358   <a class="code" href="classqucs_1_1tvector.html">tvector&lt;nr_complex_t&gt;</a> * I = <span class="keyword">new</span> <a class="code" href="classqucs_1_1tvector.html">tvector&lt;nr_complex_t&gt;</a> (<a class="code" href="property_8cpp.html#ab14b3c1e9fec18e9a3000b0b1a80ac77">S</a>);
<a name="l01359"></a>01359   <span class="comment">// temporary solution</span>
<a name="l01360"></a>01360   <a class="code" href="classqucs_1_1tvector.html">tvector&lt;nr_complex_t&gt;</a> * <a class="code" href="evaluate_8cpp.html#a1bba8cd8d1268d1be05f381ef916bae0">V</a> = <span class="keyword">new</span> <a class="code" href="classqucs_1_1tvector.html">tvector&lt;nr_complex_t&gt;</a> (<a class="code" href="property_8cpp.html#ab14b3c1e9fec18e9a3000b0b1a80ac77">S</a>);
<a name="l01361"></a>01361   <span class="comment">// final solution</span>
<a name="l01362"></a>01362   <a class="code" href="parse__mdl_8y.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a> = <span class="keyword">new</span> <a class="code" href="classqucs_1_1tvector.html">tvector&lt;nr_complex_t&gt;</a> (<a class="code" href="equation_8cpp.html#a540f72cb9bcf86a19e3bbc259b9ec3e0">N</a>);
<a name="l01363"></a>01363 
<a name="l01364"></a>01364   <span class="comment">// fill in missing MNA entries</span>
<a name="l01365"></a>01365   fillMatrixLinearExtended (NA, I);
<a name="l01366"></a>01366 
<a name="l01367"></a>01367   <span class="comment">// put currents through balanced nodes into right hand side</span>
<a name="l01368"></a>01368   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code" href="parse__mdl_8y.html#aecba4cab5e52994730d1e21424997b33">n</a> = 0; <a class="code" href="parse__mdl_8y.html#aecba4cab5e52994730d1e21424997b33">n</a> &lt; nbanodes; <a class="code" href="parse__mdl_8y.html#aecba4cab5e52994730d1e21424997b33">n</a>++) {
<a name="l01369"></a>01369     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> f = 0; f &lt; lnfreqs; f++) {
<a name="l01370"></a>01370       <a class="code" href="complex_8h.html#a7ad1a12245ad87a9d81d6bcc18afacae">nr_complex_t</a> <a class="code" href="parse__mdl_8y.html#a7e98b8a17c0aad30ba64d47b74e2a6c1">i</a> = IL-&gt;get (<a class="code" href="parse__mdl_8y.html#aecba4cab5e52994730d1e21424997b33">n</a> * nlfreqs + f);
<a name="l01371"></a>01371       <span class="keywordflow">if</span> (f != 0 &amp;&amp; f != lnfreqs - 1) i *= 2;
<a name="l01372"></a>01372       <a class="code" href="hbsolver_8cpp.html#acf616472cca1fa9706b90b01fcc36a7c">I_</a>(<a class="code" href="parse__mdl_8y.html#aecba4cab5e52994730d1e21424997b33">n</a> * lnfreqs + f) = <a class="code" href="parse__mdl_8y.html#a7e98b8a17c0aad30ba64d47b74e2a6c1">i</a>;
<a name="l01373"></a>01373     }
<a name="l01374"></a>01374   }
<a name="l01375"></a>01375 
<a name="l01376"></a>01376   <span class="comment">// use QR decomposition for the final solution</span>
<a name="l01377"></a>01377   <a class="code" href="exceptionstack_8h.html#a5123cac5cf3369997ae7bc31d5f1e1ce">try_running</a> () {
<a name="l01378"></a>01378     <a class="code" href="classqucs_1_1eqnsys.html">eqnsys&lt;nr_complex_t&gt;</a> <a class="code" href="parse__netlist_8y.html#aad664ad10957bf531dcce47612c7677a">eqns</a>;
<a name="l01379"></a>01379     eqns.<a class="code" href="classqucs_1_1eqnsys.html#a8f296af94985c93e84febc130bcd8901">setAlgo</a> (<a class="code" href="eqnsys_8h.html#a92b72228de8e945a7cbdf109a4e3c14fa6cea149798988dc30e1b4186f8a3c8dd">ALGO_LU_DECOMPOSITION</a>);
<a name="l01380"></a>01380     eqns.<a class="code" href="classqucs_1_1eqnsys.html#aa6b55148a64ff0e9b3afb8a7e76afae9">passEquationSys</a> (NA, V, I);
<a name="l01381"></a>01381     eqns.<a class="code" href="classqucs_1_1eqnsys.html#a8c2dfc7e3116a729c92ec356bca70ad6">solve</a> ();
<a name="l01382"></a>01382   }
<a name="l01383"></a>01383   <span class="comment">// appropriate exception handling</span>
<a name="l01384"></a>01384   <a class="code" href="exceptionstack_8h.html#a1bcd5362715dd5fbe069fdf9f9b96399">catch_exception</a> () {
<a name="l01385"></a>01385   <span class="keywordflow">case</span> <a class="code" href="structqucs.html#ac060e999cf6725990fdd6c65600a62e5a732ab89ae14ddf9050b060b500c84177">EXCEPTION_PIVOT</a>:
<a name="l01386"></a>01386   <span class="keywordflow">default</span>:
<a name="l01387"></a>01387     <a class="code" href="logging_8c.html#abe06a8732a47a291606edcfac5e5146e">logprint</a> (<a class="code" href="logging_8h.html#aced66975c154ea0e2a8ec3bc818b4e08">LOG_ERROR</a>, <span class="stringliteral">&quot;WARNING: %s: during final AC analysis\n&quot;</span>,
<a name="l01388"></a>01388               getName ());
<a name="l01389"></a>01389     <a class="code" href="structqucs.html#a99a68a2452092cafcd735a48a064a8bf">estack</a>.<a class="code" href="classqucs_1_1exceptionstack.html#a486af86b492f662998c8d7ced9ecd64f">print</a> ();
<a name="l01390"></a>01390   }
<a name="l01391"></a>01391   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code" href="parse__mdl_8y.html#a7e98b8a17c0aad30ba64d47b74e2a6c1">i</a> = 0; <a class="code" href="parse__mdl_8y.html#a7e98b8a17c0aad30ba64d47b74e2a6c1">i</a> &lt; <a class="code" href="equation_8cpp.html#a540f72cb9bcf86a19e3bbc259b9ec3e0">N</a>; <a class="code" href="parse__mdl_8y.html#a7e98b8a17c0aad30ba64d47b74e2a6c1">i</a>++) x-&gt;<a class="code" href="classqucs_1_1tvector.html#a0e3bc3de4b28ad95b779c6e054bf4c88">set</a> (<a class="code" href="parse__mdl_8y.html#a7e98b8a17c0aad30ba64d47b74e2a6c1">i</a>, <a class="code" href="hbsolver_8cpp.html#a1d582ab0a74305d73a8d52218c35d12e">V_</a>(<a class="code" href="parse__mdl_8y.html#a7e98b8a17c0aad30ba64d47b74e2a6c1">i</a>));
<a name="l01392"></a>01392 }
<a name="l01393"></a>01393 
<a name="l01394"></a>01394 <span class="comment">// Saves simulation results.</span>
<a name="l01395"></a><a class="code" href="structqucs_1_1hbsolver.html#a30af43ea6d7b9ff5f57964cefc413009">01395</a> <span class="keywordtype">void</span> hbsolver::saveResults (<span class="keywordtype">void</span>) {
<a name="l01396"></a>01396   <a class="code" href="classqucs_1_1vector.html">vector</a> * f;
<a name="l01397"></a>01397   <span class="comment">// add current frequency to the dependency of the output dataset</span>
<a name="l01398"></a>01398   <span class="keywordflow">if</span> ((f = <a class="code" href="parse__citi_8y.html#a511ae0b1c13f95e5f08f1a0dd3da3d93">data</a>-&gt;findDependency (<span class="stringliteral">&quot;hbfrequency&quot;</span>)) == NULL) {
<a name="l01399"></a>01399     f = <span class="keyword">new</span> <a class="code" href="classqucs_1_1vector.html">vector</a> (<span class="stringliteral">&quot;hbfrequency&quot;</span>);
<a name="l01400"></a>01400     <a class="code" href="parse__citi_8y.html#a511ae0b1c13f95e5f08f1a0dd3da3d93">data</a>-&gt;addDependency (f);
<a name="l01401"></a>01401   }
<a name="l01402"></a>01402   <span class="comment">// save frequency vector</span>
<a name="l01403"></a>01403   <span class="keywordflow">if</span> (runs == 1) {
<a name="l01404"></a>01404     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code" href="parse__mdl_8y.html#a7e98b8a17c0aad30ba64d47b74e2a6c1">i</a> = 0; <a class="code" href="parse__mdl_8y.html#a7e98b8a17c0aad30ba64d47b74e2a6c1">i</a> &lt; lnfreqs; <a class="code" href="parse__mdl_8y.html#a7e98b8a17c0aad30ba64d47b74e2a6c1">i</a>++) f-&gt;<a class="code" href="classqucs_1_1vector.html#a281fd644d9b0e1bf00d2e98a06de0d20">add</a> (rfreqs[<a class="code" href="parse__mdl_8y.html#a7e98b8a17c0aad30ba64d47b74e2a6c1">i</a>]);
<a name="l01405"></a>01405   }
<a name="l01406"></a>01406   <span class="comment">// save node voltage vectors</span>
<a name="l01407"></a>01407   <span class="keywordtype">int</span> nanode = 0;
<a name="l01408"></a>01408   <span class="keywordflow">for</span> (<a class="code" href="classqucs_1_1strlistiterator.html">strlistiterator</a> it (nanodes); *it; ++it, nanode++) {
<a name="l01409"></a>01409     <span class="keywordtype">int</span> l = strlen (*it);
<a name="l01410"></a>01410     <span class="keywordtype">char</span> * <a class="code" href="parse__mdl_8y.html#aecba4cab5e52994730d1e21424997b33">n</a> = (<span class="keywordtype">char</span> *) malloc (l + 4);
<a name="l01411"></a>01411     sprintf (n, <span class="stringliteral">&quot;%s.Vb&quot;</span>, *it);
<a name="l01412"></a>01412     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code" href="parse__mdl_8y.html#a7e98b8a17c0aad30ba64d47b74e2a6c1">i</a> = 0; <a class="code" href="parse__mdl_8y.html#a7e98b8a17c0aad30ba64d47b74e2a6c1">i</a> &lt; lnfreqs; <a class="code" href="parse__mdl_8y.html#a7e98b8a17c0aad30ba64d47b74e2a6c1">i</a>++) {
<a name="l01413"></a>01413       saveVariable (n, <a class="code" href="parse__mdl_8y.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>-&gt;get (<a class="code" href="parse__mdl_8y.html#a7e98b8a17c0aad30ba64d47b74e2a6c1">i</a> + nanode * lnfreqs), f);
<a name="l01414"></a>01414     }
<a name="l01415"></a>01415   }
<a name="l01416"></a>01416 }
<a name="l01417"></a>01417 
<a name="l01418"></a>01418 <span class="comment">// properties</span>
<a name="l01419"></a>01419 <a class="code" href="structqucs.html#a22dddfa38928996c2851157e7609cc33">PROP_REQ</a> [] = {
<a name="l01420"></a>01420   { <span class="stringliteral">&quot;n&quot;</span>, <a class="code" href="netdefs_8h.html#a1a52c37e7df2d230169832d17a1c0c5c">PROP_INT</a>, { 1, <a class="code" href="netdefs_8h.html#a4d0941b8422de2007248d250c7c5c9ed">PROP_NO_STR</a> }, <a class="code" href="netdefs_8h.html#a87f670224851c2a44bfa1be44eddbb13">PROP_MIN_VAL</a> (1) },
<a name="l01421"></a>01421   <a class="code" href="netdefs_8h.html#abe2affa5f22fc12b66df2bb2c385af8b">PROP_NO_PROP</a> };
<a name="l01422"></a>01422 <a class="code" href="structqucs.html#a23d1ecdd5939cc3ab98c05aed05eb1be">PROP_OPT</a> [] = {
<a name="l01423"></a>01423   { <span class="stringliteral">&quot;f&quot;</span>, <a class="code" href="netdefs_8h.html#affd5c5788fc34f8a0ab1b07b77604103">PROP_REAL</a>, { 1e9, <a class="code" href="netdefs_8h.html#a4d0941b8422de2007248d250c7c5c9ed">PROP_NO_STR</a> }, <a class="code" href="netdefs_8h.html#a4129c2429762ec32998c31828cb36a57">PROP_POS_RANGEX</a> },
<a name="l01424"></a>01424   { <span class="stringliteral">&quot;iabstol&quot;</span>, <a class="code" href="netdefs_8h.html#affd5c5788fc34f8a0ab1b07b77604103">PROP_REAL</a>, { 1<a class="code" href="group__qucsMathConstants.html#gae162651ba6f0c9b150cf9bd8c41113c8" title="Euler&#39;s constant ( )">e</a>-12, <a class="code" href="netdefs_8h.html#a4d0941b8422de2007248d250c7c5c9ed">PROP_NO_STR</a> }, <a class="code" href="netdefs_8h.html#a7e9ba27c049eba55e49f20f4fc4c2f03">PROP_RNG_X01I</a> },
<a name="l01425"></a>01425   { <span class="stringliteral">&quot;vabstol&quot;</span>, <a class="code" href="netdefs_8h.html#affd5c5788fc34f8a0ab1b07b77604103">PROP_REAL</a>, { 1<a class="code" href="group__qucsMathConstants.html#gae162651ba6f0c9b150cf9bd8c41113c8" title="Euler&#39;s constant ( )">e</a>-6, <a class="code" href="netdefs_8h.html#a4d0941b8422de2007248d250c7c5c9ed">PROP_NO_STR</a> }, <a class="code" href="netdefs_8h.html#a7e9ba27c049eba55e49f20f4fc4c2f03">PROP_RNG_X01I</a> },
<a name="l01426"></a>01426   { <span class="stringliteral">&quot;reltol&quot;</span>, <a class="code" href="netdefs_8h.html#affd5c5788fc34f8a0ab1b07b77604103">PROP_REAL</a>, { 1<a class="code" href="group__qucsMathConstants.html#gae162651ba6f0c9b150cf9bd8c41113c8" title="Euler&#39;s constant ( )">e</a>-3, <a class="code" href="netdefs_8h.html#a4d0941b8422de2007248d250c7c5c9ed">PROP_NO_STR</a> }, <a class="code" href="netdefs_8h.html#a7e9ba27c049eba55e49f20f4fc4c2f03">PROP_RNG_X01I</a> },
<a name="l01427"></a>01427   { <span class="stringliteral">&quot;MaxIter&quot;</span>, <a class="code" href="netdefs_8h.html#a1a52c37e7df2d230169832d17a1c0c5c">PROP_INT</a>, { 150, <a class="code" href="netdefs_8h.html#a4d0941b8422de2007248d250c7c5c9ed">PROP_NO_STR</a> }, <a class="code" href="netdefs_8h.html#aa6ae43a3d5db7a8e127e51641f27de7c">PROP_RNGII</a> (2, 10000) },
<a name="l01428"></a>01428   <a class="code" href="netdefs_8h.html#abe2affa5f22fc12b66df2bb2c385af8b">PROP_NO_PROP</a> };
<a name="l01429"></a><a class="code" href="structqucs_1_1hbsolver.html">01429</a> <span class="keyword">struct </span><a class="code" href="structdefine__t.html">define_t</a> <a class="code" href="structqucs_1_1hbsolver.html">hbsolver</a>::anadef =
<a name="l01430"></a><a class="code" href="structqucs_1_1hbsolver.html#af8fb5c7f4e9eb9880c6d81ae698ffa56">01430</a>   { <span class="stringliteral">&quot;HB&quot;</span>, 0, <a class="code" href="netdefs_8h.html#a7f2eed3c8b53ad19237413982b693f6f">PROP_ACTION</a>, <a class="code" href="structqucs_1_1hbsolver.html#af8fb5c7f4e9eb9880c6d81ae698ffa56">PROP_NO_SUBSTRATE</a>, <a class="code" href="netdefs_8h.html#abbc3dc5d6e7ed19e109e2c80caba81bf">PROP_LINEAR</a>, <a class="code" href="netdefs_8h.html#acd1661cbcb5d1e27c3cf1b93f5ef8153">PROP_DEF</a> };
<a name="l01431"></a>01431 
<a name="l01432"></a>01432 } <span class="comment">// namespace qucs</span>
<a name="l01433"></a>01433 
<a name="l01434"></a>01434 <span class="comment">/* TODO list for HB Solver:</span>
<a name="l01435"></a>01435 <span class="comment">   - Take care about nodes with non-linear components only.</span>
<a name="l01436"></a>01436 <span class="comment">   - AC Power Sources (extra Z and open loop voltage).</span>
<a name="l01437"></a>01437 <span class="comment">   - Current sources.</span>
<a name="l01438"></a>01438 <span class="comment">   - Balancing of multi-dimensional non-linear networks.</span>
<a name="l01439"></a>01439 <span class="comment">   - Sources directly connected to non-linear components and no other</span>
<a name="l01440"></a>01440 <span class="comment">     linear component (insert short).</span>
<a name="l01441"></a>01441 <span class="comment">   - Bug: With capacitors at hand there is voltage convergence but no</span>
<a name="l01442"></a>01442 <span class="comment">     current balancing.</span>
<a name="l01443"></a>01443 <span class="comment">   - Output currents through voltage sources.</span>
<a name="l01444"></a>01444 <span class="comment"> */</span>
</pre></div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Sat Jan 24 2015 10:24:29 for Qucs-core by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
